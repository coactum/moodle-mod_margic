{"version":3,"file":"types.min.js","sources":["../src/types.js"],"sourcesContent":["/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport { matchQuote } from './match-quote';\nimport { TextRange, TextPosition } from './text-range';\nimport { nodeFromXPath, xpathFromNode } from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    // console.log('RangeAnchor -> fromSelector before nodeFromXPATH');\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    // console.log('after nodeFromXPATH');\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n\n    // console.log('types.js -> toSelector this.range');\n    // console.log(this.range);\n\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    // console.log('types.js -> toSelector normalizedRange');\n    // console.log(normalizedRange);\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    console.log('TextPositionAnchor -> fromRange root');\n    console.log(root);\n\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n    // const match = text.match(this.exact);\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n"],"names":["RangeAnchor","root","range","this","normalizedRange","TextRange","fromRange","toRange","textRange","startContainer","start","element","endContainer","end","type","startOffset","offset","endOffset","selector","Error","startPos","TextPosition","fromCharOffset","endPos","TextPositionAnchor","fromOffsets","console","log","relativeTo","TextQuoteAnchor","exact","context","prefix","suffix","options","toPositionAnchor","text","textContent","match","hint","slice","Math","max","min","length"],"mappings":"01DA2BaA,4CAKCC,KAAMC,8CACXD,KAAOA,UACPC,MAAQA,4DA2Cf,kBACSC,KAAKD,gCAMd,eAOQE,gBAAkBC,qBAAUC,UAAUH,KAAKD,OAAOK,UAKlDC,UAAYH,qBAAUC,UAAUF,iBAChCK,gBAAiB,wBAAcD,UAAUE,MAAMC,QAASR,KAAKF,MAC7DW,cAAe,wBAAcJ,UAAUK,IAAIF,QAASR,KAAKF,YAExD,CACLa,KAAM,gBACNL,eAAAA,eACAM,YAAaP,UAAUE,MAAMM,OAC7BJ,aAAAA,aACAK,UAAWT,UAAUK,IAAIG,mCAhE7B,SAAiBf,KAAMC,cACd,IAAIF,YAAYC,KAAMC,mCAS/B,SAAoBD,KAAMiB,cAElBT,gBAAiB,wBAAcS,SAAST,eAAgBR,UAEzDQ,qBACG,IAAIU,MAAM,8CAGZP,cAAe,wBAAcM,SAASN,aAAcX,UACrDW,mBACG,IAAIO,MAAM,4CAGZC,SAAWC,wBAAaC,eAC5Bb,eACAS,SAASH,aAELQ,OAASF,wBAAaC,eAC1BV,aACAM,SAASD,kBAIJ,IAAIjB,YAAYC,KADT,IAAII,qBAAUe,SAAUG,QAAQhB,mEAwCrCiB,0DAMCvB,KAAMS,MAAOG,mDAClBZ,KAAOA,UACPS,MAAQA,WACRG,IAAMA,oEA6Bb,iBACS,CACLC,KAAM,uBACNJ,MAAOP,KAAKO,MACZG,IAAKV,KAAKU,4BAId,kBACSR,qBAAUoB,YAAYtB,KAAKF,KAAME,KAAKO,MAAOP,KAAKU,KAAKN,qCA/BhE,SAAiBN,KAAMC,OACrBwB,QAAQC,IAAI,wCACZD,QAAQC,IAAI1B,UAENO,UAAYH,qBAAUC,UAAUJ,OAAO0B,WAAW3B,aACjD,IAAIuB,mBACTvB,KACAO,UAAUE,MAAMM,OAChBR,UAAUK,IAAIG,oCAOlB,SAAoBf,KAAMiB,iBACjB,IAAIM,mBAAmBvB,KAAMiB,SAASR,MAAOQ,SAASL,kFA2BpDgB,oDAQC5B,KAAM6B,WAAOC,+DAAU,8CAC5B9B,KAAOA,UACP6B,MAAQA,WACRC,QAAUA,qEA+CjB,iBACS,CACLjB,KAAM,oBACNgB,MAAO3B,KAAK2B,MACZE,OAAQ7B,KAAK4B,QAAQC,OACrBC,OAAQ9B,KAAK4B,QAAQE,+BAOzB,eAAQC,+DAAU,UACT/B,KAAKgC,iBAAiBD,SAAS3B,0CAMxC,eAAiB2B,+DAAU,GACnBE,KAA8BjC,KAAKF,KAAKoC,YACxCC,OAAQ,0BAAWF,KAAMjC,KAAK2B,qCAC/B3B,KAAK4B,aACRQ,KAAML,QAAQK,YAGXD,YACG,IAAInB,MAAM,0BAGX,IAAIK,mBAAmBrB,KAAKF,KAAMqC,MAAM5B,MAAO4B,MAAMzB,gCAlE9D,SAAiBZ,KAAMC,WACfkC,KAA8BnC,KAAKoC,YACnC7B,UAAYH,qBAAUC,UAAUJ,OAAO0B,WAAW3B,MAElDS,MAAQF,UAAUE,MAAMM,OACxBH,IAAML,UAAUK,IAAIG,cAanB,IAAIa,gBAAgB5B,KAAMmC,KAAKI,MAAM9B,MAAOG,KAAM,CACvDmB,OAAQI,KAAKI,MAAMC,KAAKC,IAAI,EAAGhC,MAHd,IAGmCA,OACpDuB,OAAQG,KAAKI,MAAM3B,IAAK4B,KAAKE,IAAIP,KAAKQ,OAAQ/B,IAJ7B,mCAYrB,SAAoBZ,KAAMiB,cAChBc,OAAmBd,SAAnBc,OAAQC,OAAWf,SAAXe,cACT,IAAIJ,gBAAgB5B,KAAMiB,SAASY,MAAO,CAAEE,OAAAA,OAAQC,OAAAA"}