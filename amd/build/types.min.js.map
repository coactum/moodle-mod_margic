{"version":3,"file":"types.min.js","sources":["../src/types.js"],"sourcesContent":["/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n */\n\n//import { matchQuote } from './match-quote';\nimport { TextRange, TextPosition } from './text-range';\nimport { nodeFromXPath, xpathFromNode } from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   */\n  static fromSelector(root, selector) {\n    // console.log('RangeAnchor -> fromSelector before nodeFromXPATH');\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n    // console.log('after nodeFromXPATH');\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   */\n  static fromSelector(root, selector) {\n    const { prefix, suffix } = selector;\n    return new TextQuoteAnchor(root, selector.exact, { prefix, suffix });\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   */\n  toPositionAnchor() {\n    const text = /** @type {string} */ (this.root.textContent);\n    // const match = matchQuote(text, this.exact, {\n    //   ...this.context,\n    //   hint: options.hint,\n    // });\n    const match = text.match(this.exact);\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n"],"names":["RangeAnchor","root","range","this","normalizedRange","TextRange","fromRange","toRange","textRange","startContainer","start","element","endContainer","end","type","startOffset","offset","endOffset","selector","Error","startPos","TextPosition","fromCharOffset","endPos","TextPositionAnchor","fromOffsets","relativeTo","TextQuoteAnchor","exact","context","prefix","suffix","options","toPositionAnchor","match","textContent","text","slice","Math","max","min","length"],"mappings":"s5BAuBaA,4CAKCC,KAAMC,8CACXD,KAAOA,UACPC,MAAQA,4DA2Cf,kBACSC,KAAKD,gCAMd,eAGQE,gBAAkBC,qBAAUC,UAAUH,KAAKD,OAAOK,UAElDC,UAAYH,qBAAUC,UAAUF,iBAChCK,gBAAiB,wBAAcD,UAAUE,MAAMC,QAASR,KAAKF,MAC7DW,cAAe,wBAAcJ,UAAUK,IAAIF,QAASR,KAAKF,YAExD,CACLa,KAAM,gBACNL,eAAAA,eACAM,YAAaP,UAAUE,MAAMM,OAC7BJ,aAAAA,aACAK,UAAWT,UAAUK,IAAIG,mCAzD7B,SAAiBf,KAAMC,cACd,IAAIF,YAAYC,KAAMC,mCAS/B,SAAoBD,KAAMiB,cAElBT,gBAAiB,wBAAcS,SAAST,eAAgBR,UAEzDQ,qBACG,IAAIU,MAAM,8CAGZP,cAAe,wBAAcM,SAASN,aAAcX,UACrDW,mBACG,IAAIO,MAAM,4CAGZC,SAAWC,wBAAaC,eAC5Bb,eACAS,SAASH,aAELQ,OAASF,wBAAaC,eAC1BV,aACAM,SAASD,kBAIJ,IAAIjB,YAAYC,KADT,IAAII,qBAAUe,SAAUG,QAAQhB,mEAiCrCiB,0DAMCvB,KAAMS,MAAOG,mDAClBZ,KAAOA,UACPS,MAAQA,WACRG,IAAMA,oEA0Bb,iBACS,CACLC,KAAM,uBACNJ,MAAOP,KAAKO,MACZG,IAAKV,KAAKU,4BAId,kBACSR,qBAAUoB,YAAYtB,KAAKF,KAAME,KAAKO,MAAOP,KAAKU,KAAKN,qCA5BhE,SAAiBN,KAAMC,WACfM,UAAYH,qBAAUC,UAAUJ,OAAOwB,WAAWzB,aACjD,IAAIuB,mBACTvB,KACAO,UAAUE,MAAMM,OAChBR,UAAUK,IAAIG,oCAOlB,SAAoBf,KAAMiB,iBACjB,IAAIM,mBAAmBvB,KAAMiB,SAASR,MAAOQ,SAASL,kFA2BpDc,oDAQC1B,KAAM2B,WAAOC,+DAAU,8CAC5B5B,KAAOA,UACP2B,MAAQA,WACRC,QAAUA,qEA+CjB,iBACS,CACLf,KAAM,oBACNc,MAAOzB,KAAKyB,MACZE,OAAQ3B,KAAK0B,QAAQC,OACrBC,OAAQ5B,KAAK0B,QAAQE,+BAOzB,eAAQC,+DAAU,UACT7B,KAAK8B,iBAAiBD,SAASzB,0CAMxC,eAMQ2B,MAL8B/B,KAAKF,KAAKkC,YAK3BD,MAAM/B,KAAKyB,WACzBM,YACG,IAAIf,MAAM,0BAEX,IAAIK,mBAAmBrB,KAAKF,KAAMiC,MAAMxB,MAAOwB,MAAMrB,gCAjE9D,SAAiBZ,KAAMC,WACfkC,KAA8BnC,KAAKkC,YACnC3B,UAAYH,qBAAUC,UAAUJ,OAAOwB,WAAWzB,MAElDS,MAAQF,UAAUE,MAAMM,OACxBH,IAAML,UAAUK,IAAIG,cAanB,IAAIW,gBAAgB1B,KAAMmC,KAAKC,MAAM3B,MAAOG,KAAM,CACvDiB,OAAQM,KAAKC,MAAMC,KAAKC,IAAI,EAAG7B,MAHd,IAGmCA,OACpDqB,OAAQK,KAAKC,MAAMxB,IAAKyB,KAAKE,IAAIJ,KAAKK,OAAQ5B,IAJ7B,mCAYrB,SAAoBZ,KAAMiB,cAChBY,OAAmBZ,SAAnBY,OAAQC,OAAWb,SAAXa,cACT,IAAIJ,gBAAgB1B,KAAMiB,SAASU,MAAO,CAAEE,OAAAA,OAAQC,OAAAA"}