{"version":3,"file":"types.min.js","sources":["../src/types.js"],"sourcesContent":["/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport {matchQuote} from './match-quote';\nimport {TextRange, TextPosition} from './text-range';\nimport {nodeFromXPath, xpathFromNode} from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   * @return {RangeAnchor}\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   * @return {RangeAnchor}\n   */\n  static fromSelector(root, selector) {\n\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   * @return {TextPositionAnchor}\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   * @return {TextPositionAnchor}\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   * @return {TextQuoteAnchor}\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   * @return {TextQuoteAnchor}\n   */\n  static fromSelector(root, selector) {\n    const {prefix, suffix} = selector;\n    return new TextQuoteAnchor(root, selector.exact, {prefix, suffix});\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   * @return {TextQuoteAnchor}\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   * @return {TextPositionAnchor}\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n"],"names":["RangeAnchor","constructor","root","range","this","static","selector","startContainer","nodeFromXPath","Error","endContainer","startPos","TextPosition","fromCharOffset","startOffset","endPos","endOffset","TextRange","toRange","toSelector","normalizedRange","fromRange","textRange","xpathFromNode","start","element","end","type","offset","_exports","TextPositionAnchor","relativeTo","fromOffsets","TextQuoteAnchor","exact","context","arguments","length","undefined","text","textContent","slice","prefix","Math","max","suffix","min","options","toPositionAnchor","match","matchQuote","hint"],"mappings":"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"}