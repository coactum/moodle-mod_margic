{"version":3,"sources":["../src/types.js"],"names":["RangeAnchor","root","range","normalizedRange","TextRange","fromRange","toRange","textRange","startContainer","start","element","endContainer","end","type","startOffset","offset","endOffset","selector","Error","startPos","TextPosition","fromCharOffset","endPos","TextPositionAnchor","fromOffsets","relativeTo","TextQuoteAnchor","exact","context","prefix","suffix","options","toPositionAnchor","text","textContent","match","hint","contextLen","slice","Math","max","min","length"],"mappings":"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","sourcesContent":["/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport {matchQuote} from './match-quote';\nimport {TextRange, TextPosition} from './text-range';\nimport {nodeFromXPath, xpathFromNode} from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   * @return {RangeAnchor}\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   * @return {RangeAnchor}\n   */\n  static fromSelector(root, selector) {\n\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   * @return {TextPositionAnchor}\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   * @return {TextPositionAnchor}\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   * @return {TextQuoteAnchor}\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   * @return {TextQuoteAnchor}\n   */\n  static fromSelector(root, selector) {\n    const {prefix, suffix} = selector;\n    return new TextQuoteAnchor(root, selector.exact, {prefix, suffix});\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   * @return {TextQuoteAnchor}\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   * @return {TextPositionAnchor}\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n"],"file":"types.min.js"}