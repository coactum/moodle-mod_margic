{"version":3,"file":"types.min.js","sources":["../src/types.js"],"sourcesContent":["/**\n * This module exports a set of classes for converting between DOM `Range`\n * objects and different types of selectors. It is mostly a thin wrapper around a\n * set of anchoring libraries. It serves two main purposes:\n *\n *  1. Providing a consistent interface across different types of anchors.\n *  2. Insulating the rest of the code from API changes in the underlying anchoring\n *     libraries.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport {matchQuote} from './match-quote';\nimport {TextRange, TextPosition} from './text-range';\nimport {nodeFromXPath, xpathFromNode} from './xpath';\n\n/**\n * @typedef {import('../../types/api').RangeSelector} RangeSelector\n * @typedef {import('../../types/api').TextPositionSelector} TextPositionSelector\n * @typedef {import('../../types/api').TextQuoteSelector} TextQuoteSelector\n */\n\n/**\n * Converts between `RangeSelector` selectors and `Range` objects.\n */\nexport class RangeAnchor {\n  /**\n   * @param {Node} root - A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   */\n  constructor(root, range) {\n    this.root = root;\n    this.range = range;\n  }\n\n  /**\n   * @param {Node} root -  A root element from which to anchor.\n   * @param {Range} range -  A range describing the anchor.\n   * @return {RangeAnchor}\n   */\n  static fromRange(root, range) {\n    return new RangeAnchor(root, range);\n  }\n\n  /**\n   * Create an anchor from a serialized `RangeSelector` selector.\n   *\n   * @param {Element} root -  A root element from which to anchor.\n   * @param {RangeSelector} selector\n   * @return {RangeAnchor}\n   */\n  static fromSelector(root, selector) {\n\n    const startContainer = nodeFromXPath(selector.startContainer, root);\n\n    if (!startContainer) {\n      throw new Error('Failed to resolve startContainer XPath');\n    }\n\n    const endContainer = nodeFromXPath(selector.endContainer, root);\n    if (!endContainer) {\n      throw new Error('Failed to resolve endContainer XPath');\n    }\n\n    const startPos = TextPosition.fromCharOffset(\n      startContainer,\n      selector.startOffset\n    );\n    const endPos = TextPosition.fromCharOffset(\n      endContainer,\n      selector.endOffset\n    );\n\n    const range = new TextRange(startPos, endPos).toRange();\n    return new RangeAnchor(root, range);\n  }\n\n  toRange() {\n    return this.range;\n  }\n\n  /**\n   * @return {RangeSelector}\n   */\n  toSelector() {\n    // \"Shrink\" the range so that it tightly wraps its text. This ensures more\n    // predictable output for a given text selection.\n\n    const normalizedRange = TextRange.fromRange(this.range).toRange();\n\n    const textRange = TextRange.fromRange(normalizedRange);\n    const startContainer = xpathFromNode(textRange.start.element, this.root);\n    const endContainer = xpathFromNode(textRange.end.element, this.root);\n\n    return {\n      type: 'RangeSelector',\n      startContainer,\n      startOffset: textRange.start.offset,\n      endContainer,\n      endOffset: textRange.end.offset,\n    };\n  }\n}\n\n/**\n * Converts between `TextPositionSelector` selectors and `Range` objects.\n */\nexport class TextPositionAnchor {\n  /**\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  constructor(root, start, end) {\n    this.root = root;\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * @param {Element} root\n   * @param {Range} range\n   * @return {TextPositionAnchor}\n   */\n  static fromRange(root, range) {\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n    return new TextPositionAnchor(\n      root,\n      textRange.start.offset,\n      textRange.end.offset\n    );\n  }\n  /**\n   * @param {Element} root\n   * @param {TextPositionSelector} selector\n   * @return {TextPositionAnchor}\n   */\n  static fromSelector(root, selector) {\n    return new TextPositionAnchor(root, selector.start, selector.end);\n  }\n\n  /**\n   * @return {TextPositionSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextPositionSelector',\n      start: this.start,\n      end: this.end,\n    };\n  }\n\n  toRange() {\n    return TextRange.fromOffsets(this.root, this.start, this.end).toRange();\n  }\n}\n\n/**\n * @typedef QuoteMatchOptions\n * @prop {number} [hint] - Expected position of match in text. See `matchQuote`.\n */\n\n/**\n * Converts between `TextQuoteSelector` selectors and `Range` objects.\n */\nexport class TextQuoteAnchor {\n  /**\n   * @param {Element} root - A root element from which to anchor.\n   * @param {string} exact\n   * @param {Object} context\n   *   @param {string} [context.prefix]\n   *   @param {string} [context.suffix]\n   */\n  constructor(root, exact, context = {}) {\n    this.root = root;\n    this.exact = exact;\n    this.context = context;\n  }\n\n  /**\n   * Create a `TextQuoteAnchor` from a range.\n   *\n   * Will throw if `range` does not contain any text nodes.\n   *\n   * @param {Element} root\n   * @param {Range} range\n   * @return {TextQuoteAnchor}\n   */\n  static fromRange(root, range) {\n    const text = /** @type {string} */ (root.textContent);\n    const textRange = TextRange.fromRange(range).relativeTo(root);\n\n    const start = textRange.start.offset;\n    const end = textRange.end.offset;\n\n    // Number of characters around the quote to capture as context. We currently\n    // always use a fixed amount, but it would be better if this code was aware\n    // of logical boundaries in the document (paragraph, article etc.) to avoid\n    // capturing text unrelated to the quote.\n    //\n    // In regular prose the ideal content would often be the surrounding sentence.\n    // This is a natural unit of meaning which enables displaying quotes in\n    // context even when the document is not available. We could use `Intl.Segmenter`\n    // for this when available.\n    const contextLen = 32;\n\n    return new TextQuoteAnchor(root, text.slice(start, end), {\n      prefix: text.slice(Math.max(0, start - contextLen), start),\n      suffix: text.slice(end, Math.min(text.length, end + contextLen)),\n    });\n  }\n\n  /**\n   * @param {Element} root\n   * @param {TextQuoteSelector} selector\n   * @return {TextQuoteAnchor}\n   */\n  static fromSelector(root, selector) {\n    const {prefix, suffix} = selector;\n    return new TextQuoteAnchor(root, selector.exact, {prefix, suffix});\n  }\n\n  /**\n   * @return {TextQuoteSelector}\n   */\n  toSelector() {\n    return {\n      type: 'TextQuoteSelector',\n      exact: this.exact,\n      prefix: this.context.prefix,\n      suffix: this.context.suffix,\n    };\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   * @return {TextQuoteAnchor}\n   */\n  toRange(options = {}) {\n    return this.toPositionAnchor(options).toRange();\n  }\n\n  /**\n   * @param {QuoteMatchOptions} [options]\n   * @return {TextPositionAnchor}\n   */\n  toPositionAnchor(options = {}) {\n    const text = /** @type {string} */ (this.root.textContent);\n    const match = matchQuote(text, this.exact, {\n      ...this.context,\n      hint: options.hint,\n    });\n\n    if (!match) {\n      throw new Error('Quote not found');\n    }\n\n    return new TextPositionAnchor(this.root, match.start, match.end);\n  }\n}\n"],"names":["RangeAnchor","constructor","root","range","selector","startContainer","Error","endContainer","startPos","TextPosition","fromCharOffset","startOffset","endPos","endOffset","TextRange","toRange","this","toSelector","normalizedRange","fromRange","textRange","start","element","end","type","offset","TextPositionAnchor","relativeTo","fromOffsets","TextQuoteAnchor","exact","context","text","textContent","slice","prefix","Math","max","suffix","min","length","options","toPositionAnchor","match","hint"],"mappings":"gRA2BaA,YAKXC,YAAYC,KAAMC,YACXD,KAAOA,UACPC,MAAQA,uBAQED,KAAMC,cACd,IAAIH,YAAYE,KAAMC,2BAUXD,KAAME,gBAElBC,gBAAiB,wBAAcD,SAASC,eAAgBH,UAEzDG,qBACG,IAAIC,MAAM,gDAGZC,cAAe,wBAAcH,SAASG,aAAcL,UACrDK,mBACG,IAAID,MAAM,8CAGZE,SAAWC,wBAAaC,eAC5BL,eACAD,SAASO,aAELC,OAASH,wBAAaC,eAC1BH,aACAH,SAASS,WAGLV,MAAQ,IAAIW,qBAAUN,SAAUI,QAAQG,iBACvC,IAAIf,YAAYE,KAAMC,OAG/BY,iBACSC,KAAKb,MAMdc,mBAIQC,gBAAkBJ,qBAAUK,UAAUH,KAAKb,OAAOY,UAElDK,UAAYN,qBAAUK,UAAUD,iBAChCb,gBAAiB,wBAAce,UAAUC,MAAMC,QAASN,KAAKd,MAC7DK,cAAe,wBAAca,UAAUG,IAAID,QAASN,KAAKd,YAExD,CACLsB,KAAM,gBACNnB,eAAAA,eACAM,YAAaS,UAAUC,MAAMI,OAC7BlB,aAAAA,aACAM,UAAWO,UAAUG,IAAIE,gDAQlBC,mBAMXzB,YAAYC,KAAMmB,MAAOE,UAClBrB,KAAOA,UACPmB,MAAQA,WACRE,IAAMA,qBAQIrB,KAAMC,aACfiB,UAAYN,qBAAUK,UAAUhB,OAAOwB,WAAWzB,aACjD,IAAIwB,mBACTxB,KACAkB,UAAUC,MAAMI,OAChBL,UAAUG,IAAIE,4BAQEvB,KAAME,iBACjB,IAAIsB,mBAAmBxB,KAAME,SAASiB,MAAOjB,SAASmB,KAM/DN,mBACS,CACLO,KAAM,uBACNH,MAAOL,KAAKK,MACZE,IAAKP,KAAKO,KAIdR,iBACSD,qBAAUc,YAAYZ,KAAKd,KAAMc,KAAKK,MAAOL,KAAKO,KAAKR,gEAYrDc,gBAQX5B,YAAYC,KAAM4B,WAAOC,+DAAU,QAC5B7B,KAAOA,UACP4B,MAAQA,WACRC,QAAUA,yBAYA7B,KAAMC,aACf6B,KAA8B9B,KAAK+B,YACnCb,UAAYN,qBAAUK,UAAUhB,OAAOwB,WAAWzB,MAElDmB,MAAQD,UAAUC,MAAMI,OACxBF,IAAMH,UAAUG,IAAIE,cAanB,IAAII,gBAAgB3B,KAAM8B,KAAKE,MAAMb,MAAOE,KAAM,CACvDY,OAAQH,KAAKE,MAAME,KAAKC,IAAI,EAAGhB,MAHd,IAGmCA,OACpDiB,OAAQN,KAAKE,MAAMX,IAAKa,KAAKG,IAAIP,KAAKQ,OAAQjB,IAJ7B,2BAaDrB,KAAME,gBAClB+B,OAACA,OAADG,OAASA,QAAUlC,gBAClB,IAAIyB,gBAAgB3B,KAAME,SAAS0B,MAAO,CAACK,OAAAA,OAAQG,OAAAA,SAM5DrB,mBACS,CACLO,KAAM,oBACNM,MAAOd,KAAKc,MACZK,OAAQnB,KAAKe,QAAQI,OACrBG,OAAQtB,KAAKe,QAAQO,QAQzBvB,cAAQ0B,+DAAU,UACTzB,KAAK0B,iBAAiBD,SAAS1B,UAOxC2B,uBAAiBD,+DAAU,SACnBT,KAA8BhB,KAAKd,KAAK+B,YACxCU,OAAQ,0BAAWX,KAAMhB,KAAKc,MAAO,IACtCd,KAAKe,QACRa,KAAMH,QAAQG,WAGXD,YACG,IAAIrC,MAAM,0BAGX,IAAIoB,mBAAmBV,KAAKd,KAAMyC,MAAMtB,MAAOsB,MAAMpB"}