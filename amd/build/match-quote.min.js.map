{"version":3,"sources":["../src/match-quote.js"],"names":["text","quote","context","length","maxErrors","Math","min","matches","search","scoreMatch","match","prefixWeight","suffixWeight","posWeight","quoteScore","errors","prefixScore","prefix","textMatchScore","slice","max","start","suffixScore","suffix","end","posScore","hint","offset","abs","rawScore","scoredMatches","map","m","score","sort","a","b","str","matchPos","exactMatches","indexOf","push"],"mappings":"uJA4FO,SAAoBA,CAApB,CAA0BC,CAA1B,CAA+C,IAAdC,CAAAA,CAAc,wDAAJ,EAAI,CACpD,GAAqB,CAAjB,GAAAD,CAAK,CAACE,MAAV,CAAwB,CACtB,MAAO,KACR,CAHmD,GAc9CC,CAAAA,CAAS,CAAGC,IAAI,CAACC,GAAL,CAAS,GAAT,CAAcL,CAAK,CAACE,MAAN,CAAe,CAA7B,CAdkC,CAiB9CI,CAAO,CAAGC,CAAM,CAACR,CAAD,CAAOC,CAAP,CAAcG,CAAd,CAjB8B,CAmBpD,GAAuB,CAAnB,GAAAG,CAAO,CAACJ,MAAZ,CAA0B,CACxB,MAAO,KACR,CArBmD,GA6B9CM,CAAAA,CAAU,CAAG,SAAAC,CAAK,CAAI,IAEpBC,CAAAA,CAAY,CAAG,EAFK,CAGpBC,CAAY,CAAG,EAHK,CAIpBC,CAAS,CAAG,CAJQ,CAMpBC,CAAU,CAAG,EAAIJ,CAAK,CAACK,MAAN,CAAed,CAAK,CAACE,MANlB,CAQpBa,CAAW,CAAGd,CAAO,CAACe,MAAR,CAChBC,CAAc,CACZlB,CAAI,CAACmB,KAAL,CACEd,IAAI,CAACe,GAAL,CAAS,CAAT,CAAYV,CAAK,CAACW,KAAN,CAAcnB,CAAO,CAACe,MAAR,CAAed,MAAzC,CADF,CAEEO,CAAK,CAACW,KAFR,CADY,CAKZnB,CAAO,CAACe,MALI,CADE,CAQhB,CAhBsB,CAiBpBK,CAAW,CAAGpB,CAAO,CAACqB,MAAR,CAChBL,CAAc,CACZlB,CAAI,CAACmB,KAAL,CAAWT,CAAK,CAACc,GAAjB,CAAsBd,CAAK,CAACc,GAAN,CAAYtB,CAAO,CAACqB,MAAR,CAAepB,MAAjD,CADY,CAEZD,CAAO,CAACqB,MAFI,CADE,CAKhB,CAtBsB,CAwBtBE,CAAQ,CAAG,CAxBW,CAyB1B,GAA4B,QAAxB,QAAOvB,CAAAA,CAAO,CAACwB,IAAnB,CAAsC,CACpC,GAAMC,CAAAA,CAAM,CAAGtB,IAAI,CAACuB,GAAL,CAASlB,CAAK,CAACW,KAAN,CAAcnB,CAAO,CAACwB,IAA/B,CAAf,CACAD,CAAQ,CAAG,EAAME,CAAM,CAAG3B,CAAI,CAACG,MAChC,CA5ByB,GA8BpB0B,CAAAA,CAAQ,CACZ,GAAcf,CAAd,CACAH,CAAY,CAAGK,CADf,CAEAJ,CAAY,CAAGU,CAFf,CAGAT,CAAS,CAAGY,CAlCY,CAsC1B,MAFwBI,CAAAA,CAAQ,EADf,GAAclB,CAAd,CAA6BC,CAA7B,CAA4CC,CAC7B,CAGjC,CApEmD,CAwE9CiB,CAAa,CAAGvB,CAAO,CAACwB,GAAR,CAAY,SAAAC,CAAC,QAAK,CACtCX,KAAK,CAAEW,CAAC,CAACX,KAD6B,CAEtCG,GAAG,CAAEQ,CAAC,CAACR,GAF+B,CAGtCS,KAAK,CAAExB,CAAU,CAACuB,CAAD,CAHqB,CAAL,CAAb,CAxE8B,CA+EpDF,CAAa,CAACI,IAAd,CAAmB,SAACC,CAAD,CAAIC,CAAJ,QAAUA,CAAAA,CAAC,CAACH,KAAF,CAAUE,CAAC,CAACF,KAAtB,CAAnB,EACA,MAAOH,CAAAA,CAAa,CAAC,CAAD,CACrB,C,CArKD,uDAuBA,QAAStB,CAAAA,CAAT,CAAgBR,CAAhB,CAAsBqC,CAAtB,CAA2BjC,CAA3B,CAAsC,IAGhCkC,CAAAA,CAAQ,CAAG,CAHqB,CAIhCC,CAAY,CAAG,EAJiB,CAKpC,MAAoB,CAAC,CAAd,GAAAD,CAAP,CAAwB,CACtBA,CAAQ,CAAGtC,CAAI,CAACwC,OAAL,CAAaH,CAAb,CAAkBC,CAAlB,CAAX,CACA,GAAiB,CAAC,CAAd,GAAAA,CAAJ,CAAqB,CACnBC,CAAY,CAACE,IAAb,CAAkB,CAChBpB,KAAK,CAAEiB,CADS,CAEhBd,GAAG,CAAEc,CAAQ,CAAGD,CAAG,CAAClC,MAFJ,CAGhBY,MAAM,CAAE,CAHQ,CAAlB,EAKAuB,CAAQ,EAAI,CACb,CACF,CACD,GAA0B,CAAtB,CAAAC,CAAY,CAACpC,MAAjB,CAA6B,CAC3B,MAAOoC,CAAAA,CACR,CAID,MAAO,cAAavC,CAAb,CAAmBqC,CAAnB,CAAwBjC,CAAxB,CACR,CASD,QAASc,CAAAA,CAAT,CAAwBlB,CAAxB,CAA8BqC,CAA9B,CAAmC,CAIjC,GAAmB,CAAf,GAAAA,CAAG,CAAClC,MAAJ,EAAoC,CAAhB,GAAAH,CAAI,CAACG,MAA7B,CAA2C,CACzC,MAAO,EACR,CAED,GAAMI,CAAAA,CAAO,CAAGC,CAAM,CAACR,CAAD,CAAOqC,CAAP,CAAYA,CAAG,CAAClC,MAAhB,CAAtB,CAGA,MAAO,GAAKI,CAAO,CAAC,CAAD,CAAP,CAAWQ,MAAX,CAAoBsB,CAAG,CAAClC,MACrC,C","sourcesContent":["/**\n * Functions for quote matching for the annotations and highlighting.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport approxSearch from './string-match';\n\n/**\n * @typedef {import('approx-string-match').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn't currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return approxSearch(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n * @return {int}\n */\nfunction textMatchScore(text, str) {\n  // `search` will return no matches if either the text or pattern is empty,\n  // otherwise it will return at least one match if the max allowed error count\n  // is at least `str.length`.\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n\n  const matches = search(text, str, str.length);\n\n  // Prettier-ignore.\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nexport function matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of \"good\" matches found)\n  //  - Precision (proportion of matches found which are \"good\")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   * @return {int}\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(\n            Math.max(0, match.start - context.prefix.length),\n            match.start\n          ),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === 'number') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n"],"file":"match-quote.min.js"}