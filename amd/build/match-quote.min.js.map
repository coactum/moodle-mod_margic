{"version":3,"file":"match-quote.min.js","sources":["../src/match-quote.js"],"sourcesContent":["/**\n * Functions for quote matching for the annotations and highlighting.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport approxSearch from './string-match';\n\n/**\n * @typedef {import('approx-string-match').Match} StringMatch\n */\n\n/**\n * @typedef Match\n * @prop {number} start - Start offset of match in text\n * @prop {number} end - End offset of match in text\n * @prop {number} score -\n *   Score for the match between 0 and 1.0, where 1.0 indicates a perfect match\n *   for the quote and context.\n */\n\n/**\n * Find the best approximate matches for `str` in `text` allowing up to `maxErrors` errors.\n *\n * @param {string} text\n * @param {string} str\n * @param {number} maxErrors\n * @return {StringMatch[]}\n */\nfunction search(text, str, maxErrors) {\n  // Do a fast search for exact matches. The `approx-string-match` library\n  // doesn't currently incorporate this optimization itself.\n  let matchPos = 0;\n  let exactMatches = [];\n  while (matchPos !== -1) {\n    matchPos = text.indexOf(str, matchPos);\n    if (matchPos !== -1) {\n      exactMatches.push({\n        start: matchPos,\n        end: matchPos + str.length,\n        errors: 0,\n      });\n      matchPos += 1;\n    }\n  }\n  if (exactMatches.length > 0) {\n    return exactMatches;\n  }\n\n  // If there are no exact matches, do a more expensive search for matches\n  // with errors.\n  return approxSearch(text, str, maxErrors);\n}\n\n/**\n * Compute a score between 0 and 1.0 for the similarity between `text` and `str`.\n *\n * @param {string} text\n * @param {string} str\n * @return {int}\n */\nfunction textMatchScore(text, str) {\n  // `search` will return no matches if either the text or pattern is empty,\n  // otherwise it will return at least one match if the max allowed error count\n  // is at least `str.length`.\n  if (str.length === 0 || text.length === 0) {\n    return 0.0;\n  }\n\n  const matches = search(text, str, str.length);\n\n  // Prettier-ignore.\n  return 1 - (matches[0].errors / str.length);\n}\n\n/**\n * Find the best approximate match for `quote` in `text`.\n *\n * Returns `null` if no match exceeding the minimum quality threshold was found.\n *\n * @param {string} text - Document text to search\n * @param {string} quote - String to find within `text`\n * @param {Object} context -\n *   Context in which the quote originally appeared. This is used to choose the\n *   best match.\n *   @param {string} [context.prefix] - Expected text before the quote\n *   @param {string} [context.suffix] - Expected text after the quote\n *   @param {number} [context.hint] - Expected offset of match within text\n * @return {Match|null}\n */\nexport function matchQuote(text, quote, context = {}) {\n  if (quote.length === 0) {\n    return null;\n  }\n\n  // Choose the maximum number of errors to allow for the initial search.\n  // This choice involves a tradeoff between:\n  //\n  //  - Recall (proportion of \"good\" matches found)\n  //  - Precision (proportion of matches found which are \"good\")\n  //  - Cost of the initial search and of processing the candidate matches [1]\n  //\n  // [1] Specifically, the expected-time complexity of the initial search is\n  //     `O((maxErrors / 32) * text.length)`. See `approx-string-match` docs.\n  const maxErrors = Math.min(256, quote.length / 2);\n\n  // Find closest matches for `quote` in `text` based on edit distance.\n  const matches = search(text, quote, maxErrors);\n\n  if (matches.length === 0) {\n    return null;\n  }\n\n  /**\n   * Compute a score between 0 and 1.0 for a match candidate.\n   *\n   * @param {StringMatch} match\n   * @return {int}\n   */\n  const scoreMatch = match => {\n    const quoteWeight = 50; // Similarity of matched text to quote.\n    const prefixWeight = 20; // Similarity of text before matched text to `context.prefix`.\n    const suffixWeight = 20; // Similarity of text after matched text to `context.suffix`.\n    const posWeight = 2; // Proximity to expected location. Used as a tie-breaker.\n\n    const quoteScore = 1 - match.errors / quote.length;\n\n    const prefixScore = context.prefix\n      ? textMatchScore(\n          text.slice(\n            Math.max(0, match.start - context.prefix.length),\n            match.start\n          ),\n          context.prefix\n        )\n      : 1.0;\n    const suffixScore = context.suffix\n      ? textMatchScore(\n          text.slice(match.end, match.end + context.suffix.length),\n          context.suffix\n        )\n      : 1.0;\n\n    let posScore = 1.0;\n    if (typeof context.hint === 'number') {\n      const offset = Math.abs(match.start - context.hint);\n      posScore = 1.0 - offset / text.length;\n    }\n\n    const rawScore =\n      quoteWeight * quoteScore +\n      prefixWeight * prefixScore +\n      suffixWeight * suffixScore +\n      posWeight * posScore;\n    const maxScore = quoteWeight + prefixWeight + suffixWeight + posWeight;\n    const normalizedScore = rawScore / maxScore;\n\n    return normalizedScore;\n  };\n\n  // Rank matches based on similarity of actual and expected surrounding text\n  // and actual/expected offset in the document text.\n  const scoredMatches = matches.map(m => ({\n    start: m.start,\n    end: m.end,\n    score: scoreMatch(m),\n  }));\n\n  // Choose match with highest score.\n  scoredMatches.sort((a, b) => b.score - a.score);\n  return scoredMatches[0];\n}\n"],"names":["obj","search","text","str","maxErrors","matchPos","exactMatches","indexOf","push","start","end","length","errors","approxSearch","textMatchScore","quote","context","arguments","undefined","Math","min","matches","scoreMatch","match","quoteScore","prefixScore","prefix","slice","max","suffixScore","suffix","posScore","hint","abs","quoteWeight","scoredMatches","map","m","score","sort","a","b","_stringMatch","__esModule","default"],"mappings":"8FAQ0C,IAAAA,IAuB1C,SAASC,OAAOC,KAAMC,IAAKC,WAGzB,IAAIC,SAAW,EACXC,aAAe,GACnB,MAAqB,IAAdD,UACLA,SAAWH,KAAKK,QAAQJ,IAAKE,WACX,IAAdA,WACFC,aAAaE,KAAK,CAChBC,MAAOJ,SACPK,IAAKL,SAAWF,IAAIQ,OACpBC,OAAQ,IAEVP,UAAY,GAGhB,OAAIC,aAAaK,OAAS,EACjBL,cAKF,EAAAO,sBAAaX,KAAMC,IAAKC,UACjC,CASA,SAASU,eAAeZ,KAAMC,KAI5B,GAAmB,IAAfA,IAAIQ,QAAgC,IAAhBT,KAAKS,OAC3B,OAAO,EAMT,OAAO,EAHSV,OAAOC,KAAMC,IAAKA,IAAIQ,QAGlB,GAAGC,OAAST,IAAIQ,MACtC,6EAiBO,SAAoBT,KAAMa,OAAqB,IAAdC,QAAOC,UAAAN,OAAA,QAAAO,IAAAD,UAAA,GAAAA,UAAA,GAAG,CAAA,EAChD,GAAqB,IAAjBF,MAAMJ,OACR,OAAO,KAYT,MAAMP,UAAYe,KAAKC,IAAI,IAAKL,MAAMJ,OAAS,GAGzCU,QAAUpB,OAAOC,KAAMa,MAAOX,WAEpC,GAAuB,IAAnBiB,QAAQV,OACV,OAAO,KAST,MAAMW,WAAaC,QACjB,MAKMC,WAAa,EAAID,MAAMX,OAASG,MAAMJ,OAEtCc,YAAcT,QAAQU,OACxBZ,eACEZ,KAAKyB,MACHR,KAAKS,IAAI,EAAGL,MAAMd,MAAQO,QAAQU,OAAOf,QACzCY,MAAMd,OAERO,QAAQU,QAEV,EACEG,YAAcb,QAAQc,OACxBhB,eACEZ,KAAKyB,MAAMJ,MAAMb,IAAKa,MAAMb,IAAMM,QAAQc,OAAOnB,QACjDK,QAAQc,QAEV,EAEJ,IAAIC,SAAW,EACf,GAA4B,iBAAjBf,QAAQgB,KAAmB,CAEpCD,SAAW,EADIZ,KAAKc,IAAIV,MAAMd,MAAQO,QAAQgB,MACpB9B,KAAKS,MACjC,CAUA,OArCoB,GA8BJa,WA7BK,GA8BJC,YA7BI,GA8BJI,YA7BC,EA8BJE,UACGG,EAGK,EAKlBC,cAAgBd,QAAQe,KAAIC,IAAM,CACtC5B,MAAO4B,EAAE5B,MACTC,IAAK2B,EAAE3B,IACP4B,MAAOhB,WAAWe,OAKpB,OADAF,cAAcI,MAAK,CAACC,EAAGC,IAAMA,EAAEH,MAAQE,EAAEF,QAClCH,cAAc,EACvB,EArKAO,cAA0C1C,IAA1C0C,eAA0C1C,IAAA2C,WAAA3C,IAAA4C,CAAAA,QAAA5C,IAqKzC"}