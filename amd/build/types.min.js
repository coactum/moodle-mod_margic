define("mod_margic/types",["exports","./match-quote","./text-range","./xpath"],(function(_exports,_matchQuote,_textRange,_xpath){Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.TextQuoteAnchor=_exports.TextPositionAnchor=_exports.RangeAnchor=void 0;class RangeAnchor{constructor(root,range){this.root=root,this.range=range}static fromRange(root,range){return new RangeAnchor(root,range)}static fromSelector(root,selector){const startContainer=(0,_xpath.nodeFromXPath)(selector.startContainer,root);if(!startContainer)throw new Error("Failed to resolve startContainer XPath");const endContainer=(0,_xpath.nodeFromXPath)(selector.endContainer,root);if(!endContainer)throw new Error("Failed to resolve endContainer XPath");const startPos=_textRange.TextPosition.fromCharOffset(startContainer,selector.startOffset),endPos=_textRange.TextPosition.fromCharOffset(endContainer,selector.endOffset),range=new _textRange.TextRange(startPos,endPos).toRange();return new RangeAnchor(root,range)}toRange(){return this.range}toSelector(){const normalizedRange=_textRange.TextRange.fromRange(this.range).toRange(),textRange=_textRange.TextRange.fromRange(normalizedRange),startContainer=(0,_xpath.xpathFromNode)(textRange.start.element,this.root),endContainer=(0,_xpath.xpathFromNode)(textRange.end.element,this.root);return{type:"RangeSelector",startContainer:startContainer,startOffset:textRange.start.offset,endContainer:endContainer,endOffset:textRange.end.offset}}}_exports.RangeAnchor=RangeAnchor;class TextPositionAnchor{constructor(root,start,end){this.root=root,this.start=start,this.end=end}static fromRange(root,range){const textRange=_textRange.TextRange.fromRange(range).relativeTo(root);return new TextPositionAnchor(root,textRange.start.offset,textRange.end.offset)}static fromSelector(root,selector){return new TextPositionAnchor(root,selector.start,selector.end)}toSelector(){return{type:"TextPositionSelector",start:this.start,end:this.end}}toRange(){return _textRange.TextRange.fromOffsets(this.root,this.start,this.end).toRange()}}_exports.TextPositionAnchor=TextPositionAnchor;class TextQuoteAnchor{constructor(root,exact){let context=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};this.root=root,this.exact=exact,this.context=context}static fromRange(root,range){const text=root.textContent,textRange=_textRange.TextRange.fromRange(range).relativeTo(root),start=textRange.start.offset,end=textRange.end.offset;return new TextQuoteAnchor(root,text.slice(start,end),{prefix:text.slice(Math.max(0,start-32),start),suffix:text.slice(end,Math.min(text.length,end+32))})}static fromSelector(root,selector){const{prefix:prefix,suffix:suffix}=selector;return new TextQuoteAnchor(root,selector.exact,{prefix:prefix,suffix:suffix})}toSelector(){return{type:"TextQuoteSelector",exact:this.exact,prefix:this.context.prefix,suffix:this.context.suffix}}toRange(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this.toPositionAnchor(options).toRange()}toPositionAnchor(){let options=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const text=this.root.textContent,match=(0,_matchQuote.matchQuote)(text,this.exact,{...this.context,hint:options.hint});if(!match)throw new Error("Quote not found");return new TextPositionAnchor(this.root,match.start,match.end)}}_exports.TextQuoteAnchor=TextQuoteAnchor}));

//# sourceMappingURL=types.min.js.map