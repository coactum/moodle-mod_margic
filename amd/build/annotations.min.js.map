{"version":3,"sources":["../src/annotations.js"],"names":["define","$","init","annotations","console","log","hide","removeClass","editAnnotation","annotationid","removeAllTempHighlights","resetForms","entry","val","startcontainer","endcontainer","startposition","endposition","text","show","focus","wholeTextNodesInRange","range","collapsed","root","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","textNodes","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","node","nextNode","isNodeInRange","startContainer","startOffset","splitText","endContainer","endOffset","data","length","push","highlightRange","cssClass","inPlaceholder","isInPlaceholder","textNodeSpans","prevNode","currentSpan","forEach","nextSibling","filter","span","some","test","nodeValue","highlights","nodes","highlightEl","document","createElement","className","id","parentNode","replaceChild","appendChild","childNodes","comparePoint","e","closest","getNodeName","nodeName","toLowerCase","result","getNodePosition","pos","tmp","previousSibling","getPathSegment","name","xpathFromNode","xpath","elem","Error","replace","nthChildOfType","element","index","toUpperCase","matchIndex","i","child","children","evaluateSimpleXPath","isSimpleXPath","match","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt","nodeFromXPath","body","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","replaceWith","replacements","parent","r","insertBefore","remove","Array","from","querySelectorAll","removeHighlights","on","selectedrange","window","getSelection","getRangeAt","cloneContents","textContent","Object","values","annotation","newrange","createRange","setStart","setEnd","mouseenter","addClass","mouseleave"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module for the annotation functions of the annotated diary.\n *\n * @module     mod_annotateddiary/annotations\n * @package    mod_annotateddiary\n * @copyright  2021 coactum GmbH\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n define(['jquery', 'mod_annotateddiary/addertoolbar_new'], function($, addertoolbar) {\n    return {\n        init: function(annotations) {\n\n            // // replace the 'n'th character of 's' with 't'\n            // function replaceWithHighlights() {\n            //     //var entry = s.substring(0, n) + t + s.substring(n + 1);\n\n            //     console.log(Object.values(annotations));\n\n            //     for (let annotation of Object.values(annotations)) {\n            //         var oldtext = $('#entry-' + annotation.entry)[0].innerHTML;\n\n            //         console.log(annotation);\n\n            //         console.log(oldtext);\n\n            //         var newtext = oldtext.substring(0, annotation.startposition) + '<span>' + oldtext.substring(annotation.startposition + 1, annotation.endposition) + '</span>' + oldtext.substring(annotation.endposition + 1);\n\n            //         console.log(newtext);\n\n            //         $('#entry-' + annotation.entry)[0].innerHTML = newtext;\n            //     }\n            // }\n\n            // function replaceWithHighlights() {\n\n            //     for (let annotation of Object.values(annotations)) {\n            //         //create range from db\n            //         var range = document.createRange();\n\n            //         var startcontainer = annotation.startcontainer+1;\n            //         var endcontainer = annotation.endcontainer+1;\n\n            //         console.log('nth child');\n            //         console.log($( \"#entry-\" + annotation.entry + \" :nth-child(\" + startcontainer + \")\" ));\n\n            //         range.setStart($( \"#entry-\" + annotation.entry + \" :nth-child(\" + startcontainer + \")\" )[0].firstChild, annotation.startposition);\n            //         range.setEnd($( \"#entry-\" + annotation.entry + \" :nth-child(\" + endcontainer + \")\" )[0].firstChild, annotation.endposition);\n\n            //         console.log('new range');\n            //         console.log(range);\n\n            //         // wrap range with span\n            //         var span = document.createElement('SPAN');\n            //         span.textContent = 'TEST'; // needs to be done by js depending on start and endposition\n\n            //         range.deleteContents();\n            //         range.insertNode(span);\n\n            //         console.log('new range with span');\n            //         console.log(range);\n\n            //     }\n            // }\n\n            // function getSelectionValues(entry) {\n            //     if (typeof window.getSelection != \"undefined\") {\n            //         var selection = window.getSelection();\n            //         var range = selection.getRangeAt(0);\n\n            //         var child = range.startContainer.parentNode;\n            //         var parent = child.parentNode;\n            //         var startcontainer = Array.prototype.indexOf.call(parent.children, child);\n\n            //         var child = range.endContainer.parentNode;\n            //         var parent = child.parentNode;\n            //         var endcontainer = Array.prototype.indexOf.call(parent.children, child);\n            //     }\n\n            //     $('input[name=\"startcontainer[' + entry + ']\"]').val(startcontainer);\n            //     $('input[name=\"endcontainer[' + entry + ']\"]').val(endcontainer);\n            //     $('input[name=\"startposition[' + entry + ']\"]').val(range.startOffset);\n            //     $('input[name=\"endposition[' + entry + ']\"]').val(range.endOffset);\n\n            //     console.log('selected range');\n            //     console.log(range);\n\n            //     return {\n            //         startcontainer: startcontainer,\n            //         endcontainer: endcontainer,\n            //         startposition: range.startOffset,\n            //         endposition: range.endOffset,\n            //     };\n            // }\n\n            // function createAnnotation(entry) {\n            //     if (typeof window.getSelection != \"undefined\") {\n            //         var range = window.getSelection().getRangeAt(0);\n            //     } else if (typeof document.selection != \"undefined\") {\n            //         if (document.selection.type == \"Text\") {\n            //             var range = document.selection.createRange();\n            //         }\n            //     }\n\n            //     console.log('entry');\n            //     console.log(entry);\n\n            //     console.log('window.getSelection()');\n            //     console.log(window.getSelection());\n\n            //     console.log('range');\n            //     console.log(range);\n\n            //     //console.log(priorRange);\n\n            //     console.log('range as string');\n            //     console.log(range.toString());\n\n            //     console.log('range as cloned contents');\n            //     console.log(range.cloneContents());\n\n            //     console.log($('<div>').append(range.cloneContents()).html());\n\n            //     var span = document.createElement('SPAN');\n            //     span.classList.add(\"annotated\")\n\n            //     var str = $('<div>').append(range.cloneContents()).html();\n            //     //var pattern = /<\\/(.{1,4})>/g;\n            //     var pattern = /<(?:\"[^\"]*\"['\"]*|'[^']*'['\"]*|[^'\">])+>/g;\n            //     var newstr = str;\n            //     var addition = 0;\n\n            //     while (match = pattern.exec(str)) {\n            //         console.log(match);\n            //         console.log(match.index + ' ' + pattern.lastIndex);\n\n            //         if(match[0].indexOf('</') !== -1) {\n            //             newstr = newstr.substr(0, match.index + addition) + '</span>' + match[0] + newstr.substr(pattern.lastIndex + addition);\n            //             addition += 7;\n            //         } else {\n            //             newstr = newstr.substr(0, match.index + addition) + match[0] + '<span class=\"annotated\">' + newstr.substr(pattern.lastIndex + addition);\n            //             addition += 24;\n            //         }\n\n            //     }\n\n            //     console.log('newstr');\n            //     console.log(newstr);\n\n            //     span.innerHTML = newstr;\n\n            //     range.deleteContents();\n            //     range.insertNode(span);\n\n            //     console.log('range with span as string');\n            //     console.log(range.toString());\n\n            // }\n\n            console.log ('SITE IS LOADED');\n\n            // Hide all Moodle forms\n            $('.mform').hide();\n\n            // remove col-mds from moodle form\n            $('.mform div.col-md-3').removeClass('col-md-3');\n            $('.mform div.col-md-9').removeClass('col-md-9');\n            $('.mform div.form-group').removeClass('form-group');\n            $('.mform div.row').removeClass('row');\n\n            function recreateAnnotations(){\n                for (let annotation of Object.values(annotations)) {\n\n                    console.log($( \"#entry-\" + annotation.entry)[0]);\n\n                    //recreate range from db\n                    var newrange = document.createRange();\n\n                    try {\n                        newrange.setStart(nodeFromXPath(annotation.startcontainer, $( \"#entry-\" + annotation.entry)[0]), annotation.startposition);\n                        newrange.setEnd(nodeFromXPath(annotation.endcontainer, $( \"#entry-\" + annotation.entry)[0]), annotation.endposition);\n                     }\n                     catch (e) {\n                        console.log('try/catch');\n                        console.log(e);\n                     }\n\n                    console.log('recreateAnnotations after setStart/End');\n\n                    highlightRange(newrange, annotation.id);\n\n                }\n            }\n\n            function editAnnotation(annotationid) {\n                removeAllTempHighlights();\n                resetForms();\n\n                console.log('annotations from js');\n                console.log(annotations);\n\n                var entry = annotations[annotationid].entry;\n\n                console.log(entry);\n\n                $('input[name=\"startcontainer[' + entry + ']\"]').val(annotations[annotationid].startcontainer);\n                $('input[name=\"endcontainer[' + entry + ']\"]').val(annotations[annotationid].endcontainer);\n                $('input[name=\"startposition[' + entry + ']\"]').val(annotations[annotationid].startposition);\n                $('input[name=\"endposition[' + entry + ']\"]').val(annotations[annotationid].endposition);\n\n                $('textarea[name=\"text[' + entry + ']\"]').val(annotations[annotationid].text);\n\n                $('.annotationarea-' + entry + ' .mform').show();\n                $('#id_text_' + entry).focus();\n            }\n\n            function resetForms(){\n                $('.mform').hide();\n\n                $('.mform input[name^=\"annotationid\"]').val(null);\n\n                $('.mform input[name^=\"startcontainer\"]').val(-1);\n                $('.mform input[name^=\"endcontainer\"]').val(-1);\n                $('.mform input[name^=\"startposition\"]').val(-1);\n                $('.mform input[name^=\"endposition\"]').val(-1);\n\n                $('.mform textarea[name^=\"text\"]').val('');\n            }\n\n            // function hoverAnnotationAndText (){\n\n            // }\n\n            // function getSelectionCharOffsetWithin(element) { // unnötig da bereits in selection\n            //     var start = 0;\n            //     var end = 0;\n\n            //     if (typeof window.getSelection != \"undefined\") {\n            //         var range = window.getSelection().getRangeAt(0);\n            //         var priorRange = range.cloneRange();\n            //         priorRange.selectNodeContents(element);\n            //         priorRange.setEnd(range.startContainer, range.startOffset);\n            //         start = priorRange.toString().length;\n            //         end = start + range.toString().length;\n            //     } else if (typeof document.selection != \"undefined\") {\n            //         if (document.selection.type == \"Text\") {\n            //             var range = document.selection.createRange();\n            //             var priorRange = document.body.createTextRange();\n            //             priorRange.moveToElementText(element);\n            //             priorRange.setEndPoint(\"EndToStart\", range);\n            //             start = priorRange.text.length;\n            //             end = start + range.text.length;\n            //         }\n            //     }\n\n            //     return {\n            //         start: start,\n            //         end: end,\n            //     };\n            // }\n\n            // $(document).bind(\"mouseup\", function() {\n            //     var mytext = getSelectionHtml();\n            //     console.log(mytext);\n            // });\n\n            //replaceWithHighlights();\n\n            /**\n             * Return text nodes which are entirely inside `range`.\n             *\n             * If a range starts or ends part-way through a text node, the node is split\n             * and the part inside the range is returned.\n             *\n             * @param {Range} range\n             * @return {Text[]}\n             */\n            function wholeTextNodesInRange(range) {\n                if (range.collapsed) {\n                    // Exit early for an empty range to avoid an edge case that breaks the algorithm\n                    // below. Splitting a text node at the start of an empty range can leave the\n                    // range ending in the left part rather than the right part.\n                    return [];\n                }\n\n                /** @type {Node|null} */\n                let root = range.commonAncestorContainer;\n                if (root.nodeType !== Node.ELEMENT_NODE) {\n                    // If the common ancestor is not an element, set it to the parent element to\n                    // ensure that the loop below visits any text nodes generated by splitting\n                    // the common ancestor.\n                    //\n                    // Note that `parentElement` may be `null`.\n                    root = root.parentElement;\n                }\n                if (!root) {\n                    // If there is no root element then we won't be able to insert highlights,\n                    // so exit here.\n                    return [];\n                }\n\n                const textNodes = [];\n                const nodeIter = /** @type {Document} */ (\n                root.ownerDocument\n                ).createNodeIterator(\n                root,\n                NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n                );\n                let node;\n                while ((node = nodeIter.nextNode())) {\n                    if (!isNodeInRange(range, node)) {\n                        continue;\n                    }\n                    let text = /** @type {Text} */ (node);\n\n                    if (text === range.startContainer && range.startOffset > 0) {\n                        // Split `text` where the range starts. The split will create a new `Text`\n                        // node which will be in the range and will be visited in the next loop iteration.\n                        text.splitText(range.startOffset);\n                        continue;\n                    }\n\n                    if (text === range.endContainer && range.endOffset < text.data.length) {\n                        // Split `text` where the range ends, leaving it as the part in the range.\n                        text.splitText(range.endOffset);\n                    }\n\n                    textNodes.push(text);\n                }\n\n                return textNodes;\n            }\n\n            /**\n             * Wraps the DOM Nodes within the provided range with a highlight\n             * element of the specified class and returns the highlight Elements.\n             *\n             * @param {Range} range - Range to be highlighted\n             * @param {string} cssClass - A CSS class to use for the highlight\n             * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n             */\n            function highlightRange(range, annotationid = false, cssClass = 'annotated') {\n\n                console.log('highlightRange start');\n\n                const textNodes = wholeTextNodesInRange(range);\n\n                // Check if this range refers to a placeholder for not-yet-rendered content in\n                // a PDF. These highlights should be invisible.\n                const inPlaceholder = textNodes.length > 0 && isInPlaceholder(textNodes[0]);\n\n                // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n                // adjacent, we only need to create one highlight element for the group.\n                let textNodeSpans = [];\n                let prevNode = null;\n                let currentSpan = null;\n\n                textNodes.forEach(node => {\n                if (prevNode && prevNode.nextSibling === node) {\n                    currentSpan.push(node);\n                } else {\n                    currentSpan = [node];\n                    textNodeSpans.push(currentSpan);\n                }\n                prevNode = node;\n                });\n\n                // Filter out text node spans that consist only of white space. This avoids\n                // inserting highlight elements in places that can only contain a restricted\n                // subset of nodes such as table rows and lists.\n                const whitespace = /^\\s*$/;\n                textNodeSpans = textNodeSpans.filter(span =>\n                // Check for at least one text node with non-space content.\n                span.some(node => !whitespace.test(node.nodeValue))\n                );\n\n                // Wrap each text node span with a `<hypothesis-highlight>` element.\n                const highlights = [];\n                textNodeSpans.forEach(nodes => {\n                // A custom element name is used here rather than `<span>` to reduce the\n                // likelihood of highlights being hidden by page styling.\n\n                /** @type {HighlightElement} */\n                const highlightEl = document.createElement('span');\n                highlightEl.className = cssClass;\n\n                if (annotationid) {\n                    highlightEl.className += ' ' + cssClass + '-' + annotationid;\n                    highlightEl.id = cssClass + '-' + annotationid;\n                }\n\n                nodes[0].parentNode.replaceChild(highlightEl, nodes[0]);\n                nodes.forEach(node => highlightEl.appendChild(node));\n\n                highlights.push(highlightEl);\n                });\n\n                console.log('highlightRange end');\n\n\n                return highlights;\n            }\n\n            /**\n             * Returns true if any part of `node` lies within `range`.\n             *\n             * @param {Range} range\n             * @param {Node} node\n             */\n            function isNodeInRange(range, node) {\n                try {\n                    const length = node.nodeValue?.length ?? node.childNodes.length;\n                    return (\n                        // Check start of node is before end of range.\n                        range.comparePoint(node, 0) <= 0 &&\n                        // Check end of node is after start of range.\n                        range.comparePoint(node, length) >= 0\n                    );\n                } catch (e) {\n                    // `comparePoint` may fail if the `range` and `node` do not share a common\n                    // ancestor or `node` is a doctype.\n                return false;\n                }\n            }\n\n            /**\n             * CSS selector that will match the placeholder within a page/tile container.\n             */\n            const placeholderSelector = '.annotator-placeholder';\n\n            /**\n             * Return true if `node` is inside a placeholder element created with `createPlaceholder`.\n             *\n             * This is typically used to test if a highlight element associated with an\n             * anchor is inside a placeholder.\n             *\n             * @param {Node} node\n             */\n            function isInPlaceholder(node) {\n                if (!node.parentElement) {\n                    return false;\n                }\n                return node.parentElement.closest(placeholderSelector) !== null;\n            }\n\n\n\n\n\n            /**\n             * Get the node name for use in generating an xpath expression.\n             *\n             * @param {Node} node\n             */\n            function getNodeName(node) {\n                const nodeName = node.nodeName.toLowerCase();\n                let result = nodeName;\n                if (nodeName === '#text') {\n                    result = 'text()';\n                }\n                return result;\n            }\n\n            /**\n             * Get the index of the node as it appears in its parent's child list\n             *\n             * @param {Node} node\n             */\n            function getNodePosition(node) {\n                let pos = 0;\n                /** @type {Node|null} */\n                let tmp = node;\n                while (tmp) {\n                    if (tmp.nodeName === node.nodeName) {\n                        pos += 1;\n                    }\n                    tmp = tmp.previousSibling;\n                    }\n                return pos;\n            }\n\n            function getPathSegment(node) {\n                const name = getNodeName(node);\n                const pos = getNodePosition(node);\n                return `${name}[${pos}]`;\n            }\n\n            /**\n             * A simple XPath generator which can generate XPaths of the form\n             * /tag[index]/tag[index].\n             *\n             * @param {Node} node - The node to generate a path to\n             * @param {Node} root - Root node to which the returned path is relative\n             */\n            function xpathFromNode(node, root) {\n                let xpath = '';\n\n                /** @type {Node|null} */\n                let elem = node;\n                while (elem !== root) {\n                    if (!elem) {\n                        throw new Error('Node is not a descendant of root');\n                    }\n                    xpath = getPathSegment(elem) + '/' + xpath;\n                    elem = elem.parentNode;\n                }\n                xpath = '/' + xpath;\n                xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n                return xpath;\n            }\n\n            /**\n             * Return the `index`'th immediate child of `element` whose tag name is\n             * `nodeName` (case insensitive).\n             *\n             * @param {Element} element\n             * @param {string} nodeName\n             * @param {number} index\n             */\n            function nthChildOfType(element, nodeName, index) {\n                nodeName = nodeName.toUpperCase();\n\n                let matchIndex = -1;\n                for (let i = 0; i < element.children.length; i++) {\n                const child = element.children[i];\n                if (child.nodeName.toUpperCase() === nodeName) {\n                    ++matchIndex;\n                    if (matchIndex === index) {\n                    return child;\n                    }\n                }\n                }\n\n                return null;\n            }\n\n            /**\n             * Evaluate a _simple XPath_ relative to a `root` element and return the\n             * matching element.\n             *\n             * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n             *\n             * Unlike `document.evaluate` this function:\n             *\n             *  - Only supports simple XPaths\n             *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n             *  - Ignores element namespaces when matching element names in the XPath against\n             *    elements in the DOM tree\n             *  - Is case insensitive for all elements, not just HTML elements\n             *\n             * The matching element is returned or `null` if no such element is found.\n             * An error is thrown if `xpath` is not a simple XPath.\n             *\n             * @param {string} xpath\n             * @param {Element} root\n             * @return {Element|null}\n             */\n            function evaluateSimpleXPath(xpath, root) {\n                const isSimpleXPath = xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n                if (!isSimpleXPath) {\n                    throw new Error('Expression is not a simple XPath');\n                }\n\n                const segments = xpath.split('/');\n                let element = root;\n\n                // Remove leading empty segment. The regex above validates that the XPath\n                // has at least two segments, with the first being empty and the others non-empty.\n                segments.shift();\n\n                for (let segment of segments) {\n                    let elementName;\n                    let elementIndex;\n\n                    const separatorPos = segment.indexOf('[');\n                    if (separatorPos !== -1) {\n                        elementName = segment.slice(0, separatorPos);\n\n                        const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n                        elementIndex = parseInt(indexStr) - 1;\n                        if (elementIndex < 0) {\n                        return null;\n                        }\n                    } else {\n                        elementName = segment;\n                        elementIndex = 0;\n                    }\n\n                    const child = nthChildOfType(element, elementName, elementIndex);\n                    if (!child) {\n                        return null;\n                    }\n\n                    element = child;\n                }\n\n                return element;\n            }\n\n            /**\n             * Finds an element node using an XPath relative to `root`\n             *\n             * Example:\n             *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n             *\n             * @param {string} xpath\n             * @param {Element} [root]\n             * @return {Node|null}\n             */\n            function nodeFromXPath(xpath, root = document.body) {\n                try {\n                    return evaluateSimpleXPath(xpath, root);\n                } catch (err) {\n                    return document.evaluate(\n                        '.' + xpath,\n                        root,\n\n                        // nb. The `namespaceResolver` and `result` arguments are optional in the spec\n                        // but required in Edge Legacy.\n                        null /* namespaceResolver */,\n                        XPathResult.FIRST_ORDERED_NODE_TYPE,\n                        null /* result */\n                    ).singleNodeValue;\n                }\n            }\n\n            /**\n             * Replace a child `node` with `replacements`.\n             *\n             * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n             *\n             * @param {ChildNode} node\n             * @param {Node[]} replacements\n             */\n            function replaceWith(node, replacements) {\n                const parent = /** @type {Node} */ (node.parentNode);\n\n                replacements.forEach(r => parent.insertBefore(r, node));\n                node.remove();\n            }\n\n            /**\n             * Remove all temporary highlights under a given root element.\n             *\n             * @param {HTMLElement} root\n             */\n            function removeAllTempHighlights() {\n                const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n                if (highlights !== undefined && highlights.length != 0){\n                    removeHighlights(highlights);\n                }\n            }\n\n            /**\n             * Remove highlights from a range previously highlighted with `highlightRange`.\n             *\n             * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n             */\n            function removeHighlights(highlights) {\n                for (var i = 0; i < highlights.length; i++) {\n                    if (highlights[i].parentNode) {\n                        const children = Array.from(highlights[i].childNodes);\n                        replaceWith(highlights[i], children);\n                    }\n                }\n            }\n\n\n            // If user selects text for new annotation\n            $(document).on('mouseup', '.originaltext', function() {\n                var selectedrange = window.getSelection().getRangeAt(0);\n\n                console.log('window.getSelection()');\n                console.log(window.getSelection());\n                console.log('selectedrange');\n                console.log(selectedrange);\n\n                if (selectedrange.cloneContents().textContent !== '') {\n                    removeAllTempHighlights(); // remove other temporary highlights\n\n                    resetForms(); // remove old form contents\n\n                    // console.log(addertoolbar);\n                    // console.log(addertoolbar.buildAdderToolbar());\n\n                    var entry = this.id.replace(/entry-/, '');\n\n                    //getSelectionValues(entry);\n\n                    //createAnnotation(entry);\n                    console.log('selectedrange.cloneContents().textContent');\n                    console.log(selectedrange.cloneContents().textContent);\n\n                    $('input[name=\"startcontainer[' + entry + ']\"]').val(xpathFromNode(selectedrange.startContainer, this));\n                    $('input[name=\"endcontainer[' + entry + ']\"]').val(xpathFromNode(selectedrange.endContainer, this));\n                    $('input[name=\"startposition[' + entry + ']\"]').val(selectedrange.startOffset);\n                    $('input[name=\"endposition[' + entry + ']\"]').val(selectedrange.endOffset);\n\n                    highlightRange(selectedrange, false, 'annotated_temp');\n\n                    $('.annotationarea-' + entry + ' .mform').show();\n                    $('#id_text_' + entry).focus();\n                }\n            });\n\n            recreateAnnotations();\n\n            // Highlight annotation and all annotated text if annotated text is hovered\n            $('.annotated').mouseenter (function() {\n                var id = this.id.replace('annotated-', '');\n                $('.annotation-'+id).addClass('hovered');\n                $('.annotated-'+id).addClass('hovered');\n            });\n\n            $('.annotated').mouseleave (function() {\n                var id = this.id.replace('annotated-', '');\n                $('.annotation-'+id).removeClass('hovered');\n                $('.annotated-'+id).removeClass('hovered');\n            });\n\n            // Highlight annotated text if annotation is hovered\n            $('.annotation').mouseenter (function() {\n                var id = this.id.replace('annotation-', '');\n                $('.annotated-'+id).addClass('hovered');\n            });\n\n            $('.annotation').mouseleave (function() {\n                var id = this.id.replace('annotation-', '');\n                $('.annotated-'+id).removeClass('hovered');\n            });\n\n            // Highlight whole temp annotation if part of temp annotation is hovered\n            $(document).on('mouseover', '.annotated_temp', function(){\n                $('.annotated_temp').addClass('hovered');\n            });\n\n            $(document).on('mouseleave', '.annotated_temp', function(){\n                $('.annotated_temp').removeClass('hovered');\n            });\n\n            // edit annotation\n            $(document).on('click', '.annotated', function(){\n                console.log('annotated text is clicked');\n                console.log(this);\n                var id = this.id.replace('annotated-', '');\n                editAnnotation(id);\n            });\n\n        }\n    };\n});"],"file":"annotations.min.js"}