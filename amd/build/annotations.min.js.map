{"version":3,"sources":["../src/annotations.js"],"names":["define","$","init","annotations","canmakeannotations","hide","removeClass","editAnnotation","annotationid","removeAllTempHighlights","resetForms","entry","val","startcontainer","endcontainer","startposition","endposition","text","show","focus","wholeTextNodesInRange","range","collapsed","root","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","textNodes","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","node","nextNode","isNodeInRange","startContainer","startOffset","splitText","endContainer","endOffset","data","length","push","highlightRange","cssClass","inPlaceholder","isInPlaceholder","textNodeSpans","prevNode","currentSpan","forEach","nextSibling","filter","span","some","test","nodeValue","highlights","nodes","highlightEl","document","createElement","className","id","parentNode","replaceChild","appendChild","childNodes","comparePoint","e","closest","getNodeName","nodeName","toLowerCase","result","getNodePosition","pos","tmp","previousSibling","getPathSegment","name","xpathFromNode","xpath","elem","Error","replace","nthChildOfType","element","index","toUpperCase","matchIndex","i","child","children","evaluateSimpleXPath","isSimpleXPath","match","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt","nodeFromXPath","body","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","replaceWith","replacements","parent","r","insertBefore","remove","Array","from","querySelectorAll","removeHighlights","on","selectedrange","window","getSelection","getRangeAt","cloneContents","textContent","Object","values","annotation","newrange","createRange","setStart","setEnd","mouseenter","addClass","mouseleave","preventDefault"],"mappings":"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","sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module for the annotation functions of the annotated diary.\n *\n * @module     mod_annotateddiary/annotations\n * @package    mod_annotateddiary\n * @copyright  2021 coactum GmbH\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n define(['jquery', 'mod_annotateddiary/addertoolbar_new'], function($) {\n    return {\n        init: function(annotations, canmakeannotations) {\n\n            // Hide all Moodle forms\n            $('.annotation-form').hide();\n\n            // remove col-mds from moodle form\n            $('.annotation-form div.col-md-3').removeClass('col-md-3');\n            $('.annotation-form div.col-md-9').removeClass('col-md-9');\n            $('.annotation-form div.form-group').removeClass('form-group');\n            $('.annotation-form div.row').removeClass('row');\n\n            function recreateAnnotations(){\n                for (let annotation of Object.values(annotations)) {\n\n                    //console.log($( \"#entry-\" + annotation.entry)[0]);\n\n                    //recreate range from db\n                    var newrange = document.createRange();\n\n                    try {\n                        newrange.setStart(nodeFromXPath(annotation.startcontainer, $( \"#entry-\" + annotation.entry)[0]), annotation.startposition);\n                        newrange.setEnd(nodeFromXPath(annotation.endcontainer, $( \"#entry-\" + annotation.entry)[0]), annotation.endposition);\n                     }\n                     catch (e) {\n                        //console.log('try/catch');\n                        //console.log(e);\n                     }\n\n                    //console.log('recreateAnnotations after setStart/End');\n\n                    highlightRange(newrange, annotation.id);\n\n                }\n            }\n\n            function editAnnotation(annotationid) {\n                if (canmakeannotations) {\n                    removeAllTempHighlights();\n                    resetForms();\n\n                    //console.log('annotations from js');\n                    //console.log(annotations);\n\n                    var entry = annotations[annotationid].entry;\n\n                    //console.log(entry);\n\n                    $('input[name=\"startcontainer[' + entry + ']\"]').val(annotations[annotationid].startcontainer);\n                    $('input[name=\"endcontainer[' + entry + ']\"]').val(annotations[annotationid].endcontainer);\n                    $('input[name=\"startposition[' + entry + ']\"]').val(annotations[annotationid].startposition);\n                    $('input[name=\"endposition[' + entry + ']\"]').val(annotations[annotationid].endposition);\n\n                    $('input[name=\"annotationid[' + entry + ']\"]').val(annotationid);\n\n                    $('textarea[name=\"text[' + entry + ']\"]').val(annotations[annotationid].text);\n\n                    $('.annotationarea-' + entry + ' .annotation-form').show();\n                    $('#id_text_' + entry).focus();\n                }\n            }\n\n            // function deleteAnnotation(annotationid) {\n\n            //     //console.log('delete annotation');\n            //     //console.log(annotationid);\n\n            //     // removeAllTempHighlights();\n            //     // resetForms();\n\n            //     // var entry = annotations[annotationid].entry;\n\n            //     // console.log(entry);\n\n            //     // $('input[name=\"startcontainer[' + entry + ']\"]').val(annotations[annotationid].startcontainer);\n            //     // $('input[name=\"endcontainer[' + entry + ']\"]').val(annotations[annotationid].endcontainer);\n            //     // $('input[name=\"startposition[' + entry + ']\"]').val(annotations[annotationid].startposition);\n            //     // $('input[name=\"endposition[' + entry + ']\"]').val(annotations[annotationid].endposition);\n\n            //     // $('textarea[name=\"text[' + entry + ']\"]').val(annotations[annotationid].text);\n\n            //     // $('.annotationarea-' + entry + ' .annotation-form').show();\n            //     // $('#id_text_' + entry).focus();\n            // }\n\n            function resetForms(){\n                $('.annotation-form').hide();\n\n                $('.annotation-form input[name^=\"annotationid\"]').val(null);\n\n                $('.annotation-form input[name^=\"startcontainer\"]').val(-1);\n                $('.annotation-form input[name^=\"endcontainer\"]').val(-1);\n                $('.annotation-form input[name^=\"startposition\"]').val(-1);\n                $('.annotation-form input[name^=\"endposition\"]').val(-1);\n\n                $('.annotation-form textarea[name^=\"text\"]').val('');\n            }\n\n            /**\n             * Return text nodes which are entirely inside `range`.\n             *\n             * If a range starts or ends part-way through a text node, the node is split\n             * and the part inside the range is returned.\n             *\n             * @param {Range} range\n             * @return {Text[]}\n             */\n            function wholeTextNodesInRange(range) {\n                if (range.collapsed) {\n                    // Exit early for an empty range to avoid an edge case that breaks the algorithm\n                    // below. Splitting a text node at the start of an empty range can leave the\n                    // range ending in the left part rather than the right part.\n                    return [];\n                }\n\n                /** @type {Node|null} */\n                let root = range.commonAncestorContainer;\n                if (root.nodeType !== Node.ELEMENT_NODE) {\n                    // If the common ancestor is not an element, set it to the parent element to\n                    // ensure that the loop below visits any text nodes generated by splitting\n                    // the common ancestor.\n                    //\n                    // Note that `parentElement` may be `null`.\n                    root = root.parentElement;\n                }\n                if (!root) {\n                    // If there is no root element then we won't be able to insert highlights,\n                    // so exit here.\n                    return [];\n                }\n\n                const textNodes = [];\n                const nodeIter = /** @type {Document} */ (\n                root.ownerDocument\n                ).createNodeIterator(\n                root,\n                NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n                );\n                let node;\n                while ((node = nodeIter.nextNode())) {\n                    if (!isNodeInRange(range, node)) {\n                        continue;\n                    }\n                    let text = /** @type {Text} */ (node);\n\n                    if (text === range.startContainer && range.startOffset > 0) {\n                        // Split `text` where the range starts. The split will create a new `Text`\n                        // node which will be in the range and will be visited in the next loop iteration.\n                        text.splitText(range.startOffset);\n                        continue;\n                    }\n\n                    if (text === range.endContainer && range.endOffset < text.data.length) {\n                        // Split `text` where the range ends, leaving it as the part in the range.\n                        text.splitText(range.endOffset);\n                    }\n\n                    textNodes.push(text);\n                }\n\n                return textNodes;\n            }\n\n            /**\n             * Wraps the DOM Nodes within the provided range with a highlight\n             * element of the specified class and returns the highlight Elements.\n             *\n             * @param {Range} range - Range to be highlighted\n             * @param {string} cssClass - A CSS class to use for the highlight\n             * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n             */\n            function highlightRange(range, annotationid = false, cssClass = 'annotated') {\n\n                //console.log('highlightRange start');\n\n                const textNodes = wholeTextNodesInRange(range);\n\n                // Check if this range refers to a placeholder for not-yet-rendered content in\n                // a PDF. These highlights should be invisible.\n                const inPlaceholder = textNodes.length > 0 && isInPlaceholder(textNodes[0]);\n\n                // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n                // adjacent, we only need to create one highlight element for the group.\n                let textNodeSpans = [];\n                let prevNode = null;\n                let currentSpan = null;\n\n                textNodes.forEach(node => {\n                if (prevNode && prevNode.nextSibling === node) {\n                    currentSpan.push(node);\n                } else {\n                    currentSpan = [node];\n                    textNodeSpans.push(currentSpan);\n                }\n                prevNode = node;\n                });\n\n                // Filter out text node spans that consist only of white space. This avoids\n                // inserting highlight elements in places that can only contain a restricted\n                // subset of nodes such as table rows and lists.\n                const whitespace = /^\\s*$/;\n                textNodeSpans = textNodeSpans.filter(span =>\n                // Check for at least one text node with non-space content.\n                span.some(node => !whitespace.test(node.nodeValue))\n                );\n\n                // Wrap each text node span with a `<hypothesis-highlight>` element.\n                const highlights = [];\n                textNodeSpans.forEach(nodes => {\n                // A custom element name is used here rather than `<span>` to reduce the\n                // likelihood of highlights being hidden by page styling.\n\n                /** @type {HighlightElement} */\n                const highlightEl = document.createElement('span');\n                highlightEl.className = cssClass;\n\n                if (annotationid) {\n                    highlightEl.className += ' ' + cssClass + '-' + annotationid;\n                    highlightEl.id = cssClass + '-' + annotationid;\n                }\n\n                nodes[0].parentNode.replaceChild(highlightEl, nodes[0]);\n                nodes.forEach(node => highlightEl.appendChild(node));\n\n                highlights.push(highlightEl);\n                });\n\n                //console.log('highlightRange end');\n\n\n                return highlights;\n            }\n\n            /**\n             * Returns true if any part of `node` lies within `range`.\n             *\n             * @param {Range} range\n             * @param {Node} node\n             */\n            function isNodeInRange(range, node) {\n                try {\n                    const length = node.nodeValue?.length ?? node.childNodes.length;\n                    return (\n                        // Check start of node is before end of range.\n                        range.comparePoint(node, 0) <= 0 &&\n                        // Check end of node is after start of range.\n                        range.comparePoint(node, length) >= 0\n                    );\n                } catch (e) {\n                    // `comparePoint` may fail if the `range` and `node` do not share a common\n                    // ancestor or `node` is a doctype.\n                return false;\n                }\n            }\n\n            /**\n             * CSS selector that will match the placeholder within a page/tile container.\n             */\n            const placeholderSelector = '.annotator-placeholder';\n\n            /**\n             * Return true if `node` is inside a placeholder element created with `createPlaceholder`.\n             *\n             * This is typically used to test if a highlight element associated with an\n             * anchor is inside a placeholder.\n             *\n             * @param {Node} node\n             */\n            function isInPlaceholder(node) {\n                if (!node.parentElement) {\n                    return false;\n                }\n                return node.parentElement.closest(placeholderSelector) !== null;\n            }\n\n\n\n\n\n            /**\n             * Get the node name for use in generating an xpath expression.\n             *\n             * @param {Node} node\n             */\n            function getNodeName(node) {\n                const nodeName = node.nodeName.toLowerCase();\n                let result = nodeName;\n                if (nodeName === '#text') {\n                    result = 'text()';\n                }\n                return result;\n            }\n\n            /**\n             * Get the index of the node as it appears in its parent's child list\n             *\n             * @param {Node} node\n             */\n            function getNodePosition(node) {\n                let pos = 0;\n                /** @type {Node|null} */\n                let tmp = node;\n                while (tmp) {\n                    if (tmp.nodeName === node.nodeName) {\n                        pos += 1;\n                    }\n                    tmp = tmp.previousSibling;\n                    }\n                return pos;\n            }\n\n            function getPathSegment(node) {\n                const name = getNodeName(node);\n                const pos = getNodePosition(node);\n                return `${name}[${pos}]`;\n            }\n\n            /**\n             * A simple XPath generator which can generate XPaths of the form\n             * /tag[index]/tag[index].\n             *\n             * @param {Node} node - The node to generate a path to\n             * @param {Node} root - Root node to which the returned path is relative\n             */\n            function xpathFromNode(node, root) {\n                let xpath = '';\n\n                /** @type {Node|null} */\n                let elem = node;\n                while (elem !== root) {\n                    if (!elem) {\n                        throw new Error('Node is not a descendant of root');\n                    }\n                    xpath = getPathSegment(elem) + '/' + xpath;\n                    elem = elem.parentNode;\n                }\n                xpath = '/' + xpath;\n                xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n                return xpath;\n            }\n\n            /**\n             * Return the `index`'th immediate child of `element` whose tag name is\n             * `nodeName` (case insensitive).\n             *\n             * @param {Element} element\n             * @param {string} nodeName\n             * @param {number} index\n             */\n            function nthChildOfType(element, nodeName, index) {\n                nodeName = nodeName.toUpperCase();\n\n                let matchIndex = -1;\n                for (let i = 0; i < element.children.length; i++) {\n                const child = element.children[i];\n                if (child.nodeName.toUpperCase() === nodeName) {\n                    ++matchIndex;\n                    if (matchIndex === index) {\n                    return child;\n                    }\n                }\n                }\n\n                return null;\n            }\n\n            /**\n             * Evaluate a _simple XPath_ relative to a `root` element and return the\n             * matching element.\n             *\n             * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n             *\n             * Unlike `document.evaluate` this function:\n             *\n             *  - Only supports simple XPaths\n             *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n             *  - Ignores element namespaces when matching element names in the XPath against\n             *    elements in the DOM tree\n             *  - Is case insensitive for all elements, not just HTML elements\n             *\n             * The matching element is returned or `null` if no such element is found.\n             * An error is thrown if `xpath` is not a simple XPath.\n             *\n             * @param {string} xpath\n             * @param {Element} root\n             * @return {Element|null}\n             */\n            function evaluateSimpleXPath(xpath, root) {\n                const isSimpleXPath = xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n                if (!isSimpleXPath) {\n                    throw new Error('Expression is not a simple XPath');\n                }\n\n                const segments = xpath.split('/');\n                let element = root;\n\n                // Remove leading empty segment. The regex above validates that the XPath\n                // has at least two segments, with the first being empty and the others non-empty.\n                segments.shift();\n\n                for (let segment of segments) {\n                    let elementName;\n                    let elementIndex;\n\n                    const separatorPos = segment.indexOf('[');\n                    if (separatorPos !== -1) {\n                        elementName = segment.slice(0, separatorPos);\n\n                        const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n                        elementIndex = parseInt(indexStr) - 1;\n                        if (elementIndex < 0) {\n                        return null;\n                        }\n                    } else {\n                        elementName = segment;\n                        elementIndex = 0;\n                    }\n\n                    const child = nthChildOfType(element, elementName, elementIndex);\n                    if (!child) {\n                        return null;\n                    }\n\n                    element = child;\n                }\n\n                return element;\n            }\n\n            /**\n             * Finds an element node using an XPath relative to `root`\n             *\n             * Example:\n             *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n             *\n             * @param {string} xpath\n             * @param {Element} [root]\n             * @return {Node|null}\n             */\n            function nodeFromXPath(xpath, root = document.body) {\n                try {\n                    return evaluateSimpleXPath(xpath, root);\n                } catch (err) {\n                    return document.evaluate(\n                        '.' + xpath,\n                        root,\n\n                        // nb. The `namespaceResolver` and `result` arguments are optional in the spec\n                        // but required in Edge Legacy.\n                        null /* namespaceResolver */,\n                        XPathResult.FIRST_ORDERED_NODE_TYPE,\n                        null /* result */\n                    ).singleNodeValue;\n                }\n            }\n\n            /**\n             * Replace a child `node` with `replacements`.\n             *\n             * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n             *\n             * @param {ChildNode} node\n             * @param {Node[]} replacements\n             */\n            function replaceWith(node, replacements) {\n                const parent = /** @type {Node} */ (node.parentNode);\n\n                replacements.forEach(r => parent.insertBefore(r, node));\n                node.remove();\n            }\n\n            /**\n             * Remove all temporary highlights under a given root element.\n             *\n             * @param {HTMLElement} root\n             */\n            function removeAllTempHighlights() {\n                const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n                if (highlights !== undefined && highlights.length != 0){\n                    removeHighlights(highlights);\n                }\n            }\n\n            /**\n             * Remove highlights from a range previously highlighted with `highlightRange`.\n             *\n             * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n             */\n            function removeHighlights(highlights) {\n                for (var i = 0; i < highlights.length; i++) {\n                    if (highlights[i].parentNode) {\n                        const children = Array.from(highlights[i].childNodes);\n                        replaceWith(highlights[i], children);\n                    }\n                }\n            }\n\n\n            // If user selects text for new annotation\n            $(document).on('mouseup', '.originaltext', function() {\n                var selectedrange = window.getSelection().getRangeAt(0);\n\n                // console.log('i should make annotation');\n\n                // console.log('window.getSelection()');\n                // console.log(window.getSelection());\n                // console.log('selectedrange');\n                // console.log(selectedrange);\n\n                if (selectedrange.cloneContents().textContent !== '' && canmakeannotations) {\n                    removeAllTempHighlights(); // remove other temporary highlights\n\n                    resetForms(); // remove old form contents\n\n                    //console.log('i should make concrete annotation');\n\n                    // console.log(addertoolbar);\n                    // console.log(addertoolbar.buildAdderToolbar());\n\n                    var entry = this.id.replace(/entry-/, '');\n\n                    //getSelectionValues(entry);\n\n                    //createAnnotation(entry);\n                    //console.log('selectedrange.cloneContents().textContent');\n                    //console.log(selectedrange.cloneContents().textContent);\n\n                    $('input[name=\"startcontainer[' + entry + ']\"]').val(xpathFromNode(selectedrange.startContainer, this));\n                    $('input[name=\"endcontainer[' + entry + ']\"]').val(xpathFromNode(selectedrange.endContainer, this));\n                    $('input[name=\"startposition[' + entry + ']\"]').val(selectedrange.startOffset);\n                    $('input[name=\"endposition[' + entry + ']\"]').val(selectedrange.endOffset);\n\n                    highlightRange(selectedrange, false, 'annotated_temp');\n\n                    $('.annotationarea-' + entry + ' .annotation-form').show();\n                    $('#id_text_' + entry).focus();\n                }\n            });\n\n            recreateAnnotations();\n\n            // Highlight annotation and all annotated text if annotated text is hovered\n            $('.annotated').mouseenter (function() {\n                var id = this.id.replace('annotated-', '');\n                $('.annotation-'+id).addClass('hovered');\n                $('.annotated-'+id).addClass('hovered');\n            });\n\n            $('.annotated').mouseleave (function() {\n                var id = this.id.replace('annotated-', '');\n                $('.annotation-'+id).removeClass('hovered');\n                $('.annotated-'+id).removeClass('hovered');\n            });\n\n            // Highlight annotated text if annotation is hovered\n            $('.annotation').mouseenter (function() {\n                var id = this.id.replace('annotation-', '');\n                $('.annotated-'+id).addClass('hovered');\n            });\n\n            $('.annotation').mouseleave (function() {\n                var id = this.id.replace('annotation-', '');\n                $('.annotated-'+id).removeClass('hovered');\n            });\n\n            // Highlight whole temp annotation if part of temp annotation is hovered\n            $(document).on('mouseover', '.annotated_temp', function(){\n                $('.annotated_temp').addClass('hovered');\n            });\n\n            $(document).on('mouseleave', '.annotated_temp', function(){\n                $('.annotated_temp').removeClass('hovered');\n            });\n\n            // onclick listener for editing annotation\n            $(document).on('click', '.annotated', function(){\n                //console.log('annotated text is clicked');\n                //console.log(this);\n                var id = this.id.replace('annotated-', '');\n                editAnnotation(id);\n            });\n\n            // onclick listener for editing annotation\n            $(document).on('click', '.edit-annotation', function(){\n                //console.log('edit annotation button clicked');\n                //console.log(this);\n                var id = this.id.replace('edit-annotation-', '');\n                editAnnotation(id);\n            });\n\n            // onclick listener for deleting annotation\n            // $(document).on('click', '.delete-annotation', function(){\n            //     //console.log('delete annotation button clicked');\n            //     //console.log(this);\n            //     var id = this.id.replace('delete-annotation-', '');\n            //     deleteAnnotation(id);\n            // });\n\n            // onclick listener if form is canceled\n            $(document).on('click', '#id_cancel', function(e){\n                e.preventDefault();\n\n                //console.log('form is canceled');\n                //console.log(e);\n\n                removeAllTempHighlights(); // remove other temporary highlights\n\n                resetForms(); // remove old form contents\n            });\n\n        }\n    };\n});"],"file":"annotations.min.js"}