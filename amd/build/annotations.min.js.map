{"version":3,"file":"annotations.min.js","sources":["../src/annotations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module for the annotation functions of the margic.\n *\n * @module     mod_margic/annotations\n * @copyright  2022 coactum GmbH\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport $ from 'jquery';\n\nexport const init = (cmid, canmakeannotations, myuserid) => {\n\n    var edited = false;\n    var annotations = Array();\n\n    // Hide all Moodle forms.\n    $('.annotation-form').hide();\n\n    // Remove col-mds from moodle form.\n    $('.annotation-form div.col-md-3').removeClass('col-md-3');\n    $('.annotation-form div.col-md-9').removeClass('col-md-9');\n    $('.annotation-form div.form-group').removeClass('form-group');\n    $('.annotation-form div.row').removeClass('row');\n\n    // Onclick listener if form is canceled.\n    $(document).on('click', '#id_cancel', function(e) {\n        e.preventDefault();\n\n        removeAllTempHighlights(); // Remove other temporary highlights.\n\n        resetForms(); // Remove old form contents.\n\n        edited = false;\n    });\n\n    // Listen for return key pressed to submit annotation form.\n    $('textarea').keypress(function (e) {\n        if (e.which == 13) {\n            $(this).parents(':eq(2)').submit();\n            e.preventDefault();\n        }\n    });\n\n    // If user selects text for new annotation\n    $(document).on('mouseup', '.originaltext', function () {\n        var selectedrange = window.getSelection().getRangeAt(0);\n\n        if (selectedrange.cloneContents().textContent !== '' && canmakeannotations) {\n\n            removeAllTempHighlights(); // Remove other temporary highlights.\n\n            resetForms(); // Remove old form contents.\n\n            var entry = this.id.replace(/entry-/, '');\n\n            $('.annotation-form-' + entry + ' input[name=\"startcontainer\"]').val(\n                xpathFromNode(selectedrange.startContainer, this));\n            $('.annotation-form-' + entry + ' input[name=\"endcontainer\"]').val(\n                xpathFromNode(selectedrange.endContainer, this));\n            $('.annotation-form-' + entry + ' input[name=\"startposition\"]').val(selectedrange.startOffset);\n            $('.annotation-form-' + entry + ' input[name=\"endposition\"]').val(selectedrange.endOffset);\n\n            $('.annotation-form-' + entry + ' select').val(1);\n\n            var annotatedtext = highlightRange(selectedrange, false, 'annotated_temp');\n\n            if (annotatedtext != '') {\n                $('#annotationpreview-temp-' + entry).html(annotatedtext);\n            }\n\n            $('.annotationarea-' + entry + ' .annotation-form').show();\n            $('.annotation-form-' + entry + ' #id_text').focus();\n        }\n    });\n\n    // Fetch and recreate annotations.\n    $.ajax({\n        url: './annotations.php',\n        data: {'id': cmid, 'getannotations': 1},\n        success: function(response) {\n            annotations = JSON.parse(response);\n            recreateAnnotations();\n\n            // Highlight annotation and all annotated text if annotated text is hovered\n            $('.annotated').mouseenter(function () {\n                var id = this.id.replace('annotated-', '');\n                $('.annotationpreview-' + id).addClass('hovered');\n                $('.annotated-' + id).addClass('hovered');\n                $('.annotation-box-' + id + ' .errortype').addClass('hovered');\n\n            });\n\n            $('.annotated').mouseleave(function () {\n                var id = this.id.replace('annotated-', '');\n                $('.annotationpreview-' + id).removeClass('hovered');\n                $('.annotated-' + id).removeClass('hovered');\n                $('.annotation-box-' + id + ' .errortype').removeClass('hovered');\n            });\n\n            // Highlight annotated text if annotationpreview is hovered\n            $('.annotatedtextpreview').mouseenter(function () {\n                var id = this.id.replace('annotationpreview-', '');\n                $('.annotated-' + id).addClass('hovered');\n            });\n\n            $('.annotatedtextpreview').mouseleave(function () {\n                var id = this.id.replace('annotationpreview-', '');\n                $('.annotated-' + id).removeClass('hovered');\n            });\n\n            // Highlight whole temp annotation if part of temp annotation is hovered\n            $(document).on('mouseover', '.annotated_temp', function () {\n                $('.annotated_temp').addClass('hovered');\n            });\n\n            $(document).on('mouseleave', '.annotated_temp', function () {\n                $('.annotated_temp').removeClass('hovered');\n            });\n\n            // Onclick listener for editing annotation.\n            $(document).on('click', '.annotated', function () {\n                var id = this.id.replace('annotated-', '');\n                editAnnotation(id);\n            });\n\n            // Onclick listener for editing annotation.\n            $(document).on('click', '.edit-annotation', function () {\n                var id = this.id.replace('edit-annotation-', '');\n                editAnnotation(id);\n            });\n\n            // Onclick listener for click on annotation-box.\n            // $(document).on('click', '.annotation-box', function() {\n            //     var id = this.id.replace('annotation-box-', '');\n            //     $('#annotated-' + id).focus();\n            // });\n        },\n        error: function() {\n            alert ('Error fetiching annotations');\n        }\n    });\n\n    /**\n     * Recreate annotations.\n     *\n     */\n    function recreateAnnotations() {\n\n        for (let annotation of Object.values(annotations)) {\n\n            // Recreate range from db.\n            var newrange = document.createRange();\n\n            try {\n                newrange.setStart(\n                    nodeFromXPath(annotation.startcontainer, $(\"#entry-\" + annotation.entry)[0]), annotation.startposition);\n                newrange.setEnd(\n                    nodeFromXPath(annotation.endcontainer, $(\"#entry-\" + annotation.entry)[0]), annotation.endposition);\n            } catch (e) {\n                // eslint-disable-line\n            }\n\n            var annotatedtext = highlightRange(newrange, annotation.id, 'annotated', annotation.color);\n\n            if (annotatedtext != '') {\n                $('#annotationpreview-' + annotation.id).html(annotatedtext);\n            }\n        }\n    }\n\n    /**\n     * Edit annotation.\n     *\n     * @param {int} annotationid\n     */\n    function editAnnotation(annotationid) {\n\n        if (edited == annotationid) {\n            removeAllTempHighlights(); // Remove other temporary highlights.\n            resetForms(); // Remove old form contents.\n            edited = false;\n        } else if (canmakeannotations && myuserid == annotations[annotationid].userid) {\n            removeAllTempHighlights(); // Remove other temporary highlights.\n            resetForms(); // Remove old form contents.\n\n            edited = annotationid;\n\n            var entry = annotations[annotationid].entry;\n\n            $('.annotation-box-' + annotationid).hide(); // Hide edited annotation-box.\n\n            $('.annotation-form-' + entry + ' input[name=\"startcontainer\"]').val(annotations[annotationid].startcontainer);\n            $('.annotation-form-' + entry + ' input[name=\"endcontainer\"]').val(annotations[annotationid].endcontainer);\n            $('.annotation-form-' + entry + ' input[name=\"startposition\"]').val(annotations[annotationid].startposition);\n            $('.annotation-form-' + entry + ' input[name=\"endposition\"]').val(annotations[annotationid].endposition);\n\n            $('.annotation-form-' + entry + ' input[name=\"annotationid\"]').val(annotationid);\n\n            $('.annotation-form-' + entry + ' textarea[name=\"text\"]').val(annotations[annotationid].text);\n\n            $('.annotation-form-' + entry + ' select').val(annotations[annotationid].type);\n\n            $('#annotationpreview-temp-' + entry).html($('#annotationpreview-' + annotationid).html());\n            $('#annotationpreview-temp-' + entry).css('border-color', '#' + annotations[annotationid].color);\n\n            $('.annotationarea-' + entry + ' .annotation-form').insertBefore('.annotation-box-' + annotationid);\n            $('.annotationarea-' + entry + ' .annotation-form').show();\n            $('.annotationarea-' + entry + ' #id_text').focus();\n        } else {\n            $('.annotation-box-' + annotationid).focus();\n        }\n    }\n\n    /**\n     * Reset all annotation forms\n     */\n    function resetForms() {\n        $('.annotation-form').hide();\n\n        $('.annotation-form input[name^=\"annotationid\"]').val(null);\n\n        $('.annotation-form input[name^=\"startcontainer\"]').val(-1);\n        $('.annotation-form input[name^=\"endcontainer\"]').val(-1);\n        $('.annotation-form input[name^=\"startposition\"]').val(-1);\n        $('.annotation-form input[name^=\"endposition\"]').val(-1);\n\n        $('.annotation-form textarea[name^=\"text\"]').val('');\n\n        $('.annotation-box').not('.annotation-form').show(); // To show again edited annotation.\n    }\n\n    /**\n     * Remove all temporary highlights under a given root element.\n     */\n     function removeAllTempHighlights() {\n        const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n        if (highlights !== undefined && highlights.length != 0) {\n            removeHighlights(highlights);\n        }\n    }\n\n    /**\n     * Remove highlights from a range previously highlighted with `highlightRange`.\n     *\n     * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n     */\n    function removeHighlights(highlights) {\n        for (var i = 0; i < highlights.length; i++) {\n            if (highlights[i].parentNode) {\n                var pn = highlights[i].parentNode;\n                const children = Array.from(highlights[i].childNodes);\n                replaceWith(highlights[i], children);\n                pn.normalize();\n            }\n        }\n    }\n\n    /**\n     * Return text nodes which are entirely inside `range`.\n     *\n     * If a range starts or ends part-way through a text node, the node is split\n     * and the part inside the range is returned.\n     *\n     * @param {Range} range\n     * @return {Text[]}\n     */\n    function wholeTextNodesInRange(range) {\n        if (range.collapsed) {\n            // Exit early for an empty range to avoid an edge case that breaks the algorithm\n            // below. Splitting a text node at the start of an empty range can leave the\n            // range ending in the left part rather than the right part.\n            return [];\n        }\n\n        /** @type {Node|null} */\n        let root = range.commonAncestorContainer;\n        if (root.nodeType !== Node.ELEMENT_NODE) {\n            // If the common ancestor is not an element, set it to the parent element to\n            // ensure that the loop below visits any text nodes generated by splitting\n            // the common ancestor.\n            //\n            // Note that `parentElement` may be `null`.\n            root = root.parentElement;\n        }\n        if (!root) {\n            // If there is no root element then we won't be able to insert highlights,\n            // so exit here.\n            return [];\n        }\n\n        const textNodes = [];\n        const nodeIter = /** @type {Document} */ (\n            root.ownerDocument\n        ).createNodeIterator(\n            root,\n            NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n        );\n        let node;\n        while ((node = nodeIter.nextNode())) {\n            if (!isNodeInRange(range, node)) {\n                continue;\n            }\n            let text = /** @type {Text} */ (node);\n\n            if (text === range.startContainer && range.startOffset > 0) {\n                // Split `text` where the range starts. The split will create a new `Text`\n                // node which will be in the range and will be visited in the next loop iteration.\n                text.splitText(range.startOffset);\n                continue;\n            }\n\n            if (text === range.endContainer && range.endOffset < text.data.length) {\n                // Split `text` where the range ends, leaving it as the part in the range.\n                text.splitText(range.endOffset);\n            }\n\n            textNodes.push(text);\n        }\n\n        return textNodes;\n    }\n\n    /**\n     * Wraps the DOM Nodes within the provided range with a highlight\n     * element of the specified class and returns the highlight Elements.\n     *\n     * @param {Range} range - Range to be highlighted\n     * @param {int} annotationid - ID of annotation\n     * @param {string} cssClass - A CSS class to use for the highlight\n     * @param {string} color - Color of the highlighting\n     * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n     */\n    function highlightRange(range, annotationid = false, cssClass = 'annotated', color = 'FFFF00') {\n\n        const textNodes = wholeTextNodesInRange(range);\n\n        // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n        // adjacent, we only need to create one highlight element for the group.\n        let textNodeSpans = [];\n        let prevNode = null;\n        let currentSpan = null;\n\n        textNodes.forEach(node => {\n            if (prevNode && prevNode.nextSibling === node) {\n                currentSpan.push(node);\n            } else {\n                currentSpan = [node];\n                textNodeSpans.push(currentSpan);\n            }\n            prevNode = node;\n        });\n\n        // Filter out text node spans that consist only of white space. This avoids\n        // inserting highlight elements in places that can only contain a restricted\n        // subset of nodes such as table rows and lists.\n        const whitespace = /^\\s*$/;\n        textNodeSpans = textNodeSpans.filter(span =>\n            // Check for at least one text node with non-space content.\n            span.some(node => !whitespace.test(node.nodeValue))\n        );\n\n        // Wrap each text node span with a `<span>` element.\n        var hihglightedtext = '';\n\n        textNodeSpans.forEach(nodes => {\n            const highlightEl = document.createElement('span');\n            highlightEl.className = cssClass;\n\n            if (annotationid) {\n                highlightEl.className += ' ' + cssClass + '-' + annotationid;\n                // highlightEl.tabIndex = 1;\n                highlightEl.style = \"text-decoration:underline; text-decoration-color: #\" + color;\n                highlightEl.id = cssClass + '-' + annotationid;\n                highlightEl.style.backgroundColor = '#' + color;\n            }\n\n            hihglightedtext += nodes[0].textContent;\n\n            nodes[0].parentNode.replaceChild(highlightEl, nodes[0]);\n            nodes.forEach(node => highlightEl.appendChild(node));\n\n        });\n\n        return hihglightedtext;\n    }\n\n    /**\n     * Returns true if any part of `node` lies within `range`.\n     *\n     * @param {Range} range\n     * @param {Node} node\n     * @return {bool} - If node is in range\n     */\n    function isNodeInRange(range, node) {\n        try {\n            const length = node.nodeValue?.length ?? node.childNodes.length;\n            return (\n                // Check start of node is before end of range.\n                range.comparePoint(node, 0) <= 0 &&\n                // Check end of node is after start of range.\n                range.comparePoint(node, length) >= 0\n            );\n        } catch (e) {\n            // `comparePoint` may fail if the `range` and `node` do not share a common\n            // ancestor or `node` is a doctype.\n            return false;\n        }\n    }\n\n    /**\n     * Get the node name for use in generating an xpath expression.\n     *\n     * @param {Node} node\n     * @return {string} - Name of the node\n     */\n    function getNodeName(node) {\n        const nodeName = node.nodeName.toLowerCase();\n        let result = nodeName;\n        if (nodeName === '#text') {\n            result = 'text()';\n        }\n        return result;\n    }\n\n    /**\n     * Get the index of the node as it appears in its parent's child list\n     *\n     * @param {Node} node\n     * @return {int} - Position of the node\n     */\n    function getNodePosition(node) {\n        let pos = 0;\n        /** @type {Node|null} */\n        let tmp = node;\n        while (tmp) {\n            if (tmp.nodeName === node.nodeName) {\n                pos += 1;\n            }\n            tmp = tmp.previousSibling;\n        }\n        return pos;\n    }\n\n    /**\n     * Get the path segments to the node\n     *\n     * @param {Node} node\n     * @return {array} - Path segments\n     */\n    function getPathSegment(node) {\n        const name = getNodeName(node);\n        const pos = getNodePosition(node);\n        return `${name}[${pos}]`;\n    }\n\n    /**\n     * A simple XPath generator which can generate XPaths of the form\n     * /tag[index]/tag[index].\n     *\n     * @param {Node} node - The node to generate a path to\n     * @param {Node} root - Root node to which the returned path is relative\n     * @return {string} - The xpath of a node\n     */\n    function xpathFromNode(node, root) {\n        let xpath = '';\n\n        /** @type {Node|null} */\n        let elem = node;\n        while (elem !== root) {\n            if (!elem) {\n                throw new Error('Node is not a descendant of root');\n            }\n            xpath = getPathSegment(elem) + '/' + xpath;\n            elem = elem.parentNode;\n        }\n        xpath = '/' + xpath;\n        xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n        return xpath;\n    }\n\n    /**\n     * Return the `index`'th immediate child of `element` whose tag name is\n     * `nodeName` (case insensitive).\n     *\n     * @param {Element} element\n     * @param {string} nodeName\n     * @param {number} index\n     * @return {Element|null} - The child element or null\n     */\n    function nthChildOfType(element, nodeName, index) {\n        nodeName = nodeName.toUpperCase();\n\n        let matchIndex = -1;\n        for (let i = 0; i < element.children.length; i++) {\n            const child = element.children[i];\n            if (child.nodeName.toUpperCase() === nodeName) {\n                ++matchIndex;\n                if (matchIndex === index) {\n                    return child;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Evaluate a _simple XPath_ relative to a `root` element and return the\n     * matching element.\n     *\n     * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n     *\n     * Unlike `document.evaluate` this function:\n     *\n     *  - Only supports simple XPaths\n     *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n     *  - Ignores element namespaces when matching element names in the XPath against\n     *    elements in the DOM tree\n     *  - Is case insensitive for all elements, not just HTML elements\n     *\n     * The matching element is returned or `null` if no such element is found.\n     * An error is thrown if `xpath` is not a simple XPath.\n     *\n     * @param {string} xpath\n     * @param {Element} root\n     * @return {Element|null}\n     */\n    function evaluateSimpleXPath(xpath, root) {\n        const isSimpleXPath = xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n        if (!isSimpleXPath) {\n            throw new Error('Expression is not a simple XPath');\n        }\n\n        const segments = xpath.split('/');\n        let element = root;\n\n        // Remove leading empty segment. The regex above validates that the XPath\n        // has at least two segments, with the first being empty and the others non-empty.\n        segments.shift();\n\n        for (let segment of segments) {\n            let elementName;\n            let elementIndex;\n\n            const separatorPos = segment.indexOf('[');\n            if (separatorPos !== -1) {\n                elementName = segment.slice(0, separatorPos);\n\n                const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n                elementIndex = parseInt(indexStr) - 1;\n                if (elementIndex < 0) {\n                    return null;\n                }\n            } else {\n                elementName = segment;\n                elementIndex = 0;\n            }\n\n            const child = nthChildOfType(element, elementName, elementIndex);\n            if (!child) {\n                return null;\n            }\n\n            element = child;\n        }\n\n        return element;\n    }\n\n    /**\n     * Finds an element node using an XPath relative to `root`\n     *\n     * Example:\n     *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n     *\n     * @param {string} xpath\n     * @param {Element} [root]\n     * @return {Node|null}\n     */\n    function nodeFromXPath(xpath, root = document.body) {\n        try {\n            return evaluateSimpleXPath(xpath, root);\n        } catch (err) {\n            return document.evaluate(\n                '.' + xpath,\n                root,\n\n                // The `namespaceResolver` and `result` arguments are optional in the spec\n                // but required in Edge Legacy.\n                null /* NamespaceResolver */,\n                XPathResult.FIRST_ORDERED_NODE_TYPE,\n                null /* Result */\n            ).singleNodeValue;\n        }\n    }\n\n    /**\n     * Replace a child `node` with `replacements`.\n     *\n     * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n     *\n     * @param {ChildNode} node\n     * @param {Node[]} replacements\n     */\n    function replaceWith(node, replacements) {\n        const parent = /** @type {Node} */ (node.parentNode);\n\n        replacements.forEach(r => parent.insertBefore(r, node));\n        node.remove();\n    }\n};"],"names":["cmid","canmakeannotations","myuserid","edited","annotations","Array","editAnnotation","annotationid","removeAllTempHighlights","resetForms","userid","entry","hide","val","startcontainer","endcontainer","startposition","endposition","text","type","html","css","color","insertBefore","show","focus","not","highlights","from","querySelectorAll","undefined","length","i","parentNode","pn","children","childNodes","replaceWith","normalize","removeHighlights","wholeTextNodesInRange","range","collapsed","root","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","node","textNodes","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","nextNode","isNodeInRange","startContainer","startOffset","splitText","endContainer","endOffset","data","push","highlightRange","cssClass","textNodeSpans","prevNode","currentSpan","forEach","nextSibling","whitespace","filter","span","some","test","nodeValue","hihglightedtext","nodes","highlightEl","document","createElement","className","style","id","backgroundColor","textContent","replaceChild","appendChild","_node$nodeValue","comparePoint","e","getPathSegment","name","nodeName","toLowerCase","result","getNodeName","pos","tmp","previousSibling","getNodePosition","xpathFromNode","xpath","elem","Error","replace","nthChildOfType","element","index","toUpperCase","matchIndex","child","evaluateSimpleXPath","match","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt","nodeFromXPath","body","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","replacements","parent","r","remove","removeClass","on","preventDefault","keypress","which","this","parents","submit","selectedrange","window","getSelection","getRangeAt","cloneContents","annotatedtext","ajax","url","success","response","JSON","parse","Object","values","annotation","newrange","createRange","setStart","setEnd","recreateAnnotations","mouseenter","addClass","mouseleave","error","alert"],"mappings":"0+CAyBoB,SAACA,KAAMC,mBAAoBC,cAEvCC,QAAS,EACTC,YAAcC,iBAkKTC,eAAeC,iBAEhBJ,QAAUI,aACVC,0BACAC,aACAN,QAAS,OACN,GAAIF,oBAAsBC,UAAYE,YAAYG,cAAcG,OAAQ,CAC3EF,0BACAC,aAEAN,OAASI,iBAELI,MAAQP,YAAYG,cAAcI,0BAEpC,mBAAqBJ,cAAcK,2BAEnC,oBAAsBD,MAAQ,iCAAiCE,IAAIT,YAAYG,cAAcO,oCAC7F,oBAAsBH,MAAQ,+BAA+BE,IAAIT,YAAYG,cAAcQ,kCAC3F,oBAAsBJ,MAAQ,gCAAgCE,IAAIT,YAAYG,cAAcS,mCAC5F,oBAAsBL,MAAQ,8BAA8BE,IAAIT,YAAYG,cAAcU,iCAE1F,oBAAsBN,MAAQ,+BAA+BE,IAAIN,kCAEjE,oBAAsBI,MAAQ,0BAA0BE,IAAIT,YAAYG,cAAcW,0BAEtF,oBAAsBP,MAAQ,WAAWE,IAAIT,YAAYG,cAAcY,0BAEvE,2BAA6BR,OAAOS,MAAK,mBAAE,sBAAwBb,cAAca,4BACjF,2BAA6BT,OAAOU,IAAI,eAAgB,IAAMjB,YAAYG,cAAce,2BAExF,mBAAqBX,MAAQ,qBAAqBY,aAAa,mBAAqBhB,kCACpF,mBAAqBI,MAAQ,qBAAqBa,2BAClD,mBAAqBb,MAAQ,aAAac,gCAE1C,mBAAqBlB,cAAckB,iBAOpChB,iCACH,oBAAoBG,2BAEpB,gDAAgDC,IAAI,0BAEpD,kDAAkDA,KAAK,uBACvD,gDAAgDA,KAAK,uBACrD,iDAAiDA,KAAK,uBACtD,+CAA+CA,KAAK,uBAEpD,2CAA2CA,IAAI,wBAE/C,mBAAmBa,IAAI,oBAAoBF,gBAMvChB,8BACAmB,WAAatB,MAAMuB,MAAK,mBAAE,QAAQ,GAAGC,iBAAiB,yBACzCC,IAAfH,YAAiD,GAArBA,WAAWI,iBAUrBJ,gBACjB,IAAIK,EAAI,EAAGA,EAAIL,WAAWI,OAAQC,OAC/BL,WAAWK,GAAGC,WAAY,KACtBC,GAAKP,WAAWK,GAAGC,WACjBE,SAAW9B,MAAMuB,KAAKD,WAAWK,GAAGI,YAC1CC,YAAYV,WAAWK,GAAIG,UAC3BD,GAAGI,aAfPC,CAAiBZ,qBA6BhBa,sBAAsBC,UACvBA,MAAMC,gBAIC,OAIPC,KAAOF,MAAMG,2BACbD,KAAKE,WAAaC,KAAKC,eAMvBJ,KAAOA,KAAKK,gBAEXL,WAGM,WAUPM,KAPEC,UAAY,GACZC,SACFR,KAAKS,cACPC,mBACEV,KACAW,WAAWC,WAGPN,KAAOE,SAASK,eACfC,cAAchB,MAAOQ,WAGtB/B,KAA4B+B,KAE5B/B,OAASuB,MAAMiB,gBAAkBjB,MAAMkB,YAAc,EAGrDzC,KAAK0C,UAAUnB,MAAMkB,cAIrBzC,OAASuB,MAAMoB,cAAgBpB,MAAMqB,UAAY5C,KAAK6C,KAAKhC,QAE3Db,KAAK0C,UAAUnB,MAAMqB,WAGzBZ,UAAUc,KAAK9C,cAGZgC,mBAaFe,eAAexB,WAAOlC,qEAAsB2D,gEAAW,YAAa5C,6DAAQ,SAE3E4B,UAAYV,sBAAsBC,OAIpC0B,cAAgB,GAChBC,SAAW,KACXC,YAAc,KAElBnB,UAAUoB,SAAQ,SAAArB,MACVmB,UAAYA,SAASG,cAAgBtB,KACrCoB,YAAYL,KAAKf,OAEjBoB,YAAc,CAACpB,MACfkB,cAAcH,KAAKK,cAEvBD,SAAWnB,YAMTuB,WAAa,QACnBL,cAAgBA,cAAcM,QAAO,SAAAC,aAEjCA,KAAKC,MAAK,SAAA1B,aAASuB,WAAWI,KAAK3B,KAAK4B,qBAIxCC,gBAAkB,UAEtBX,cAAcG,SAAQ,SAAAS,WACZC,YAAcC,SAASC,cAAc,QAC3CF,YAAYG,UAAYjB,SAEpB3D,eACAyE,YAAYG,WAAa,IAAMjB,SAAW,IAAM3D,aAEhDyE,YAAYI,MAAQ,sDAAwD9D,MAC5E0D,YAAYK,GAAKnB,SAAW,IAAM3D,aAClCyE,YAAYI,MAAME,gBAAkB,IAAMhE,OAG9CwD,iBAAmBC,MAAM,GAAGQ,YAE5BR,MAAM,GAAG9C,WAAWuD,aAAaR,YAAaD,MAAM,IACpDA,MAAMT,SAAQ,SAAArB,aAAQ+B,YAAYS,YAAYxC,YAI3C6B,yBAUFrB,cAAchB,MAAOQ,oDAEhBlB,6DAASkB,KAAK4B,4CAALa,gBAAgB3D,8DAAUkB,KAAKb,WAAWL,cAGrDU,MAAMkD,aAAa1C,KAAM,IAAM,GAE/BR,MAAMkD,aAAa1C,KAAMlB,SAAW,EAE1C,MAAO6D,UAGE,YA4CNC,eAAe5C,UACd6C,cAnCW7C,UACX8C,SAAW9C,KAAK8C,SAASC,cAC3BC,OAASF,eACI,UAAbA,WACAE,OAAS,UAENA,OA6BMC,CAAYjD,MACnBkD,aArBelD,cACjBkD,IAAM,EAENC,IAAMnD,KACHmD,KACCA,IAAIL,WAAa9C,KAAK8C,WACtBI,KAAO,GAEXC,IAAMA,IAAIC,uBAEPF,IAWKG,CAAgBrD,sBAClB6C,iBAAQK,kBAWbI,cAActD,KAAMN,cACrB6D,MAAQ,GAGRC,KAAOxD,KACJwD,OAAS9D,MAAM,KACb8D,WACK,IAAIC,MAAM,oCAEpBF,MAAQX,eAAeY,MAAQ,IAAMD,MACrCC,KAAOA,KAAKxE,kBAGhBuE,OADAA,MAAQ,IAAMA,OACAG,QAAQ,MAAO,aAcxBC,eAAeC,QAASd,SAAUe,OACvCf,SAAWA,SAASgB,sBAEhBC,YAAc,EACThF,EAAI,EAAGA,EAAI6E,QAAQ1E,SAASJ,OAAQC,IAAK,KACxCiF,MAAQJ,QAAQ1E,SAASH,MAC3BiF,MAAMlB,SAASgB,gBAAkBhB,YAC/BiB,aACiBF,aACRG,aAKZ,cAwBFC,oBAAoBV,MAAO7D,WAC2C,OAArD6D,MAAMW,MAAM,4CAExB,IAAIT,MAAM,wCAGdU,SAAWZ,MAAMa,MAAM,KACzBR,QAAUlE,KAIdyE,SAASE,uDAEWF,6DAAU,KAArBG,oBACDC,mBACAC,oBAEEC,aAAeH,QAAQI,QAAQ,SACf,IAAlBD,aAAqB,CACrBF,YAAcD,QAAQK,MAAM,EAAGF,kBAEzBG,SAAWN,QAAQK,MAAMF,aAAe,EAAGH,QAAQI,QAAQ,UACjEF,aAAeK,SAASD,UAAY,GACjB,SACR,UAGXL,YAAcD,QACdE,aAAe,MAGbR,MAAQL,eAAeC,QAASW,YAAaC,kBAC9CR,aACM,KAGXJ,QAAUI,gEAGPJ,iBAaFkB,cAAcvB,WAAO7D,4DAAOsC,SAAS+C,gBAE/Bd,oBAAoBV,MAAO7D,MACpC,MAAOsF,YACEhD,SAASiD,SACZ,IAAM1B,MACN7D,KAIA,KACAwF,YAAYC,wBACZ,MACFC,0BAYDhG,YAAYY,KAAMqF,kBACjBC,OAA8BtF,KAAKhB,WAEzCqG,aAAahE,SAAQ,SAAAkE,UAAKD,OAAOhH,aAAaiH,EAAGvF,SACjDA,KAAKwF,6BAjlBP,oBAAoB7H,2BAGpB,iCAAiC8H,YAAY,gCAC7C,iCAAiCA,YAAY,gCAC7C,mCAAmCA,YAAY,kCAC/C,4BAA4BA,YAAY,2BAGxCzD,UAAU0D,GAAG,QAAS,cAAc,SAAS/C,GAC3CA,EAAEgD,iBAEFpI,0BAEAC,aAEAN,QAAS,yBAIX,YAAY0I,UAAS,SAAUjD,GACd,IAAXA,EAAEkD,4BACAC,MAAMC,QAAQ,UAAUC,SAC1BrD,EAAEgD,yCAKR3D,UAAU0D,GAAG,UAAW,iBAAiB,eACnCO,cAAgBC,OAAOC,eAAeC,WAAW,MAEH,KAA9CH,cAAcI,gBAAgB/D,aAAsBtF,mBAAoB,CAExEO,0BAEAC,iBAEIE,MAAQoI,KAAK1D,GAAGsB,QAAQ,SAAU,wBAEpC,oBAAsBhG,MAAQ,iCAAiCE,IAC7D0F,cAAc2C,cAAcxF,eAAgBqF,2BAC9C,oBAAsBpI,MAAQ,+BAA+BE,IAC3D0F,cAAc2C,cAAcrF,aAAckF,2BAC5C,oBAAsBpI,MAAQ,gCAAgCE,IAAIqI,cAAcvF,iCAChF,oBAAsBhD,MAAQ,8BAA8BE,IAAIqI,cAAcpF,+BAE9E,oBAAsBnD,MAAQ,WAAWE,IAAI,OAE3C0I,cAAgBtF,eAAeiF,eAAe,EAAO,kBAEpC,IAAjBK,mCACE,2BAA6B5I,OAAOS,KAAKmI,mCAG7C,mBAAqB5I,MAAQ,qBAAqBa,2BAClD,oBAAsBb,MAAQ,aAAac,4BAKnD+H,KAAK,CACHC,IAAK,oBACL1F,KAAM,IAAO/D,oBAAwB,GACrC0J,QAAS,SAASC,UACdvJ,YAAcwJ,KAAKC,MAAMF,iDAoENG,OAAOC,OAAO3J,2CAAc,KAA1C4J,8BAGDC,SAAWhF,SAASiF,kBAGpBD,SAASE,SACLpC,cAAciC,WAAWlJ,gBAAgB,mBAAE,UAAYkJ,WAAWrJ,OAAO,IAAKqJ,WAAWhJ,eAC7FiJ,SAASG,OACLrC,cAAciC,WAAWjJ,cAAc,mBAAE,UAAYiJ,WAAWrJ,OAAO,IAAKqJ,WAAW/I,aAC7F,MAAO2E,QAIL2D,cAAgBtF,eAAegG,SAAUD,WAAW3E,GAAI,YAAa2E,WAAW1I,OAE/D,IAAjBiI,mCACE,sBAAwBS,WAAW3E,IAAIjE,KAAKmI,gBApFlDc,uBAGE,cAAcC,YAAW,eACnBjF,GAAK0D,KAAK1D,GAAGsB,QAAQ,aAAc,wBACrC,sBAAwBtB,IAAIkF,SAAS,+BACrC,cAAgBlF,IAAIkF,SAAS,+BAC7B,mBAAqBlF,GAAK,eAAekF,SAAS,kCAItD,cAAcC,YAAW,eACnBnF,GAAK0D,KAAK1D,GAAGsB,QAAQ,aAAc,wBACrC,sBAAwBtB,IAAIqD,YAAY,+BACxC,cAAgBrD,IAAIqD,YAAY,+BAChC,mBAAqBrD,GAAK,eAAeqD,YAAY,kCAIzD,yBAAyB4B,YAAW,eAC9BjF,GAAK0D,KAAK1D,GAAGsB,QAAQ,qBAAsB,wBAC7C,cAAgBtB,IAAIkF,SAAS,kCAGjC,yBAAyBC,YAAW,eAC9BnF,GAAK0D,KAAK1D,GAAGsB,QAAQ,qBAAsB,wBAC7C,cAAgBtB,IAAIqD,YAAY,kCAIpCzD,UAAU0D,GAAG,YAAa,mBAAmB,+BACzC,mBAAmB4B,SAAS,kCAGhCtF,UAAU0D,GAAG,aAAc,mBAAmB,+BAC1C,mBAAmBD,YAAY,kCAInCzD,UAAU0D,GAAG,QAAS,cAAc,WAElCrI,eADSyI,KAAK1D,GAAGsB,QAAQ,aAAc,4BAKzC1B,UAAU0D,GAAG,QAAS,oBAAoB,WAExCrI,eADSyI,KAAK1D,GAAGsB,QAAQ,mBAAoB,SAUrD8D,MAAO,WACHC,MAAO"}