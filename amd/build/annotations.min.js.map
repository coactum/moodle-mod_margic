{"version":3,"file":"annotations.min.js","sources":["../src/annotations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module for the annotation functions of the margic.\n *\n * @module     mod_margic/annotations\n * @copyright  2022 coactum GmbH\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport $ from 'jquery';\nimport {RangeAnchor, TextPositionAnchor, TextQuoteAnchor} from './types';\nimport {TextRange} from './text-range';\n\nexport const init = (cmid, canmakeannotations, myuserid) => {\n\n    var edited = false;\n    var annotations = Array();\n\n    var newannotation = false;\n\n    // Hide all Moodle forms.\n    $('.annotation-form').hide();\n\n    // Remove col-mds from moodle form.\n    $('.annotation-form div.col-md-3').removeClass('col-md-3');\n    $('.annotation-form div.col-md-9').removeClass('col-md-9');\n    $('.annotation-form div.form-group').removeClass('form-group');\n    $('.annotation-form div.row').removeClass('row');\n\n    // Onclick listener if form is canceled.\n    $(document).on('click', '#id_cancel', function(e) {\n        e.preventDefault();\n\n        removeAllTempHighlights(); // Remove other temporary highlights.\n\n        resetForms(); // Remove old form contents.\n\n        edited = false;\n    });\n\n    // Listen for return key pressed to submit annotation form.\n    $('textarea').keypress(function(e) {\n        if (e.which == 13) {\n            $(this).parents(':eq(2)').submit();\n            e.preventDefault();\n        }\n    });\n\n    // If user selects text for new annotation\n    $(document).on('mouseup', '.originaltext', function() {\n        var selectedrange = window.getSelection().getRangeAt(0);\n\n        if (selectedrange.cloneContents().textContent !== '' && canmakeannotations) {\n\n            // console.log('mouseup in originaltext');\n\n            removeAllTempHighlights(); // Remove other temporary highlights.\n\n            resetForms(); // Reset the annotation forms.\n\n            // Create new annotation.\n            newannotation = createAnnotation(this);\n\n            var entry = this.id.replace(/entry-/, '');\n\n            // RangeSelector.\n            $('.annotation-form-' + entry + ' input[name=\"startcontainer\"]').val(\n                newannotation.target[0].selector[0].startContainer);\n            $('.annotation-form-' + entry + ' input[name=\"endcontainer\"]').val(\n                newannotation.target[0].selector[0].endContainer);\n            $('.annotation-form-' + entry + ' input[name=\"startoffset\"]').val(\n                newannotation.target[0].selector[0].startOffset);\n            $('.annotation-form-' + entry + ' input[name=\"endoffset\"]').val(\n                newannotation.target[0].selector[0].endOffset);\n\n            // TextPositionSelector.\n            $('.annotation-form-' + entry + ' input[name=\"start\"]').val(\n                newannotation.target[0].selector[1].start);\n            $('.annotation-form-' + entry + ' input[name=\"end\"]').val(\n                newannotation.target[0].selector[1].end);\n\n            // TextQuoteSelector.\n            $('.annotation-form-' + entry + ' input[name=\"exact\"]').val(\n                newannotation.target[0].selector[2].exact);\n            $('.annotation-form-' + entry + ' input[name=\"prefix\"]').val(\n                newannotation.target[0].selector[2].prefix);\n            $('.annotation-form-' + entry + ' input[name=\"suffix\"]').val(\n                newannotation.target[0].selector[2].suffix);\n\n            $('.annotation-form-' + entry + ' select').val(1);\n\n            $('#annotationpreview-temp-' + entry).html(newannotation.target[0].selector[2].exact);\n\n            $('.annotationarea-' + entry + ' .annotation-form').show();\n            $('.annotation-form-' + entry + ' #id_text').focus();\n        }\n    });\n\n    // Fetch and recreate annotations.\n    $.ajax({\n        url: './annotations.php',\n        data: {'id': cmid, 'getannotations': 1},\n        success: function(response) {\n            annotations = JSON.parse(response);\n            recreateAnnotations();\n\n            // Highlight annotation and all annotated text if annotated text is hovered\n            $('.annotated').mouseenter(function() {\n                var id = this.id.replace('annotated-', '');\n                $('.annotation-box-' + id).addClass('hovered');\n                $('.annotated-' + id).addClass('hovered');\n            });\n\n            $('.annotated').mouseleave(function() {\n                var id = this.id.replace('annotated-', '');\n                $('.annotation-box-' + id).removeClass('hovered');\n                $('.annotated-' + id).removeClass('hovered');\n            });\n\n            // Highlight whole temp annotation if part of temp annotation is hovered\n            $(document).on('mouseover', '.annotated_temp', function() {\n                $('.annotated_temp').addClass('hovered');\n            });\n\n            $(document).on('mouseleave', '.annotated_temp', function() {\n                $('.annotated_temp').removeClass('hovered');\n            });\n\n            // Onclick listener for editing annotation.\n            $(document).on('click', '.annotated', function() {\n                var id = this.id.replace('annotated-', '');\n                editAnnotation(id);\n            });\n\n            // Onclick listener for editing annotation.\n            $(document).on('click', '.edit-annotation', function() {\n                var id = this.id.replace('edit-annotation-', '');\n                editAnnotation(id);\n            });\n\n            // Highlight annotation if hoverannotation button is hovered\n            $(document).on('mouseover', '.hoverannotation', function() {\n                var id = this.id.replace('hoverannotation-', '');\n                $('.annotated-' + id).addClass('hovered');\n            });\n\n            $(document).on('mouseleave', '.hoverannotation', function() {\n                var id = this.id.replace('hoverannotation-', '');\n                $('.annotated-' + id).removeClass('hovered');\n            });\n\n        },\n        error: function() {\n            alert ('Error fetiching annotations');\n        }\n    });\n\n    /**\n     * Recreate annotations.\n     *\n     */\n    function recreateAnnotations() {\n\n        for (let annotation of Object.values(annotations)) {\n\n            const rangeSelectors = [[\n                {type: \"RangeSelector\", startContainer: annotation.startcontainer, startOffset: annotation.startoffset,\n                endContainer: annotation.endcontainer, endOffset: annotation.endoffset},\n                {type: \"TextPositionSelector\", start: annotation.start, end: annotation.end},\n                {type: \"TextQuoteSelector\", exact: annotation.exact, prefix: annotation.prefix, suffix: annotation.suffix}\n            ]];\n\n            // console.log('rangeSelectors');\n            // console.log(rangeSelectors);\n\n            const target = rangeSelectors.map(selectors => ({\n                selector: selectors,\n            }));\n\n            // console.log('target');\n            // console.log(target);\n\n            /** @type {AnnotationData} */\n            const newannotation = {\n                annotation: annotation,\n                target: target,\n            };\n\n            // console.log(newannotation);\n\n            anchor(newannotation, $(\"#entry-\" + annotation.entry)[0]);\n\n            $('#annotationpreview-' + annotation.id).html(annotation.exact);\n        }\n    }\n\n    /**\n     * Edit annotation.\n     *\n     * @param {int} annotationid\n     */\n    function editAnnotation(annotationid) {\n\n        if (edited == annotationid) {\n            removeAllTempHighlights(); // Remove other temporary highlights.\n            resetForms(); // Remove old form contents.\n            edited = false;\n        } else if (canmakeannotations && myuserid == annotations[annotationid].userid) {\n            removeAllTempHighlights(); // Remove other temporary highlights.\n            resetForms(); // Remove old form contents.\n\n            edited = annotationid;\n\n            var entry = annotations[annotationid].entry;\n\n            $('.annotation-box-' + annotationid).hide(); // Hide edited annotation-box.\n\n            $('.annotation-form-' + entry + ' input[name=\"startcontainer\"]').val(annotations[annotationid].startcontainer);\n            $('.annotation-form-' + entry + ' input[name=\"endcontainer\"]').val(annotations[annotationid].endcontainer);\n            $('.annotation-form-' + entry + ' input[name=\"startoffset\"]').val(annotations[annotationid].startoffset);\n            $('.annotation-form-' + entry + ' input[name=\"endoffset\"]').val(annotations[annotationid].endoffset);\n            $('.annotation-form-' + entry + ' input[name=\"start\"]').val(annotations[annotationid].start);\n            $('.annotation-form-' + entry + ' input[name=\"end\"]').val(annotations[annotationid].end);\n            $('.annotation-form-' + entry + ' input[name=\"exact\"]').val(annotations[annotationid].exact);\n            $('.annotation-form-' + entry + ' input[name=\"prefix\"]').val(annotations[annotationid].prefix);\n            $('.annotation-form-' + entry + ' input[name=\"suffix\"]').val(annotations[annotationid].suffix);\n\n            $('.annotation-form-' + entry + ' input[name=\"annotationid\"]').val(annotationid);\n\n            $('.annotation-form-' + entry + ' textarea[name=\"text\"]').val(annotations[annotationid].text);\n\n            $('.annotation-form-' + entry + ' select').val(annotations[annotationid].type);\n\n            $('#annotationpreview-temp-' + entry).html($('#annotationpreview-' + annotationid).html());\n            $('#annotationpreview-temp-' + entry).css('border-color', '#' + annotations[annotationid].color);\n\n            $('.annotationarea-' + entry + ' .annotation-form').insertBefore('.annotation-box-' + annotationid);\n            $('.annotationarea-' + entry + ' .annotation-form').show();\n            $('.annotationarea-' + entry + ' #id_text').focus();\n        } else {\n            $('.annotation-box-' + annotationid).focus();\n        }\n    }\n\n    /**\n     * Reset all annotation forms\n     */\n    function resetForms() {\n        $('.annotation-form').hide();\n\n        $('.annotation-form input[name^=\"annotationid\"]').val(null);\n\n        $('.annotation-form input[name^=\"startcontainer\"]').val(-1);\n        $('.annotation-form input[name^=\"endcontainer\"]').val(-1);\n        $('.annotation-form input[name^=\"startoffset\"]').val(-1);\n        $('.annotation-form input[name^=\"endoffset\"]').val(-1);\n\n        $('.annotation-form textarea[name^=\"text\"]').val('');\n\n        $('.annotation-box').not('.annotation-form').show(); // To show again edited annotation.\n    }\n\n    /**\n     * Remove all temporary highlights under a given root element.\n     */\n     function removeAllTempHighlights() {\n        const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n        if (highlights !== undefined && highlights.length != 0) {\n            removeHighlights(highlights);\n        }\n    }\n\n    /**\n     * Remove highlights from a range previously highlighted with `highlightRange`.\n     *\n     * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n     */\n    function removeHighlights(highlights) {\n\n        // console.log('removeHighlights highlights');\n        // console.log(highlights);\n\n        for (var i = 0; i < highlights.length; i++) {\n            if (highlights[i].parentNode) {\n                var pn = highlights[i].parentNode;\n                const children = Array.from(highlights[i].childNodes);\n                replaceWith(highlights[i], children);\n                pn.normalize(); // To Be removed?\n            }\n        }\n    }\n\n    /**\n     * Get the node name for use in generating an xpath expression.\n     *\n     * @param {Node} node\n     * @return {string} - Name of the node\n     */\n    function getNodeName(node) {\n        const nodeName = node.nodeName.toLowerCase();\n        let result = nodeName;\n        if (nodeName === '#text') {\n            result = 'text()';\n        }\n        return result;\n    }\n\n    /**\n     * Get the index of the node as it appears in its parent's child list\n     *\n     * @param {Node} node\n     * @return {int} - Position of the node\n     */\n    function getNodePosition(node) {\n        let pos = 0;\n        /** @type {Node|null} */\n        let tmp = node;\n        while (tmp) {\n            if (tmp.nodeName === node.nodeName) {\n                pos += 1;\n            }\n            tmp = tmp.previousSibling;\n        }\n        return pos;\n    }\n\n    /**\n     * Get the path segments to the node\n     *\n     * @param {Node} node\n     * @return {array} - Path segments\n     */\n    function getPathSegment(node) {\n        const name = getNodeName(node);\n        const pos = getNodePosition(node);\n        return `${name}[${pos}]`;\n    }\n\n    /**\n     * A simple XPath generator which can generate XPaths of the form\n     * /tag[index]/tag[index].\n     *\n     * @param {Node} node - The node to generate a path to\n     * @param {Node} root - Root node to which the returned path is relative\n     * @return {string} - The xpath of a node\n     */\n    function xpathFromNode(node, root) {\n        let xpath = '';\n\n        /** @type {Node|null} */\n        let elem = node;\n        while (elem !== root) {\n            if (!elem) {\n                throw new Error('Node is not a descendant of root');\n            }\n            xpath = getPathSegment(elem) + '/' + xpath;\n            elem = elem.parentNode;\n        }\n        xpath = '/' + xpath;\n        xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n        return xpath;\n    }\n\n    /**\n     * Return the `index`'th immediate child of `element` whose tag name is\n     * `nodeName` (case insensitive).\n     *\n     * @param {Element} element\n     * @param {string} nodeName\n     * @param {number} index\n     * @return {Element|null} - The child element or null\n     */\n    function nthChildOfType(element, nodeName, index) {\n        nodeName = nodeName.toUpperCase();\n\n        let matchIndex = -1;\n        for (let i = 0; i < element.children.length; i++) {\n            const child = element.children[i];\n            if (child.nodeName.toUpperCase() === nodeName) {\n                ++matchIndex;\n                if (matchIndex === index) {\n                    return child;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Evaluate a _simple XPath_ relative to a `root` element and return the\n     * matching element.\n     *\n     * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n     *\n     * Unlike `document.evaluate` this function:\n     *\n     *  - Only supports simple XPaths\n     *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n     *  - Ignores element namespaces when matching element names in the XPath against\n     *    elements in the DOM tree\n     *  - Is case insensitive for all elements, not just HTML elements\n     *\n     * The matching element is returned or `null` if no such element is found.\n     * An error is thrown if `xpath` is not a simple XPath.\n     *\n     * @param {string} xpath\n     * @param {Element} root\n     * @return {Element|null}\n     */\n    function evaluateSimpleXPath(xpath, root) {\n        const isSimpleXPath = xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n        if (!isSimpleXPath) {\n            throw new Error('Expression is not a simple XPath');\n        }\n\n        const segments = xpath.split('/');\n        let element = root;\n\n        // Remove leading empty segment. The regex above validates that the XPath\n        // has at least two segments, with the first being empty and the others non-empty.\n        segments.shift();\n\n        for (let segment of segments) {\n            let elementName;\n            let elementIndex;\n\n            const separatorPos = segment.indexOf('[');\n            if (separatorPos !== -1) {\n                elementName = segment.slice(0, separatorPos);\n\n                const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n                elementIndex = parseInt(indexStr) - 1;\n                if (elementIndex < 0) {\n                    return null;\n                }\n            } else {\n                elementName = segment;\n                elementIndex = 0;\n            }\n\n            const child = nthChildOfType(element, elementName, elementIndex);\n            if (!child) {\n                return null;\n            }\n\n            element = child;\n        }\n\n        return element;\n    }\n\n    /**\n     * Finds an element node using an XPath relative to `root`\n     *\n     * Example:\n     *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n     *\n     * @param {string} xpath\n     * @param {Element} [root]\n     * @return {Node|null}\n     */\n    // function nodeFromXPath(xpath, root = document.body) {\n    //     try {\n    //         return evaluateSimpleXPath(xpath, root);\n    //     } catch (err) {\n    //         return document.evaluate(\n    //             '.' + xpath,\n    //             root,\n\n    //             // The `namespaceResolver` and `result` arguments are optional in the spec\n    //             // but required in Edge Legacy.\n    //             null /* NamespaceResolver */,\n    //             XPathResult.FIRST_ORDERED_NODE_TYPE,\n    //             null /* Result */\n    //         ).singleNodeValue;\n    //     }\n    // }\n\n    /**\n     * Replace a child `node` with `replacements`.\n     *\n     * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n     *\n     * @param {ChildNode} node\n     * @param {Node[]} replacements\n     */\n    function replaceWith(node, replacements) {\n        const parent = /** @type {Node} */ (node.parentNode);\n\n        replacements.forEach(r => parent.insertBefore(r, node));\n        node.remove();\n    }\n\n};\n\n/**\n * Create a new annotation that is associated with the selected region of\n * the current document.\n *\n * @param {object} root - The root element\n * @return {object} - The new annotation\n */\nfunction createAnnotation(root) {\n    // console.log('createAnnotation');\n\n    const ranges = [window.getSelection().getRangeAt(0)];\n\n    // console.log('ranges');\n    // console.log(ranges);\n\n    if (ranges.collapsed) {\n        return null;\n    }\n\n    //const info = await this.getDocumentInfo();\n    const rangeSelectors = ranges.map(range => describe(root, range));\n\n    // console.log('rangeSelectors');\n    // console.log(rangeSelectors);\n\n    const target = rangeSelectors.map(selectors => ({\n      selector: selectors,\n    }));\n\n    // console.log('target');\n    // console.log(target);\n\n    /** @type {AnnotationData} */\n    const annotation = {\n      target,\n    };\n\n    // console.log('TARGET INFORMATION TO SAVE IN THE DB');\n    // console.log(annotation);\n\n    temp = anchor(annotation, root);\n\n    // console.log('TEMP');\n    // console.log(temp);\n\n    return annotation;\n}\n\n/**\n * Get anchors for new annnotation.\n *\n * @param {Element} root\n * @param {Range} range\n * @return {object} - Array with the anchors.\n */\nexport function describe(root, range) {\n    const types = [RangeAnchor, TextPositionAnchor, TextQuoteAnchor];\n    const result = [];\n\n    // console.log('describe');\n\n    for (let type of types) {\n      try {\n        const anchor = type.fromRange(root, range);\n\n        // console.log('type');\n        // console.log(type);\n        // console.log('anchor');\n        // console.log(anchor);\n\n        result.push(anchor.toSelector());\n      } catch (error) {\n        continue;\n      }\n    }\n    return result;\n}\n\n// Anchoring\n\n/**\n   * Anchor an annotation's selectors in the document.\n   *\n   * _Anchoring_ resolves a set of selectors to a concrete region of the document\n   * which is then highlighted.\n   *\n   * Any existing anchors associated with `annotation` will be removed before\n   * re-anchoring the annotation.\n   *\n   * @param {AnnotationData} annotation\n   * @return {obj} achor object\n   */\n function anchor(annotation, root) {\n    // console.log('anchor');\n    // console.log('annotation');\n    // console.log(annotation);\n\n    /**\n     * Resolve an annotation's selectors to a concrete range.\n     *\n     * @param {Target} target\n     * @return {obj}\n     */\n    const locate = target => {\n\n        // console.log('anchor -> locate');\n        // console.log('target');\n        // console.log(target);\n\n      // Only annotations with an associated quote can currently be anchored.\n      // This is because the quote is used to verify anchoring with other selector\n      // types.\n      if (\n        !target.selector ||\n        !target.selector.some(s => s.type === 'TextQuoteSelector')\n      ) {\n        return { annotation, target };\n      }\n\n      /** @type {Anchor} */\n      let anchor;\n      try {\n        const range = htmlAnchor(root, target.selector);\n        // Convert the `Range` to a `TextRange` which can be converted back to\n        // a `Range` later. The `TextRange` representation allows for highlights\n        // to be inserted during anchoring other annotations without \"breaking\"\n        // this anchor.\n        // console.log('anchor -> locate -> after htmlAnchor');\n        // console.log('result of htmlAnchor');\n        // console.log(range);\n        const textRange = TextRange.fromRange(range);\n        // console.log('range for anchor');\n        // console.log('textRange');\n        // console.log(textRange);\n\n        anchor = { annotation, target, range: textRange };\n\n        // console.log('anchor found');\n        // console.log(anchor);\n      } catch (err) {\n        // console.log('error in try to find textrange');\n        // console.log(err);\n        anchor = { annotation, target };\n      }\n\n    //   console.log('anchor at the end of anchor -> locate');\n    //   console.log(anchor);\n      return anchor;\n    };\n\n    /**\n     * Highlight the text range that `anchor` refers to.\n     *\n     * @param {Anchor} anchor\n     */\n    const highlight = anchor => {\n        // console.log('highlight');\n        // console.log('highlight resolveAnchor');\n      const range = resolveAnchor(anchor);\n    //   console.log('range');\n    //   console.log(range);\n\n      if (!range) {\n        // console.log('no range');\n        return;\n      }\n\n    //   console.log('highlight after resolveAnchor');\n    //   console.log('range');\n    //   console.log(range);\n\n    //   console.log('annotation');\n    //   console.log(annotation);\n\n      let highlights = [];\n\n      if (annotation.annotation) {\n        highlights = highlightRange(range, annotation.annotation.id, 'annotated', annotation.annotation.color);\n      } else {\n        highlights = highlightRange(range, false, 'annotated_temp');\n      }\n\n    //   console.log('highlights after i should have highlighted range');\n    //   console.log(highlights);\n\n      highlights.forEach(h => {\n        h._annotation = anchor.annotation;\n      });\n      anchor.highlights = highlights;\n\n    //   if (this._focusedAnnotations.has(anchor.annotation.$tag)) {\n    //     setHighlightsFocused(highlights, true);\n    //   }\n    };\n\n    // Remove existing anchors for this annotation.\n    // this.detach(annotation, false /* notify */); // To be replaced by own method\n\n    // Resolve selectors to ranges and insert highlights.\n    if (!annotation.target) {\n      annotation.target = [];\n    }\n    const anchors = annotation.target.map(locate);\n    // console.log('anchors after locate');\n    // console.log(anchors);\n\n    for (let anchor of anchors) {\n        // console.log('before highlighting anchor');\n        // console.log('anchor');\n        // console.log(anchor);\n        highlight(anchor);\n        // console.log('after highlighting anchor');\n    }\n\n    // Set flag indicating whether anchoring succeeded. For each target,\n    // anchoring is successful either if there are no selectors (ie. this is a\n    // Page Note) or we successfully resolved the selectors to a range.\n    annotation.$orphan =\n      anchors.length > 0 &&\n      anchors.every(anchor => anchor.target.selector && !anchor.range);\n\n    // console.log('anchor ends');\n    // console.log('anchors');\n    // console.log(anchors);\n    return anchors;\n  }\n\n/**\n * Resolve an anchor's associated document region to a concrete `Range`.\n *\n * This may fail if anchoring failed or if the document has been mutated since\n * the anchor was created in a way that invalidates the anchor.\n *\n * @param {Anchor} anchor\n * @return {Range|null}\n */\nfunction resolveAnchor(anchor) {\n    // console.log('resolveAnchor');\n    // console.log('anchor');\n    // console.log(anchor);\n\n    if (!anchor.range) {\n      return null;\n    }\n    try {\n      return anchor.range.toRange();\n    } catch {\n      return null;\n    }\n}\n\n\n    /**\n     * Wraps the DOM Nodes within the provided range with a highlight\n     * element of the specified class and returns the highlight Elements.\n     *\n     * @param {Range} range - Range to be highlighted\n     * @param {int} annotationid - ID of annotation\n     * @param {string} cssClass - A CSS class to use for the highlight\n     * @param {string} color - Color of the highlighting\n     * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n     */\n     function highlightRange(range, annotationid = false, cssClass = 'annotated', color = 'FFFF00') {\n        // console.log('highlightRange');\n        // console.log('range');\n        // console.log(range);\n\n        const textNodes = wholeTextNodesInRange(range);\n\n        // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n        // adjacent, we only need to create one highlight element for the group.\n        let textNodeSpans = [];\n        let prevNode = null;\n        let currentSpan = null;\n\n        textNodes.forEach(node => {\n            if (prevNode && prevNode.nextSibling === node) {\n                currentSpan.push(node);\n            } else {\n                currentSpan = [node];\n                textNodeSpans.push(currentSpan);\n            }\n            prevNode = node;\n        });\n\n        // Filter out text node spans that consist only of white space. This avoids\n        // inserting highlight elements in places that can only contain a restricted\n        // subset of nodes such as table rows and lists.\n        const whitespace = /^\\s*$/;\n        textNodeSpans = textNodeSpans.filter(span =>\n            // Check for at least one text node with non-space content.\n            span.some(node => !whitespace.test(node.nodeValue))\n        );\n\n        // Wrap each text node span with a `<span>` element.\n        const highlights = /** @type {HighlightElement[]} */ ([]);\n\n        textNodeSpans.forEach(nodes => {\n            const highlightEl = document.createElement('margic-highlight');\n            highlightEl.className = cssClass;\n\n            if (annotationid) {\n                highlightEl.className += ' ' + cssClass + '-' + annotationid;\n                highlightEl.style = \"text-decoration:underline; text-decoration-color: #\" + color;\n                highlightEl.id = cssClass + '-' + annotationid;\n                highlightEl.style.backgroundColor = '#' + color;\n            }\n\n            const parent = /** @type {Node} */ (nodes[0].parentNode);\n            parent.replaceChild(highlightEl, nodes[0]);\n            nodes.forEach(node => highlightEl.appendChild(node));\n\n            highlights.push(highlightEl);\n\n        });\n\n        return highlights;\n    }\n\n    /**\n    * Return text nodes which are entirely inside `range`.\n    *\n    * If a range starts or ends part-way through a text node, the node is split\n    * and the part inside the range is returned.\n    *\n    * @param {Range} range\n    * @return {Text[]}\n    */\n   function wholeTextNodesInRange(range) {\n       if (range.collapsed) {\n           // Exit early for an empty range to avoid an edge case that breaks the algorithm\n           // below. Splitting a text node at the start of an empty range can leave the\n           // range ending in the left part rather than the right part.\n           return [];\n       }\n\n       /** @type {Node|null} */\n       let root = range.commonAncestorContainer;\n       if (root.nodeType !== Node.ELEMENT_NODE) {\n           // If the common ancestor is not an element, set it to the parent element to\n           // ensure that the loop below visits any text nodes generated by splitting\n           // the common ancestor.\n           //\n           // Note that `parentElement` may be `null`.\n           root = root.parentElement;\n       }\n       if (!root) {\n           // If there is no root element then we won't be able to insert highlights,\n           // so exit here.\n           return [];\n       }\n\n       const textNodes = [];\n       const nodeIter = /** @type {Document} */ (\n           root.ownerDocument\n       ).createNodeIterator(\n           root,\n           NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n       );\n       let node;\n       while ((node = nodeIter.nextNode())) {\n           if (!isNodeInRange(range, node)) {\n               continue;\n           }\n           let text = /** @type {Text} */ (node);\n\n           if (text === range.startContainer && range.startOffset > 0) {\n               // Split `text` where the range starts. The split will create a new `Text`\n               // node which will be in the range and will be visited in the next loop iteration.\n               text.splitText(range.startOffset);\n               continue;\n           }\n\n           if (text === range.endContainer && range.endOffset < text.data.length) {\n               // Split `text` where the range ends, leaving it as the part in the range.\n               text.splitText(range.endOffset);\n           }\n\n           textNodes.push(text);\n       }\n\n       return textNodes;\n   }\n\n   /**\n    * Returns true if any part of `node` lies within `range`.\n    *\n    * @param {Range} range\n    * @param {Node} node\n    * @return {bool} - If node is in range\n    */\n   function isNodeInRange(range, node) {\n       try {\n           const length = node.nodeValue?.length ?? node.childNodes.length;\n           return (\n               // Check start of node is before end of range.\n               range.comparePoint(node, 0) <= 0 &&\n               // Check end of node is after start of range.\n               range.comparePoint(node, length) >= 0\n           );\n       } catch (e) {\n           // `comparePoint` may fail if the `range` and `node` do not share a common\n           // ancestor or `node` is a doctype.\n           return false;\n       }\n   }\n\n/**\n * @param {RangeAnchor|TextPositionAnchor|TextQuoteAnchor} anchor\n * @param {Object} [options]\n * @return {obj} - range\n */\n function querySelector(anchor, options = {}) {\n    // console.log('querySelector');\n    // console.log('anchor');\n    // console.log(anchor);\n    // console.log('options');\n    // console.log(options);\n\n    return anchor.toRange(options);\n  }\n\n  /**\n   * Anchor a set of selectors.\n   *\n   * This function converts a set of selectors into a document range.\n   * It encapsulates the core anchoring algorithm, using the selectors alone or\n   * in combination to establish the best anchor within the document.\n   *\n   * @param {Element} root - The root element of the anchoring context.\n   * @param {Selector[]} selectors - The selectors to try.\n   * @param {Object} [options]\n   * @return {object} the query selector\n   */\n  function htmlAnchor(root, selectors, options = {}) {\n    let position = null;\n    let quote = null;\n    let range = null;\n\n    // console.log('htmlAnchor()');\n\n    // Collect all the selectors\n    for (let selector of selectors) {\n      switch (selector.type) {\n        case 'TextPositionSelector':\n          position = selector;\n          options.hint = position.start; // TextQuoteAnchor hint\n          break;\n        case 'TextQuoteSelector':\n          quote = selector;\n          break;\n        case 'RangeSelector':\n          range = selector;\n          break;\n      }\n    }\n\n    /**\n     * Assert the quote matches the stored quote, if applicable\n     * @param {Range} range\n     * @return {Range} range\n     */\n    const maybeAssertQuote = range => {\n        // console.log('maybeAssertQuote');\n        // console.log('range');\n        // console.log(range);\n        // console.log('quote');\n        // console.log(quote);\n      if (quote?.exact && range.toString() !== quote.exact) {\n        throw new Error('quote mismatch');\n      } else {\n        // console.log('range found!');\n        // console.log(range);\n        return range;\n      }\n    };\n\n    let queryselector = false;\n    if (range) {\n        // console.log('range');\n\n      let anchor = RangeAnchor.fromSelector(root, range);\n\n    //   console.log('anchor');\n    //   console.log(anchor);\n\n      queryselector = querySelector(anchor, options);\n\n      if (queryselector) {\n\n        // console.log('htmlAnchor queryselector for RangeAnchor');\n        // console.log(queryselector);\n\n        return queryselector;\n      } else {\n        return maybeAssertQuote;\n      }\n    }\n\n    if (position) {\n        // console.log('position');\n\n        let anchor = TextPositionAnchor.fromSelector(root, position);\n\n        queryselector = querySelector(anchor, options);\n        if (queryselector) {\n\n            // console.log('htmlAnchor queryselector for TextPositionAnchor');\n            // console.log(queryselector);\n            return queryselector;\n          } else {\n            return maybeAssertQuote;\n          }\n    }\n\n    if (quote) {\n        // console.log('quote');\n        // console.log('htmlAnchor queryselector for TextQuoteAnchor');\n\n        let anchor = TextQuoteAnchor.fromSelector(root, quote);\n\n        queryselector = querySelector(anchor, options);\n\n        // console.log(queryselector);\n\n        return queryselector;\n    }\n\n    return false;\n  }"],"names":["describe","root","range","result","RangeAnchor","TextPositionAnchor","TextQuoteAnchor","type","anchor","fromRange","push","toSelector","error","annotation","highlight","toRange","resolveAnchor","highlights","highlightRange","id","color","forEach","h","_annotation","target","anchors","map","selector","some","s","selectors","options","position","quote","hint","start","maybeAssertQuote","exact","toString","Error","querySelector","fromSelector","htmlAnchor","textRange","TextRange","err","$orphan","length","every","annotationid","cssClass","textNodes","wholeTextNodesInRange","textNodeSpans","prevNode","currentSpan","node","nextSibling","whitespace","filter","span","test","nodeValue","nodes","highlightEl","document","createElement","className","style","backgroundColor","parentNode","replaceChild","appendChild","collapsed","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","nextNode","isNodeInRange","text","startContainer","startOffset","splitText","endContainer","endOffset","data","_node$nodeValue","childNodes","comparePoint","e","cmid","canmakeannotations","myuserid","edited","annotations","Array","newannotation","editAnnotation","removeAllTempHighlights","resetForms","userid","entry","hide","val","startcontainer","endcontainer","startoffset","endoffset","end","prefix","suffix","html","css","insertBefore","show","focus","not","from","querySelectorAll","undefined","i","pn","children","replaceWith","normalize","removeHighlights","replacements","parent","r","remove","removeClass","on","preventDefault","keypress","which","this","parents","submit","window","getSelection","getRangeAt","cloneContents","textContent","ranges","temp","createAnnotation","replace","ajax","url","success","response","JSON","parse","Object","values","recreateAnnotations","mouseenter","addClass","mouseleave","alert"],"mappings":"4iDAsjBgBA,SAASC,KAAMC,eAErBC,OAAS,gBADD,CAACC,oBAAaC,2BAAoBC,iDAKxB,KAAfC,yBAECC,QAASD,KAAKE,UAAUR,KAAMC,OAOpCC,OAAOO,KAAKF,QAAOG,cACnB,MAAOC,wBAIJT,gBAiBDK,OAAOK,WAAYZ,UA+DnBa,UAAY,SAAAN,YAGVN,eA8EWM,YAKdA,OAAON,aACH,gBAGAM,OAAON,MAAMa,UACpB,sBACO,MAzFOC,CAAcR,WAIvBN,WAYDe,WAAa,IAGfA,WADEJ,WAAWA,WACAK,eAAehB,MAAOW,WAAWA,WAAWM,GAAI,YAAaN,WAAWA,WAAWO,OAEnFF,eAAehB,OAAO,EAAO,mBAMjCmB,SAAQ,SAAAC,GACjBA,EAAEC,YAAcf,OAAOK,cAEzBL,OAAOS,WAAaA,aAWjBJ,WAAWW,SACdX,WAAWW,OAAS,eAEhBC,QAAUZ,WAAWW,OAAOE,KAnGnB,SAAAF,YAUVA,OAAOG,WACPH,OAAOG,SAASC,MAAK,SAAAC,SAAgB,sBAAXA,EAAEtB,cAEtB,CAAEM,WAAAA,WAAYW,OAAAA,YAInBhB,eAEIN,eAwTQD,KAAM6B,sBAAWC,+DAAU,GACzCC,SAAW,KACXC,MAAQ,KACR/B,MAAQ,2CAKS4B,iEAAW,KAAvBH,6BACCA,SAASpB,UACV,uBACHyB,SAAWL,SACXI,QAAQG,KAAOF,SAASG,gBAErB,oBACHF,MAAQN,mBAEL,gBACHzB,MAAQyB,mEAURS,iBAAmB,SAAAlC,oCAMnB+B,gCAAOI,OAASnC,MAAMoC,aAAeL,MAAMI,YACvC,IAAIE,MAAM,yBAITrC,UAKPA,MAAO,QAQOsC,cALHpC,oBAAYqC,aAAaxC,KAAMC,OAKN6B,UAS7BK,oBAIPJ,SAAU,QAKMQ,cAFHnC,2BAAmBoC,aAAaxC,KAAM+B,UAEbD,UAO3BK,oBAIXH,MAAO,QAMSO,cAFHlC,wBAAgBmC,aAAaxC,KAAMgC,OAEVF,gBAOnC,EAtZWW,CAAWzC,KAAMuB,OAAOG,UAQhCgB,UAAYC,qBAAUnC,UAAUP,OAKtCM,OAAS,CAAEK,WAAAA,WAAYW,OAAAA,OAAQtB,MAAOyC,WAItC,MAAOE,KAGPrC,OAAS,CAAEK,WAAAA,WAAYW,OAAAA,eAKlBhB,gDA2DUiB,+DAAS,CAIxBX,oFAOJD,WAAWiC,QACTrB,QAAQsB,OAAS,GACjBtB,QAAQuB,OAAM,SAAAxC,eAAUA,OAAOgB,OAAOG,WAAanB,OAAON,SAKrDuB,iBAsCGP,eAAehB,WAAO+C,qEAAsBC,gEAAW,YAAa9B,6DAAQ,SAK5E+B,UAAYC,sBAAsBlD,OAIpCmD,cAAgB,GAChBC,SAAW,KACXC,YAAc,KAElBJ,UAAU9B,SAAQ,SAAAmC,MACVF,UAAYA,SAASG,cAAgBD,KACrCD,YAAY7C,KAAK8C,OAEjBD,YAAc,CAACC,MACfH,cAAc3C,KAAK6C,cAEvBD,SAAWE,YAMTE,WAAa,QACnBL,cAAgBA,cAAcM,QAAO,SAAAC,aAEjCA,KAAKhC,MAAK,SAAA4B,aAASE,WAAWG,KAAKL,KAAKM,qBAItC7C,WAAgD,UAEtDoC,cAAchC,SAAQ,SAAA0C,WACZC,YAAcC,SAASC,cAAc,oBAC3CF,YAAYG,UAAYjB,SAEpBD,eACAe,YAAYG,WAAa,IAAMjB,SAAW,IAAMD,aAChDe,YAAYI,MAAQ,sDAAwDhD,MAC5E4C,YAAY7C,GAAK+B,SAAW,IAAMD,aAClCe,YAAYI,MAAMC,gBAAkB,IAAMjD,OAGV2C,MAAM,GAAGO,WACtCC,aAAaP,YAAaD,MAAM,IACvCA,MAAM1C,SAAQ,SAAAmC,aAAQQ,YAAYQ,YAAYhB,SAE9CvC,WAAWP,KAAKsD,gBAIb/C,oBAYHmC,sBAAsBlD,UACvBA,MAAMuE,gBAIC,OAIPxE,KAAOC,MAAMwE,2BACbzE,KAAK0E,WAAaC,KAAKC,eAMvB5E,KAAOA,KAAK6E,gBAEX7E,WAGM,WAUPuD,KAPEL,UAAY,GACZ4B,SACF9E,KAAK+E,cACPC,mBACEhF,KACAiF,WAAWC,WAGP3B,KAAOuB,SAASK,eACfC,cAAcnF,MAAOsD,WAGtB8B,KAA4B9B,KAE5B8B,OAASpF,MAAMqF,gBAAkBrF,MAAMsF,YAAc,EAGrDF,KAAKG,UAAUvF,MAAMsF,cAIrBF,OAASpF,MAAMwF,cAAgBxF,MAAMyF,UAAYL,KAAKM,KAAK7C,QAE3DuC,KAAKG,UAAUvF,MAAMyF,WAGzBxC,UAAUzC,KAAK4E,cAGZnC,mBAUFkC,cAAcnF,MAAOsD,oDAEhBT,6DAASS,KAAKM,4CAAL+B,gBAAgB9C,8DAAUS,KAAKsC,WAAW/C,cAGrD7C,MAAM6F,aAAavC,KAAM,IAAM,GAE/BtD,MAAM6F,aAAavC,KAAMT,SAAW,EAE1C,MAAOiD,UAGE,YASRxD,cAAchC,YAAQuB,+DAAU,UAO/BvB,OAAOO,QAAQgB,uBAv4BN,SAACkE,KAAMC,mBAAoBC,cAEvCC,QAAS,EACTC,YAAcC,QAEdC,eAAgB,WAuLXC,eAAevD,iBAEhBmD,QAAUnD,aACVwD,0BACAC,aACAN,QAAS,OACN,GAAIF,oBAAsBC,UAAYE,YAAYpD,cAAc0D,OAAQ,CAC3EF,0BACAC,aAEAN,OAASnD,iBAEL2D,MAAQP,YAAYpD,cAAc2D,0BAEpC,mBAAqB3D,cAAc4D,2BAEnC,oBAAsBD,MAAQ,iCAAiCE,IAAIT,YAAYpD,cAAc8D,oCAC7F,oBAAsBH,MAAQ,+BAA+BE,IAAIT,YAAYpD,cAAc+D,kCAC3F,oBAAsBJ,MAAQ,8BAA8BE,IAAIT,YAAYpD,cAAcgE,iCAC1F,oBAAsBL,MAAQ,4BAA4BE,IAAIT,YAAYpD,cAAciE,+BACxF,oBAAsBN,MAAQ,wBAAwBE,IAAIT,YAAYpD,cAAcd,2BACpF,oBAAsByE,MAAQ,sBAAsBE,IAAIT,YAAYpD,cAAckE,yBAClF,oBAAsBP,MAAQ,wBAAwBE,IAAIT,YAAYpD,cAAcZ,2BACpF,oBAAsBuE,MAAQ,yBAAyBE,IAAIT,YAAYpD,cAAcmE,4BACrF,oBAAsBR,MAAQ,yBAAyBE,IAAIT,YAAYpD,cAAcoE,4BAErF,oBAAsBT,MAAQ,+BAA+BE,IAAI7D,kCAEjE,oBAAsB2D,MAAQ,0BAA0BE,IAAIT,YAAYpD,cAAcqC,0BAEtF,oBAAsBsB,MAAQ,WAAWE,IAAIT,YAAYpD,cAAc1C,0BAEvE,2BAA6BqG,OAAOU,MAAK,mBAAE,sBAAwBrE,cAAcqE,4BACjF,2BAA6BV,OAAOW,IAAI,eAAgB,IAAMlB,YAAYpD,cAAc7B,2BAExF,mBAAqBwF,MAAQ,qBAAqBY,aAAa,mBAAqBvE,kCACpF,mBAAqB2D,MAAQ,qBAAqBa,2BAClD,mBAAqBb,MAAQ,aAAac,gCAE1C,mBAAqBzE,cAAcyE,iBAOpChB,iCACH,oBAAoBG,2BAEpB,gDAAgDC,IAAI,0BAEpD,kDAAkDA,KAAK,uBACvD,gDAAgDA,KAAK,uBACrD,+CAA+CA,KAAK,uBACpD,6CAA6CA,KAAK,uBAElD,2CAA2CA,IAAI,wBAE/C,mBAAmBa,IAAI,oBAAoBF,gBAMvChB,8BACAxF,WAAaqF,MAAMsB,MAAK,mBAAE,QAAQ,GAAGC,iBAAiB,yBACzCC,IAAf7G,YAAiD,GAArBA,WAAW8B,iBAUrB9B,gBAKjB,IAAI8G,EAAI,EAAGA,EAAI9G,WAAW8B,OAAQgF,OAC/B9G,WAAW8G,GAAGzD,WAAY,KACtB0D,GAAK/G,WAAW8G,GAAGzD,WACjB2D,SAAW3B,MAAMsB,KAAK3G,WAAW8G,GAAGjC,YAC1CoC,YAAYjH,WAAW8G,GAAIE,UAC3BD,GAAGG,aAnBPC,CAAiBnH,qBA4NhBiH,YAAY1E,KAAM6E,kBACjBC,OAA8B9E,KAAKc,WAEzC+D,aAAahH,SAAQ,SAAAkH,UAAKD,OAAOd,aAAae,EAAG/E,SACjDA,KAAKgF,6BAvdP,oBAAoB3B,2BAGpB,iCAAiC4B,YAAY,gCAC7C,iCAAiCA,YAAY,gCAC7C,mCAAmCA,YAAY,kCAC/C,4BAA4BA,YAAY,2BAGxCxE,UAAUyE,GAAG,QAAS,cAAc,SAAS1C,GAC3CA,EAAE2C,iBAEFlC,0BAEAC,aAEAN,QAAS,yBAIX,YAAYwC,UAAS,SAAS5C,GACb,IAAXA,EAAE6C,4BACAC,MAAMC,QAAQ,UAAUC,SAC1BhD,EAAE2C,yCAKR1E,UAAUyE,GAAG,UAAW,iBAAiB,cAGW,KAF9BO,OAAOC,eAAeC,WAAW,GAEnCC,gBAAgBC,aAAsBnD,mBAAoB,CAIxEO,0BAEAC,aAGAH,uBA2bctG,UAGhBqJ,OAAS,CAACL,OAAOC,eAAeC,WAAW,OAK7CG,OAAO7E,iBACA,SAiBL5D,WAAa,CACjBW,OAdqB8H,OAAO5H,KAAI,SAAAxB,cAASF,SAASC,KAAMC,UAK5BwB,KAAI,SAAAI,iBAAc,CAC9CH,SAAUG,sBAcZyH,KAAO/I,OAAOK,WAAYZ,MAKnBY,WAjeiB2I,CAAiBV,UAE7BlC,MAAQkC,KAAK3H,GAAGsI,QAAQ,SAAU,wBAGpC,oBAAsB7C,MAAQ,iCAAiCE,IAC7DP,cAAc/E,OAAO,GAAGG,SAAS,GAAG4D,oCACtC,oBAAsBqB,MAAQ,+BAA+BE,IAC3DP,cAAc/E,OAAO,GAAGG,SAAS,GAAG+D,kCACtC,oBAAsBkB,MAAQ,8BAA8BE,IAC1DP,cAAc/E,OAAO,GAAGG,SAAS,GAAG6D,iCACtC,oBAAsBoB,MAAQ,4BAA4BE,IACxDP,cAAc/E,OAAO,GAAGG,SAAS,GAAGgE,+BAGtC,oBAAsBiB,MAAQ,wBAAwBE,IACpDP,cAAc/E,OAAO,GAAGG,SAAS,GAAGQ,2BACtC,oBAAsByE,MAAQ,sBAAsBE,IAClDP,cAAc/E,OAAO,GAAGG,SAAS,GAAGwF,yBAGtC,oBAAsBP,MAAQ,wBAAwBE,IACpDP,cAAc/E,OAAO,GAAGG,SAAS,GAAGU,2BACtC,oBAAsBuE,MAAQ,yBAAyBE,IACrDP,cAAc/E,OAAO,GAAGG,SAAS,GAAGyF,4BACtC,oBAAsBR,MAAQ,yBAAyBE,IACrDP,cAAc/E,OAAO,GAAGG,SAAS,GAAG0F,4BAEtC,oBAAsBT,MAAQ,WAAWE,IAAI,uBAE7C,2BAA6BF,OAAOU,KAAKf,cAAc/E,OAAO,GAAGG,SAAS,GAAGU,2BAE7E,mBAAqBuE,MAAQ,qBAAqBa,2BAClD,oBAAsBb,MAAQ,aAAac,4BAKnDgC,KAAK,CACHC,IAAK,oBACL/D,KAAM,IAAOK,oBAAwB,GACrC2D,QAAS,SAASC,UACdxD,YAAcyD,KAAKC,MAAMF,iDA4DNG,OAAOC,OAAO5D,2CAAc,KAA1CxF,8BA2BLL,OAPsB,CAClBK,WAAYA,WACZW,OApBmB,CAAC,CACpB,CAACjB,KAAM,gBAAiBgF,eAAgB1E,WAAWkG,eAAgBvB,YAAa3E,WAAWoG,YAC3FvB,aAAc7E,WAAWmG,aAAcrB,UAAW9E,WAAWqG,WAC7D,CAAC3G,KAAM,uBAAwB4B,MAAOtB,WAAWsB,MAAOgF,IAAKtG,WAAWsG,KACxE,CAAC5G,KAAM,oBAAqB8B,MAAOxB,WAAWwB,MAAO+E,OAAQvG,WAAWuG,OAAQC,OAAQxG,WAAWwG,UAMzE3F,KAAI,SAAAI,iBAAc,CAC5CH,SAAUG,gBAcQ,mBAAE,UAAYjB,WAAW+F,OAAO,wBAEpD,sBAAwB/F,WAAWM,IAAImG,KAAKzG,WAAWwB,QAxFzD6H,uBAGE,cAAcC,YAAW,eACnBhJ,GAAK2H,KAAK3H,GAAGsI,QAAQ,aAAc,wBACrC,mBAAqBtI,IAAIiJ,SAAS,+BAClC,cAAgBjJ,IAAIiJ,SAAS,kCAGjC,cAAcC,YAAW,eACnBlJ,GAAK2H,KAAK3H,GAAGsI,QAAQ,aAAc,wBACrC,mBAAqBtI,IAAIsH,YAAY,+BACrC,cAAgBtH,IAAIsH,YAAY,kCAIpCxE,UAAUyE,GAAG,YAAa,mBAAmB,+BACzC,mBAAmB0B,SAAS,kCAGhCnG,UAAUyE,GAAG,aAAc,mBAAmB,+BAC1C,mBAAmBD,YAAY,kCAInCxE,UAAUyE,GAAG,QAAS,cAAc,WAElClC,eADSsC,KAAK3H,GAAGsI,QAAQ,aAAc,4BAKzCxF,UAAUyE,GAAG,QAAS,oBAAoB,WAExClC,eADSsC,KAAK3H,GAAGsI,QAAQ,mBAAoB,4BAK/CxF,UAAUyE,GAAG,YAAa,oBAAoB,eACxCvH,GAAK2H,KAAK3H,GAAGsI,QAAQ,mBAAoB,wBAC3C,cAAgBtI,IAAIiJ,SAAS,kCAGjCnG,UAAUyE,GAAG,aAAc,oBAAoB,eACzCvH,GAAK2H,KAAK3H,GAAGsI,QAAQ,mBAAoB,wBAC3C,cAAgBtI,IAAIsH,YAAY,eAI1C7H,MAAO,WACH0J,MAAO"}