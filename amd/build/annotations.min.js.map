{"version":3,"file":"annotations.min.js","sources":["../src/annotations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Module for the annotation functions of the margic.\n *\n * @module     mod_margic/annotations\n * @copyright  2022 coactum GmbH\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport $ from 'jquery';\n\nexport const init = (annotations, canmakeannotations, myuserid) => {\n    var edited = false;\n    // Hide all Moodle forms.\n    $('.annotation-form').hide();\n\n    // Remove col-mds from moodle form.\n    $('.annotation-form div.col-md-3').removeClass('col-md-3');\n    $('.annotation-form div.col-md-9').removeClass('col-md-9');\n    $('.annotation-form div.form-group').removeClass('form-group');\n    $('.annotation-form div.row').removeClass('row');\n\n    /**\n     * Recreate annotations.\n     *\n     */\n    function recreateAnnotations() {\n        for (let annotation of Object.values(annotations)) {\n\n            // Recreate range from db.\n            var newrange = document.createRange();\n\n            try {\n                newrange.setStart(\n                    nodeFromXPath(annotation.startcontainer, $(\"#entry-\" + annotation.entry)[0]), annotation.startposition);\n                newrange.setEnd(\n                    nodeFromXPath(annotation.endcontainer, $(\"#entry-\" + annotation.entry)[0]), annotation.endposition);\n            } catch (e) {\n                // eslint-disable-line\n            }\n\n            var annotatedtext = highlightRange(newrange, annotation.id, 'annotated', annotation.color);\n\n            if (annotatedtext != '') {\n                $('#annotationpreview-' + annotation.id).html(annotatedtext);\n            }\n        }\n    }\n\n    /**\n     * Edit annotation.\n     *\n     * @param {int} annotationid\n     */\n    function editAnnotation(annotationid) {\n\n        if (edited == annotationid) {\n            removeAllTempHighlights(); // Remove other temporary highlights.\n            resetForms(); // Remove old form contents.\n            edited = false;\n        } else if (canmakeannotations && myuserid == annotations[annotationid].userid) {\n            removeAllTempHighlights(); // Remove other temporary highlights.\n            resetForms(); // Remove old form contents.\n\n            edited = annotationid;\n\n            var entry = annotations[annotationid].entry;\n\n            $('.annotation-box-' + annotationid).hide(); // Hide edited annotation-box.\n\n            $('.annotation-form-' + entry + ' input[name=\"startcontainer\"]').val(annotations[annotationid].startcontainer);\n            $('.annotation-form-' + entry + ' input[name=\"endcontainer\"]').val(annotations[annotationid].endcontainer);\n            $('.annotation-form-' + entry + ' input[name=\"startposition\"]').val(annotations[annotationid].startposition);\n            $('.annotation-form-' + entry + ' input[name=\"endposition\"]').val(annotations[annotationid].endposition);\n\n            $('.annotation-form-' + entry + ' input[name=\"annotationid\"]').val(annotationid);\n\n            $('.annotation-form-' + entry + ' textarea[name=\"text\"]').val(annotations[annotationid].text);\n\n            $('.annotation-form-' + entry + ' select').val(annotations[annotationid].type);\n\n            $('#annotationpreview-temp-' + entry).html($('#annotationpreview-' + annotationid).html());\n            $('#annotationpreview-temp-' + entry).css('border-color', '#' + annotations[annotationid].color);\n\n            $('.annotationarea-' + entry + ' .annotation-form').insertBefore('.annotation-box-' + annotationid);\n            $('.annotationarea-' + entry + ' .annotation-form').show();\n            $('.annotationarea-' + entry + ' #id_text').focus();\n        } else {\n            $('.annotation-box-' + annotationid).focus();\n        }\n    }\n\n    /**\n     * Reset all annotation forms\n     */\n    function resetForms() {\n        $('.annotation-form').hide();\n\n        $('.annotation-form input[name^=\"annotationid\"]').val(null);\n\n        $('.annotation-form input[name^=\"startcontainer\"]').val(-1);\n        $('.annotation-form input[name^=\"endcontainer\"]').val(-1);\n        $('.annotation-form input[name^=\"startposition\"]').val(-1);\n        $('.annotation-form input[name^=\"endposition\"]').val(-1);\n\n        $('.annotation-form textarea[name^=\"text\"]').val('');\n\n        $('.annotation-box').not('.annotation-form').show(); // To show again edited annotation.\n    }\n\n    /**\n     * Return text nodes which are entirely inside `range`.\n     *\n     * If a range starts or ends part-way through a text node, the node is split\n     * and the part inside the range is returned.\n     *\n     * @param {Range} range\n     * @return {Text[]}\n     */\n    function wholeTextNodesInRange(range) {\n        if (range.collapsed) {\n            // Exit early for an empty range to avoid an edge case that breaks the algorithm\n            // below. Splitting a text node at the start of an empty range can leave the\n            // range ending in the left part rather than the right part.\n            return [];\n        }\n\n        /** @type {Node|null} */\n        let root = range.commonAncestorContainer;\n        if (root.nodeType !== Node.ELEMENT_NODE) {\n            // If the common ancestor is not an element, set it to the parent element to\n            // ensure that the loop below visits any text nodes generated by splitting\n            // the common ancestor.\n            //\n            // Note that `parentElement` may be `null`.\n            root = root.parentElement;\n        }\n        if (!root) {\n            // If there is no root element then we won't be able to insert highlights,\n            // so exit here.\n            return [];\n        }\n\n        const textNodes = [];\n        const nodeIter = /** @type {Document} */ (\n            root.ownerDocument\n        ).createNodeIterator(\n            root,\n            NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n        );\n        let node;\n        while ((node = nodeIter.nextNode())) {\n            if (!isNodeInRange(range, node)) {\n                continue;\n            }\n            let text = /** @type {Text} */ (node);\n\n            if (text === range.startContainer && range.startOffset > 0) {\n                // Split `text` where the range starts. The split will create a new `Text`\n                // node which will be in the range and will be visited in the next loop iteration.\n                text.splitText(range.startOffset);\n                continue;\n            }\n\n            if (text === range.endContainer && range.endOffset < text.data.length) {\n                // Split `text` where the range ends, leaving it as the part in the range.\n                text.splitText(range.endOffset);\n            }\n\n            textNodes.push(text);\n        }\n\n        return textNodes;\n    }\n\n    /**\n     * Wraps the DOM Nodes within the provided range with a highlight\n     * element of the specified class and returns the highlight Elements.\n     *\n     * @param {Range} range - Range to be highlighted\n     * @param {int} annotationid - ID of annotation\n     * @param {string} cssClass - A CSS class to use for the highlight\n     * @param {string} color - Color of the highlighting\n     * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n     */\n    function highlightRange(range, annotationid = false, cssClass = 'annotated', color = 'FFFF00') {\n\n        const textNodes = wholeTextNodesInRange(range);\n\n        // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n        // adjacent, we only need to create one highlight element for the group.\n        let textNodeSpans = [];\n        let prevNode = null;\n        let currentSpan = null;\n\n        textNodes.forEach(node => {\n            if (prevNode && prevNode.nextSibling === node) {\n                currentSpan.push(node);\n            } else {\n                currentSpan = [node];\n                textNodeSpans.push(currentSpan);\n            }\n            prevNode = node;\n        });\n\n        // Filter out text node spans that consist only of white space. This avoids\n        // inserting highlight elements in places that can only contain a restricted\n        // subset of nodes such as table rows and lists.\n        const whitespace = /^\\s*$/;\n        textNodeSpans = textNodeSpans.filter(span =>\n            // Check for at least one text node with non-space content.\n            span.some(node => !whitespace.test(node.nodeValue))\n        );\n\n        // Wrap each text node span with a `<span>` element.\n        var hihglightedtext = '';\n\n        textNodeSpans.forEach(nodes => {\n            const highlightEl = document.createElement('span');\n            highlightEl.className = cssClass;\n\n            if (annotationid) {\n                highlightEl.className += ' ' + cssClass + '-' + annotationid;\n                // highlightEl.tabIndex = 1;\n                highlightEl.id = cssClass + '-' + annotationid;\n                highlightEl.style.backgroundColor = '#' + color;\n            }\n\n            hihglightedtext += nodes[0].textContent;\n\n            nodes[0].parentNode.replaceChild(highlightEl, nodes[0]);\n            nodes.forEach(node => highlightEl.appendChild(node));\n\n        });\n\n        return hihglightedtext;\n    }\n\n    /**\n     * Returns true if any part of `node` lies within `range`.\n     *\n     * @param {Range} range\n     * @param {Node} node\n     * @return {bool} - If node is in range\n     */\n    function isNodeInRange(range, node) {\n        try {\n            const length = node.nodeValue?.length ?? node.childNodes.length;\n            return (\n                // Check start of node is before end of range.\n                range.comparePoint(node, 0) <= 0 &&\n                // Check end of node is after start of range.\n                range.comparePoint(node, length) >= 0\n            );\n        } catch (e) {\n            // `comparePoint` may fail if the `range` and `node` do not share a common\n            // ancestor or `node` is a doctype.\n            return false;\n        }\n    }\n\n    /**\n     * Get the node name for use in generating an xpath expression.\n     *\n     * @param {Node} node\n     * @return {string} - Name of the node\n     */\n    function getNodeName(node) {\n        const nodeName = node.nodeName.toLowerCase();\n        let result = nodeName;\n        if (nodeName === '#text') {\n            result = 'text()';\n        }\n        return result;\n    }\n\n    /**\n     * Get the index of the node as it appears in its parent's child list\n     *\n     * @param {Node} node\n     * @return {int} - Position of the node\n     */\n    function getNodePosition(node) {\n        let pos = 0;\n        /** @type {Node|null} */\n        let tmp = node;\n        while (tmp) {\n            if (tmp.nodeName === node.nodeName) {\n                pos += 1;\n            }\n            tmp = tmp.previousSibling;\n        }\n        return pos;\n    }\n\n    /**\n     * Get the path segments to the node\n     *\n     * @param {Node} node\n     * @return {array} - Path segments\n     */\n    function getPathSegment(node) {\n        const name = getNodeName(node);\n        const pos = getNodePosition(node);\n        return `${name}[${pos}]`;\n    }\n\n    /**\n     * A simple XPath generator which can generate XPaths of the form\n     * /tag[index]/tag[index].\n     *\n     * @param {Node} node - The node to generate a path to\n     * @param {Node} root - Root node to which the returned path is relative\n     * @return {string} - The xpath of a node\n     */\n    function xpathFromNode(node, root) {\n        let xpath = '';\n\n        /** @type {Node|null} */\n        let elem = node;\n        while (elem !== root) {\n            if (!elem) {\n                throw new Error('Node is not a descendant of root');\n            }\n            xpath = getPathSegment(elem) + '/' + xpath;\n            elem = elem.parentNode;\n        }\n        xpath = '/' + xpath;\n        xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n        return xpath;\n    }\n\n    /**\n     * Return the `index`'th immediate child of `element` whose tag name is\n     * `nodeName` (case insensitive).\n     *\n     * @param {Element} element\n     * @param {string} nodeName\n     * @param {number} index\n     * @return {Element|null} - The child element or null\n     */\n    function nthChildOfType(element, nodeName, index) {\n        nodeName = nodeName.toUpperCase();\n\n        let matchIndex = -1;\n        for (let i = 0; i < element.children.length; i++) {\n            const child = element.children[i];\n            if (child.nodeName.toUpperCase() === nodeName) {\n                ++matchIndex;\n                if (matchIndex === index) {\n                    return child;\n                }\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Evaluate a _simple XPath_ relative to a `root` element and return the\n     * matching element.\n     *\n     * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n     *\n     * Unlike `document.evaluate` this function:\n     *\n     *  - Only supports simple XPaths\n     *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n     *  - Ignores element namespaces when matching element names in the XPath against\n     *    elements in the DOM tree\n     *  - Is case insensitive for all elements, not just HTML elements\n     *\n     * The matching element is returned or `null` if no such element is found.\n     * An error is thrown if `xpath` is not a simple XPath.\n     *\n     * @param {string} xpath\n     * @param {Element} root\n     * @return {Element|null}\n     */\n    function evaluateSimpleXPath(xpath, root) {\n        const isSimpleXPath = xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n        if (!isSimpleXPath) {\n            throw new Error('Expression is not a simple XPath');\n        }\n\n        const segments = xpath.split('/');\n        let element = root;\n\n        // Remove leading empty segment. The regex above validates that the XPath\n        // has at least two segments, with the first being empty and the others non-empty.\n        segments.shift();\n\n        for (let segment of segments) {\n            let elementName;\n            let elementIndex;\n\n            const separatorPos = segment.indexOf('[');\n            if (separatorPos !== -1) {\n                elementName = segment.slice(0, separatorPos);\n\n                const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n                elementIndex = parseInt(indexStr) - 1;\n                if (elementIndex < 0) {\n                    return null;\n                }\n            } else {\n                elementName = segment;\n                elementIndex = 0;\n            }\n\n            const child = nthChildOfType(element, elementName, elementIndex);\n            if (!child) {\n                return null;\n            }\n\n            element = child;\n        }\n\n        return element;\n    }\n\n    /**\n     * Finds an element node using an XPath relative to `root`\n     *\n     * Example:\n     *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n     *\n     * @param {string} xpath\n     * @param {Element} [root]\n     * @return {Node|null}\n     */\n    function nodeFromXPath(xpath, root = document.body) {\n        try {\n            return evaluateSimpleXPath(xpath, root);\n        } catch (err) {\n            return document.evaluate(\n                '.' + xpath,\n                root,\n\n                // The `namespaceResolver` and `result` arguments are optional in the spec\n                // but required in Edge Legacy.\n                null /* NamespaceResolver */,\n                XPathResult.FIRST_ORDERED_NODE_TYPE,\n                null /* Result */\n            ).singleNodeValue;\n        }\n    }\n\n    /**\n     * Replace a child `node` with `replacements`.\n     *\n     * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n     *\n     * @param {ChildNode} node\n     * @param {Node[]} replacements\n     */\n    function replaceWith(node, replacements) {\n        const parent = /** @type {Node} */ (node.parentNode);\n\n        replacements.forEach(r => parent.insertBefore(r, node));\n        node.remove();\n    }\n\n    /**\n     * Remove all temporary highlights under a given root element.\n     */\n    function removeAllTempHighlights() {\n        const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n        if (highlights !== undefined && highlights.length != 0) {\n            removeHighlights(highlights);\n        }\n    }\n\n    /**\n     * Remove highlights from a range previously highlighted with `highlightRange`.\n     *\n     * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n     */\n    function removeHighlights(highlights) {\n        for (var i = 0; i < highlights.length; i++) {\n            if (highlights[i].parentNode) {\n                var pn = highlights[i].parentNode;\n                const children = Array.from(highlights[i].childNodes);\n                replaceWith(highlights[i], children);\n                pn.normalize();\n            }\n        }\n    }\n\n    // If user selects text for new annotation\n    $(document).on('mouseup', '.originaltext', function () {\n        var selectedrange = window.getSelection().getRangeAt(0);\n\n        if (selectedrange.cloneContents().textContent !== '' && canmakeannotations) {\n\n            removeAllTempHighlights(); // Remove other temporary highlights.\n\n            resetForms(); // Remove old form contents.\n\n            var entry = this.id.replace(/entry-/, '');\n\n            $('.annotation-form-' + entry + ' input[name=\"startcontainer\"]').val(\n                xpathFromNode(selectedrange.startContainer, this));\n            $('.annotation-form-' + entry + ' input[name=\"endcontainer\"]').val(\n                xpathFromNode(selectedrange.endContainer, this));\n            $('.annotation-form-' + entry + ' input[name=\"startposition\"]').val(selectedrange.startOffset);\n            $('.annotation-form-' + entry + ' input[name=\"endposition\"]').val(selectedrange.endOffset);\n\n            $('.annotation-form-' + entry + ' select').val(1);\n\n            var annotatedtext = highlightRange(selectedrange, false, 'annotated_temp');\n\n            if (annotatedtext != '') {\n                $('#annotationpreview-temp-' + entry).html(annotatedtext);\n            }\n\n            $('.annotationarea-' + entry + ' .annotation-form').show();\n            $('.annotation-form-' + entry + ' #id_text').focus();\n        }\n    });\n\n    recreateAnnotations();\n\n    // Highlight annotation and all annotated text if annotated text is hovered\n    $('.annotated').mouseenter(function () {\n        var id = this.id.replace('annotated-', '');\n        $('.annotationpreview-' + id).addClass('hovered');\n        $('.annotated-' + id).addClass('hovered');\n        $('.annotation-box-' + id + ' .errortype').addClass('hovered');\n\n    });\n\n    $('.annotated').mouseleave(function () {\n        var id = this.id.replace('annotated-', '');\n        $('.annotationpreview-' + id).removeClass('hovered');\n        $('.annotated-' + id).removeClass('hovered');\n        $('.annotation-box-' + id + ' .errortype').removeClass('hovered');\n    });\n\n    // Highlight annotated text if annotationpreview is hovered\n    $('.annotatedtextpreview').mouseenter(function () {\n        var id = this.id.replace('annotationpreview-', '');\n        $('.annotated-' + id).addClass('hovered');\n    });\n\n    $('.annotatedtextpreview').mouseleave(function () {\n        var id = this.id.replace('annotationpreview-', '');\n        $('.annotated-' + id).removeClass('hovered');\n    });\n\n    // Highlight whole temp annotation if part of temp annotation is hovered\n    $(document).on('mouseover', '.annotated_temp', function () {\n        $('.annotated_temp').addClass('hovered');\n    });\n\n    $(document).on('mouseleave', '.annotated_temp', function () {\n        $('.annotated_temp').removeClass('hovered');\n    });\n\n    // Onclick listener for editing annotation.\n    $(document).on('click', '.annotated', function () {\n        var id = this.id.replace('annotated-', '');\n        editAnnotation(id);\n    });\n\n    // Onclick listener for editing annotation.\n    $(document).on('click', '.edit-annotation', function () {\n        var id = this.id.replace('edit-annotation-', '');\n        editAnnotation(id);\n    });\n\n    // Onclick listener for click on annotation-box.\n    // $(document).on('click', '.annotation-box', function() {\n    //     var id = this.id.replace('annotation-box-', '');\n    //     $('#annotated-' + id).focus();\n    // });\n\n    // onclick listener if form is canceled\n    $(document).on('click', '#id_cancel', function (e) {\n        e.preventDefault();\n\n        removeAllTempHighlights(); // Remove other temporary highlights.\n\n        resetForms(); // Remove old form contents.\n\n        edited = false;\n    });\n\n    // Listen for return key pressed to submit annotation form.\n    $('textarea').keypress(function (e) {\n        if (e.which == 13) {\n            $(this).parents(':eq(2)').submit();\n            e.preventDefault();\n        }\n    });\n\n};"],"names":["annotations","canmakeannotations","myuserid","edited","editAnnotation","annotationid","removeAllTempHighlights","resetForms","userid","entry","hide","val","startcontainer","endcontainer","startposition","endposition","text","type","html","css","color","insertBefore","show","focus","not","wholeTextNodesInRange","range","collapsed","root","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","node","textNodes","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","nextNode","isNodeInRange","startContainer","startOffset","splitText","endContainer","endOffset","data","length","push","highlightRange","cssClass","textNodeSpans","prevNode","currentSpan","forEach","nextSibling","whitespace","filter","span","some","test","nodeValue","hihglightedtext","nodes","highlightEl","document","createElement","className","id","style","backgroundColor","textContent","parentNode","replaceChild","appendChild","_node$nodeValue","childNodes","comparePoint","e","getPathSegment","name","nodeName","toLowerCase","result","getNodeName","pos","tmp","previousSibling","getNodePosition","xpathFromNode","xpath","elem","Error","replace","nthChildOfType","element","index","toUpperCase","matchIndex","i","children","child","evaluateSimpleXPath","match","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt","nodeFromXPath","body","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","replaceWith","replacements","parent","r","remove","highlights","Array","from","querySelectorAll","undefined","pn","normalize","removeHighlights","removeClass","on","selectedrange","window","getSelection","getRangeAt","cloneContents","this","annotatedtext","Object","values","annotation","newrange","createRange","setStart","setEnd","recreateAnnotations","mouseenter","addClass","mouseleave","preventDefault","keypress","which","parents","submit"],"mappings":"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"}