{"version":3,"sources":["../src/xpath.js"],"names":["node","root","xpath","elem","Error","getPathSegment","parentNode","replace","document","body","evaluateSimpleXPath","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","getNodeName","nodeName","toLowerCase","result","getNodePosition","pos","tmp","previousSibling","name","nthChildOfType","element","index","toUpperCase","matchIndex","i","child","children","length","isSimpleXPath","match","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt"],"mappings":"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","sourcesContent":["/**\n * XPATH and DOM functions used for anchoring and highlighting.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Get the node name for use in generating an xpath expression.\n *\n * @param {Node} node\n * @return {string} - Name of the node\n */\nfunction getNodeName(node) {\n  const nodeName = node.nodeName.toLowerCase();\n  let result = nodeName;\n  if (nodeName === '#text') {\n    result = 'text()';\n  }\n  return result;\n}\n\n/**\n * Get the index of the node as it appears in its parent's child list\n *\n * @param {Node} node\n * @return {int} - Position of the node\n */\nfunction getNodePosition(node) {\n  let pos = 0;\n  /** @type {Node|null} */\n  let tmp = node;\n  while (tmp) {\n    if (tmp.nodeName === node.nodeName) {\n      pos += 1;\n    }\n    tmp = tmp.previousSibling;\n  }\n  return pos;\n}\n\n/**\n * Get the path segments to the node\n *\n * @param {Node} node\n * @return {array} - Path segments\n */\nfunction getPathSegment(node) {\n  const name = getNodeName(node);\n  const pos = getNodePosition(node);\n  return `${name}[${pos}]`;\n}\n\n/**\n * A simple XPath generator which can generate XPaths of the form\n * /tag[index]/tag[index].\n *\n * @param {Node} node - The node to generate a path to\n * @param {Node} root - Root node to which the returned path is relative\n * @return {string} - The xpath of a node\n */\nexport function xpathFromNode(node, root) {\n  let xpath = '';\n\n  /** @type {Node|null} */\n  let elem = node;\n  while (elem !== root) {\n    if (!elem) {\n      throw new Error('Node is not a descendant of root');\n    }\n    xpath = getPathSegment(elem) + '/' + xpath;\n    elem = elem.parentNode;\n  }\n  xpath = '/' + xpath;\n  xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n  return xpath;\n}\n\n/**\n * Return the `index`'th immediate child of `element` whose tag name is\n * `nodeName` (case insensitive).\n *\n * @param {Element} element\n * @param {string} nodeName\n * @param {number} index\n * @return {Element} - The child element or null\n */\nfunction nthChildOfType(element, nodeName, index) {\n  nodeName = nodeName.toUpperCase();\n\n  let matchIndex = -1;\n  for (let i = 0; i < element.children.length; i++) {\n    const child = element.children[i];\n    if (child.nodeName.toUpperCase() === nodeName) {\n      ++matchIndex;\n      if (matchIndex === index) {\n        return child;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Evaluate a _simple XPath_ relative to a `root` element and return the\n * matching element.\n *\n * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n *\n * Unlike `document.evaluate` this function:\n *\n *  - Only supports simple XPaths\n *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n *  - Ignores element namespaces when matching element names in the XPath against\n *    elements in the DOM tree\n *  - Is case insensitive for all elements, not just HTML elements\n *\n * The matching element is returned or `null` if no such element is found.\n * An error is thrown if `xpath` is not a simple XPath.\n *\n * @param {string} xpath\n * @param {Element} root\n * @return {Element|null}\n */\nfunction evaluateSimpleXPath(xpath, root) {\n  const isSimpleXPath =\n    xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n  if (!isSimpleXPath) {\n    throw new Error('Expression is not a simple XPath');\n  }\n\n  const segments = xpath.split('/');\n  let element = root;\n\n  // Remove leading empty segment. The regex above validates that the XPath\n  // has at least two segments, with the first being empty and the others non-empty.\n  segments.shift();\n\n  for (let segment of segments) {\n    let elementName;\n    let elementIndex;\n\n    const separatorPos = segment.indexOf('[');\n    if (separatorPos !== -1) {\n      elementName = segment.slice(0, separatorPos);\n\n      const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n      elementIndex = parseInt(indexStr) - 1;\n      if (elementIndex < 0) {\n        return null;\n      }\n    } else {\n      elementName = segment;\n      elementIndex = 0;\n    }\n\n    const child = nthChildOfType(element, elementName, elementIndex);\n    if (!child) {\n      return null;\n    }\n\n    element = child;\n  }\n\n  return element;\n}\n\n/**\n * Finds an element node using an XPath relative to `root`\n *\n * Example:\n *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n *\n * @param {string} xpath\n * @param {Element} [root]\n * @return {Node|null}\n */\nexport function nodeFromXPath(xpath, root = document.body) {\n  try {\n    return evaluateSimpleXPath(xpath, root);\n  } catch (err) {\n    return document.evaluate(\n      '.' + xpath,\n      root,\n\n      // Nb. The `namespaceResolver` and `result` arguments are optional in the spec but required in Edge Legacy.\n      null /* NamespaceResolver */,\n      XPathResult.FIRST_ORDERED_NODE_TYPE,\n      null /* Result */\n    ).singleNodeValue;\n  }\n}\n"],"file":"xpath.min.js"}