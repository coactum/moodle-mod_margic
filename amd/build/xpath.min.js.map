{"version":3,"file":"xpath.min.js","sources":["../src/xpath.js"],"sourcesContent":["/**\n * XPATH and DOM functions used for anchoring and highlighting.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Get the node name for use in generating an xpath expression.\n *\n * @param {Node} node\n * @return {string} - Name of the node\n */\nfunction getNodeName(node) {\n  const nodeName = node.nodeName.toLowerCase();\n  let result = nodeName;\n  if (nodeName === '#text') {\n    result = 'text()';\n  }\n  return result;\n}\n\n/**\n * Get the index of the node as it appears in its parent's child list\n *\n * @param {Node} node\n * @return {int} - Position of the node\n */\nfunction getNodePosition(node) {\n  let pos = 0;\n  /** @type {Node|null} */\n  let tmp = node;\n  while (tmp) {\n    if (tmp.nodeName === node.nodeName) {\n      pos += 1;\n    }\n    tmp = tmp.previousSibling;\n  }\n  return pos;\n}\n\n/**\n * Get the path segments to the node\n *\n * @param {Node} node\n * @return {array} - Path segments\n */\nfunction getPathSegment(node) {\n  const name = getNodeName(node);\n  const pos = getNodePosition(node);\n  return `${name}[${pos}]`;\n}\n\n/**\n * A simple XPath generator which can generate XPaths of the form\n * /tag[index]/tag[index].\n *\n * @param {Node} node - The node to generate a path to\n * @param {Node} root - Root node to which the returned path is relative\n * @return {string} - The xpath of a node\n */\nexport function xpathFromNode(node, root) {\n  let xpath = '';\n\n  // console.log('xpathFromNode');\n  // console.log('node');\n  // console.log(node);\n  // console.log('root');\n  // console.log(root);\n\n  /** @type {Node|null} */\n  let elem = node;\n  while (elem !== root) {\n    if (!elem) {\n      throw new Error('Node is not a descendant of root');\n    }\n    xpath = getPathSegment(elem) + '/' + xpath;\n    elem = elem.parentNode;\n  }\n  xpath = '/' + xpath;\n  xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n  // console.log('xpathFromNode xpath');\n  // console.log(xpath);\n\n  return xpath;\n}\n\n/**\n * Return the `index`'th immediate child of `element` whose tag name is\n * `nodeName` (case insensitive).\n *\n * @param {Element} element\n * @param {string} nodeName\n * @param {number} index\n * @return {Element} - The child element or null\n */\nfunction nthChildOfType(element, nodeName, index) {\n  nodeName = nodeName.toUpperCase();\n\n  let matchIndex = -1;\n  for (let i = 0; i < element.children.length; i++) {\n    const child = element.children[i];\n    if (child.nodeName.toUpperCase() === nodeName) {\n      ++matchIndex;\n      if (matchIndex === index) {\n        return child;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Evaluate a _simple XPath_ relative to a `root` element and return the\n * matching element.\n *\n * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n *\n * Unlike `document.evaluate` this function:\n *\n *  - Only supports simple XPaths\n *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n *  - Ignores element namespaces when matching element names in the XPath against\n *    elements in the DOM tree\n *  - Is case insensitive for all elements, not just HTML elements\n *\n * The matching element is returned or `null` if no such element is found.\n * An error is thrown if `xpath` is not a simple XPath.\n *\n * @param {string} xpath\n * @param {Element} root\n * @return {Element|null}\n */\nfunction evaluateSimpleXPath(xpath, root) {\n  const isSimpleXPath =\n    xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n  if (!isSimpleXPath) {\n    throw new Error('Expression is not a simple XPath');\n  }\n\n  const segments = xpath.split('/');\n  let element = root;\n\n  // Remove leading empty segment. The regex above validates that the XPath\n  // has at least two segments, with the first being empty and the others non-empty.\n  segments.shift();\n\n  for (let segment of segments) {\n    let elementName;\n    let elementIndex;\n\n    const separatorPos = segment.indexOf('[');\n    if (separatorPos !== -1) {\n      elementName = segment.slice(0, separatorPos);\n\n      const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n      elementIndex = parseInt(indexStr) - 1;\n      if (elementIndex < 0) {\n        return null;\n      }\n    } else {\n      elementName = segment;\n      elementIndex = 0;\n    }\n\n    const child = nthChildOfType(element, elementName, elementIndex);\n    if (!child) {\n      return null;\n    }\n\n    element = child;\n  }\n\n  return element;\n}\n\n/**\n * Finds an element node using an XPath relative to `root`\n *\n * Example:\n *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n *\n * @param {string} xpath\n * @param {Element} [root]\n * @return {Node|null}\n */\nexport function nodeFromXPath(xpath, root = document.body) {\n  try {\n    return evaluateSimpleXPath(xpath, root);\n  } catch (err) {\n    return document.evaluate(\n      '.' + xpath,\n      root,\n\n      // Nb. The `namespaceResolver` and `result` arguments are optional in the spec but required in Edge Legacy.\n      null /* NamespaceResolver */,\n      XPathResult.FIRST_ORDERED_NODE_TYPE,\n      null /* Result */\n    ).singleNodeValue;\n  }\n}\n"],"names":["getPathSegment","node","name","nodeName","toLowerCase","result","getNodeName","pos","tmp","previousSibling","getNodePosition","nthChildOfType","element","index","toUpperCase","matchIndex","i","children","length","child","evaluateSimpleXPath","xpath","root","match","Error","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt","document","body","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","elem","parentNode","replace"],"mappings":"i0CAgDSA,eAAeC,UAChBC,cAnCaD,UACbE,SAAWF,KAAKE,SAASC,cAC3BC,OAASF,eACI,UAAbA,WACFE,OAAS,UAEJA,OA6BMC,CAAYL,MACnBM,aArBiBN,cACnBM,IAAM,EAENC,IAAMP,KACHO,KACDA,IAAIL,WAAaF,KAAKE,WACxBI,KAAO,GAETC,IAAMA,IAAIC,uBAELF,IAWKG,CAAgBT,sBAClBC,iBAAQK,kBA+CXI,eAAeC,QAAST,SAAUU,OACzCV,SAAWA,SAASW,sBAEhBC,YAAc,EACTC,EAAI,EAAGA,EAAIJ,QAAQK,SAASC,OAAQF,IAAK,KAC1CG,MAAQP,QAAQK,SAASD,MAC3BG,MAAMhB,SAASW,gBAAkBX,YACjCY,aACiBF,aACVM,aAKN,cAwBAC,oBAAoBC,MAAOC,WAEqB,OAArDD,MAAME,MAAM,4CAEN,IAAIC,MAAM,wCAGZC,SAAWJ,MAAMK,MAAM,KACzBd,QAAUU,KAIdG,SAASE,uDAEWF,6DAAU,KAArBG,oBACHC,mBACAC,oBAEEC,aAAeH,QAAQI,QAAQ,SACf,IAAlBD,aAAqB,CACvBF,YAAcD,QAAQK,MAAM,EAAGF,kBAEzBG,SAAWN,QAAQK,MAAMF,aAAe,EAAGH,QAAQI,QAAQ,UACjEF,aAAeK,SAASD,UAAY,GACjB,SACV,UAGTL,YAAcD,QACdE,aAAe,MAGXX,MAAQR,eAAeC,QAASiB,YAAaC,kBAC9CX,aACI,KAGTP,QAAUO,gEAGLP,gGAaqBS,WAAOC,4DAAOc,SAASC,gBAE1CjB,oBAAoBC,MAAOC,MAClC,MAAOgB,YACAF,SAASG,SACd,IAAMlB,MACNC,KAGA,KACAkB,YAAYC,wBACZ,MACAC,kDA3IwBzC,KAAMqB,UAC9BD,MAAQ,GASRsB,KAAO1C,UACJ0C,OAASrB,MAAM,KACfqB,WACG,IAAInB,MAAM,oCAElBH,MAAQrB,eAAe2C,MAAQ,IAAMtB,MACrCsB,KAAOA,KAAKC,kBAGdvB,OADAA,MAAQ,IAAMA,OACAwB,QAAQ,MAAO"}