{"version":3,"file":"xpath.min.js","sources":["../src/xpath.js"],"sourcesContent":["/**\n * XPATH and DOM functions used for anchoring and highlighting.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Get the node name for use in generating an xpath expression.\n *\n * @param {Node} node\n * @return {string} - Name of the node\n */\nfunction getNodeName(node) {\n  const nodeName = node.nodeName.toLowerCase();\n  let result = nodeName;\n  if (nodeName === '#text') {\n    result = 'text()';\n  }\n  return result;\n}\n\n/**\n * Get the index of the node as it appears in its parent's child list\n *\n * @param {Node} node\n * @return {int} - Position of the node\n */\nfunction getNodePosition(node) {\n  let pos = 0;\n  /** @type {Node|null} */\n  let tmp = node;\n  while (tmp) {\n    if (tmp.nodeName === node.nodeName) {\n      pos += 1;\n    }\n    tmp = tmp.previousSibling;\n  }\n  return pos;\n}\n\n/**\n * Get the path segments to the node\n *\n * @param {Node} node\n * @return {array} - Path segments\n */\nfunction getPathSegment(node) {\n  const name = getNodeName(node);\n  const pos = getNodePosition(node);\n  return `${name}[${pos}]`;\n}\n\n/**\n * A simple XPath generator which can generate XPaths of the form\n * /tag[index]/tag[index].\n *\n * @param {Node} node - The node to generate a path to\n * @param {Node} root - Root node to which the returned path is relative\n * @return {string} - The xpath of a node\n */\nexport function xpathFromNode(node, root) {\n  let xpath = '';\n\n  /** @type {Node|null} */\n  let elem = node;\n  while (elem !== root) {\n    if (!elem) {\n      throw new Error('Node is not a descendant of root');\n    }\n    xpath = getPathSegment(elem) + '/' + xpath;\n    elem = elem.parentNode;\n  }\n  xpath = '/' + xpath;\n  xpath = xpath.replace(/\\/$/, ''); // Remove trailing slash\n\n  return xpath;\n}\n\n/**\n * Return the `index`'th immediate child of `element` whose tag name is\n * `nodeName` (case insensitive).\n *\n * @param {Element} element\n * @param {string} nodeName\n * @param {number} index\n * @return {Element} - The child element or null\n */\nfunction nthChildOfType(element, nodeName, index) {\n  nodeName = nodeName.toUpperCase();\n\n  let matchIndex = -1;\n  for (let i = 0; i < element.children.length; i++) {\n    const child = element.children[i];\n    if (child.nodeName.toUpperCase() === nodeName) {\n      ++matchIndex;\n      if (matchIndex === index) {\n        return child;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Evaluate a _simple XPath_ relative to a `root` element and return the\n * matching element.\n *\n * A _simple XPath_ is a sequence of one or more `/tagName[index]` strings.\n *\n * Unlike `document.evaluate` this function:\n *\n *  - Only supports simple XPaths\n *  - Is not affected by the document's _type_ (HTML or XML/XHTML)\n *  - Ignores element namespaces when matching element names in the XPath against\n *    elements in the DOM tree\n *  - Is case insensitive for all elements, not just HTML elements\n *\n * The matching element is returned or `null` if no such element is found.\n * An error is thrown if `xpath` is not a simple XPath.\n *\n * @param {string} xpath\n * @param {Element} root\n * @return {Element|null}\n */\nfunction evaluateSimpleXPath(xpath, root) {\n  const isSimpleXPath =\n    xpath.match(/^(\\/[A-Za-z0-9-]+(\\[[0-9]+\\])?)+$/) !== null;\n  if (!isSimpleXPath) {\n    throw new Error('Expression is not a simple XPath');\n  }\n\n  const segments = xpath.split('/');\n  let element = root;\n\n  // Remove leading empty segment. The regex above validates that the XPath\n  // has at least two segments, with the first being empty and the others non-empty.\n  segments.shift();\n\n  for (let segment of segments) {\n    let elementName;\n    let elementIndex;\n\n    const separatorPos = segment.indexOf('[');\n    if (separatorPos !== -1) {\n      elementName = segment.slice(0, separatorPos);\n\n      const indexStr = segment.slice(separatorPos + 1, segment.indexOf(']'));\n      elementIndex = parseInt(indexStr) - 1;\n      if (elementIndex < 0) {\n        return null;\n      }\n    } else {\n      elementName = segment;\n      elementIndex = 0;\n    }\n\n    const child = nthChildOfType(element, elementName, elementIndex);\n    if (!child) {\n      return null;\n    }\n\n    element = child;\n  }\n\n  return element;\n}\n\n/**\n * Finds an element node using an XPath relative to `root`\n *\n * Example:\n *   node = nodeFromXPath('/main/article[1]/p[3]', document.body)\n *\n * @param {string} xpath\n * @param {Element} [root]\n * @return {Node|null}\n */\nexport function nodeFromXPath(xpath, root = document.body) {\n  try {\n    return evaluateSimpleXPath(xpath, root);\n  } catch (err) {\n    return document.evaluate(\n      '.' + xpath,\n      root,\n\n      // Nb. The `namespaceResolver` and `result` arguments are optional in the spec but required in Edge Legacy.\n      null /* NamespaceResolver */,\n      XPathResult.FIRST_ORDERED_NODE_TYPE,\n      null /* Result */\n    ).singleNodeValue;\n  }\n}\n"],"names":["getPathSegment","node","name","nodeName","toLowerCase","result","getNodeName","pos","tmp","previousSibling","getNodePosition","concat","nthChildOfType","element","index","toUpperCase","matchIndex","i","children","length","child","xpath","root","arguments","undefined","document","body","isSimpleXPath","match","Error","segments","split","shift","segment","elementName","elementIndex","separatorPos","indexOf","slice","indexStr","parseInt","evaluateSimpleXPath","err","evaluate","XPathResult","FIRST_ORDERED_NODE_TYPE","singleNodeValue","elem","parentNode","replace"],"mappings":"0DAgDA,SAASA,eAAeC,MACtB,MAAMC,KAnCR,SAAqBD,MACnB,MAAME,SAAWF,KAAKE,SAASC,cAC/B,IAAIC,OAASF,SAIb,MAHiB,UAAbA,WACFE,OAAS,UAEJA,MACT,CA4BeC,CAAYL,MACnBM,IArBR,SAAyBN,MACvB,IAAIM,IAAM,EAENC,IAAMP,KACV,KAAOO,KACDA,IAAIL,WAAaF,KAAKE,WACxBI,KAAO,GAETC,IAAMA,IAAIC,gBAEZ,OAAOF,GACT,CAUcG,CAAgBT,MAC5B,MAAA,GAAAU,OAAUT,KAAIS,KAAAA,OAAIJ,IAAG,IACvB,CAqCA,SAASK,eAAeC,QAASV,SAAUW,OACzCX,SAAWA,SAASY,cAEpB,IAAIC,YAAc,EAClB,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,QAAQK,SAASC,OAAQF,IAAK,CAChD,MAAMG,MAAQP,QAAQK,SAASD,GAC/B,GAAIG,MAAMjB,SAASY,gBAAkBZ,aACjCa,WACEA,aAAeF,OACjB,OAAOM,KAGb,CAEA,OAAO,IACT,gFA4EO,SAAuBC,OAA6B,IAAtBC,KAAIC,UAAAJ,OAAAI,QAAAC,IAAAD,UAAAC,GAAAD,UAAGE,GAAAA,SAASC,KACnD,IACE,OAvDJ,SAA6BL,MAAOC,MAClC,MAAMK,cACiD,OAArDN,MAAMO,MAAM,qCACd,IAAKD,cACH,MAAM,IAAIE,MAAM,oCAGlB,MAAMC,SAAWT,MAAMU,MAAM,KAC7B,IAAIlB,QAAUS,KAIdQ,SAASE,QAET,IAAK,IAAIC,WAAWH,SAAU,CAC5B,IAAII,YACAC,aAEJ,MAAMC,aAAeH,QAAQI,QAAQ,KACrC,IAAsB,IAAlBD,aAAqB,CACvBF,YAAcD,QAAQK,MAAM,EAAGF,cAE/B,MAAMG,SAAWN,QAAQK,MAAMF,aAAe,EAAGH,QAAQI,QAAQ,MAEjE,GADAF,aAAeK,SAASD,UAAY,EAChCJ,aAAe,EACjB,OAAO,IAEX,MACED,YAAcD,QACdE,aAAe,EAGjB,MAAMf,MAAQR,eAAeC,QAASqB,YAAaC,cACnD,IAAKf,MACH,OAAO,KAGTP,QAAUO,KACZ,CAEA,OAAOP,OACT,CAcW4B,CAAoBpB,MAAOC,KACnC,CAAC,MAAOoB,KACP,OAAOjB,SAASkB,SACd,IAAMtB,MACNC,KAGA,KACAsB,YAAYC,wBACZ,MACAC,eACJ,CACF,yBApIO,SAAuB7C,KAAMqB,MAClC,IAAID,MAAQ,GAGR0B,KAAO9C,KACX,KAAO8C,OAASzB,MAAM,CACpB,IAAKyB,KACH,MAAM,IAAIlB,MAAM,oCAElBR,MAAQrB,eAAe+C,MAAQ,IAAM1B,MACrC0B,KAAOA,KAAKC,UACd,CAIA,OAHA3B,MAAQ,IAAMA,MACdA,MAAQA,MAAM4B,QAAQ,MAAO,IAEtB5B,KACT,CAoHC"}