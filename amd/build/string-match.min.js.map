{"version":3,"sources":["../src/string-match.js"],"names":["text","pattern","maxErrors","matches","findMatchEnds","findMatchStarts","reverse","s","split","join","patRev","map","m","minStart","Math","max","end","length","errors","textRev","slice","start","reduce","min","rm","oneIfNotZero","n","advanceBlock","ctx","peq","b","hIn","pV","P","mV","M","hInIsNegative","eq","xV","xH","pH","mH","hOut","lastRowMask","w","bMax","ceil","Uint32Array","fill","emptyPeq","Map","asciiPeq","i","push","c","val","charCodeAt","has","charPeq","set","r","idx","match","y","score","j","charCode","get","carry","maxBlockScore","remainder","splice"],"mappings":"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","sourcesContent":["/**\n * Functions for string matching used by the other methods.\n *\n * This code originaly is from the approx-string-match project (https://github.com/robertknight/approx-string-match-js)\n * by Robert Knight wich is released under the MIT License (https://opensource.org/licenses/MIT).\n */\n\n/**\n * Represents a match returned by a call to `search`.\n * @param {string} s - Document text to search\n * @return {string}\n */\n  function reverse(s) {\n    return s.split(\"\").reverse().join(\"\");\n  }\n\n  /**\n   * Given the ends of approximate matches for `pattern` in `text`, find\n   * the start of the matches.\n   *\n   * @param {string} text\n   * @param {string} pattern\n   * @param {array} matches\n   * @return {obj} Matches with the `start` property set.\n   */\n  function findMatchStarts(text, pattern, matches) {\n    const patRev = reverse(pattern);\n\n    return matches.map((m) => {\n      // Find start of each match by reversing the pattern and matching segment\n      // of text and searching for an approx match with the same number of\n      // errors.\n      const minStart = Math.max(0, m.end - pattern.length - m.errors);\n      const textRev = reverse(text.slice(minStart, m.end));\n\n      // If there are multiple possible start points, choose the one that\n      // maximizes the length of the match.\n      const start = findMatchEnds(textRev, patRev, m.errors).reduce((min, rm) => {\n        if (m.end - rm.end < min) {\n          return m.end - rm.end;\n        }\n        return min;\n      }, m.end);\n\n      return {\n        start,\n        end: m.end,\n        errors: m.errors,\n      };\n    });\n  }\n\n  /**\n   * Internal context used when calculating blocks of a column.\n   */\n  // interface Context {\n  //   /**\n  //    * Bit-arrays of positive vertical deltas.\n  //    *\n  //    * ie. `P[b][i]` is set if the vertical delta for the i'th row in the b'th\n  //    * block is positive.\n  //    */\n  //   P: Uint32Array;\n  //   /** Bit-arrays of negative vertical deltas. */\n  //   M: Uint32Array;\n  //   /** Bit masks with a single bit set indicating the last row in each block. */\n  //   lastRowMask: Uint32Array;\n  // }\n\n  /**\n   * Return 1 if a number is non-zero or zero otherwise, without using\n   * conditional operators.\n   *\n   * This should get inlined into `advanceBlock` below by the JIT.\n   *\n   * Adapted from https://stackoverflow.com/a/3912218/434243\n   * @param {int} n\n   * @return {bool}\n   */\n  function oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n  }\n\n  /**\n   * Block calculation step of the algorithm.\n   *\n   * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n   * checks with bitwise operations as per Section 4.2.3 of [2].\n   *\n   * @param {obj} ctx - The pattern context object\n   * @param {array} peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n   * @param {int} b - The block level\n   * @param {obj} hIn - Horizontal input delta ∈ {1,0,-1}\n   * @return {obj} Horizontal output delta ∈ {1,0,-1}\n   */\n  function advanceBlock(ctx, peq, b, hIn) {\n    let pV = ctx.P[b];\n    let mV = ctx.M[b];\n    const hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    const eq = peq[b] | hInIsNegative;\n\n    // Step 1: Compute horizontal deltas.\n    const xV = eq | mV;\n    const xH = (((eq & pV) + pV) ^ pV) | eq;\n\n    let pH = mV | ~(xH | pV);\n    let mH = pV & xH;\n\n    // Step 2: Update score (value of last row of this block).\n    const hOut =\n      oneIfNotZero(pH & ctx.lastRowMask[b]) -\n      oneIfNotZero(mH & ctx.lastRowMask[b]);\n\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // Set pH[0] if hIn > 0.\n\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n\n    return hOut;\n  }\n\n  /**\n   * Find the ends and error counts for matches of `pattern` in `text`.\n   *\n   * Only the matches with the lowest error count are reported. Other matches\n   * with error counts <= maxErrors are discarded.\n   *\n   * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n   *\n   * @param {string} text\n   * @param {string} pattern\n   * @param {array} maxErrors\n   * @return {obj} Matches with the `start` property set.\n   */\n  function findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n      return [];\n    }\n\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n\n    const matches = [];\n\n    // Word size.\n    const w = 32;\n\n    // Index of maximum block level.\n    const bMax = Math.ceil(pattern.length / w) - 1;\n\n    // Context used across block calculations.\n    const ctx = {\n      P: new Uint32Array(bMax + 1),\n      M: new Uint32Array(bMax + 1),\n      lastRowMask: new Uint32Array(bMax + 1),\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n\n    // Dummy \"peq\" array for chars in the text which do not occur in the pattern.\n    const emptyPeq = new Uint32Array(bMax + 1);\n\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    const peq = new Map();\n\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    const asciiPeq = [];\n    for (let i = 0; i < 256; i++) {\n      asciiPeq.push(emptyPeq);\n    }\n\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (let c = 0; c < pattern.length; c += 1) {\n      const val = pattern.charCodeAt(c);\n      if (peq.has(val)) {\n        // Duplicate char in pattern.\n        continue;\n      }\n\n      const charPeq = new Uint32Array(bMax + 1);\n      peq.set(val, charPeq);\n      if (val < asciiPeq.length) {\n        asciiPeq[val] = charPeq;\n      }\n\n      for (let b = 0; b <= bMax; b += 1) {\n        charPeq[b] = 0;\n\n        // Set all the bits where the pattern matches the current char (ch).\n        // For indexes beyond the end of the pattern, always set the bit as if the\n        // pattern contained a wildcard char in that position.\n        for (let r = 0; r < w; r += 1) {\n          const idx = b * w + r;\n          if (idx >= pattern.length) {\n            continue;\n          }\n\n          const match = pattern.charCodeAt(idx) === val;\n          if (match) {\n            charPeq[b] |= 1 << r;\n          }\n        }\n      }\n    }\n\n    // Index of last-active block level in the column.\n    let y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n\n    // Initialize maximum error count at bottom of each block.\n    const score = new Uint32Array(bMax + 1);\n    for (let b = 0; b <= y; b += 1) {\n      score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n\n    // Initialize vertical deltas for each block.\n    for (let b = 0; b <= y; b += 1) {\n      ctx.P[b] = ~0;\n      ctx.M[b] = 0;\n    }\n\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (let j = 0; j < text.length; j += 1) {\n      // Lookup the bitmask representing the positions of the current char from\n      // the text within the pattern.\n      const charCode = text.charCodeAt(j);\n      let charPeq;\n\n      if (charCode < asciiPeq.length) {\n        // Fast array lookup.\n        charPeq = asciiPeq[charCode];\n      } else {\n        // Slower hash table lookup.\n        charPeq = peq.get(charCode);\n        if (typeof charPeq === \"undefined\") {\n          charPeq = emptyPeq;\n        }\n      }\n\n      // Calculate error count for blocks that we definitely have to process for\n      // this column.\n      let carry = 0;\n      for (let b = 0; b <= y; b += 1) {\n        carry = advanceBlock(ctx, charPeq, b, carry);\n        score[b] += carry;\n      }\n\n      // Check if we also need to compute an additional block, or if we can reduce\n      // the number of blocks processed for the next column.\n      if (\n        score[y] - carry <= maxErrors &&\n        y < bMax &&\n        (charPeq[y + 1] & 1 || carry < 0)\n      ) {\n        // Error count for bottom block is under threshold, increase the number of\n        // blocks processed for this column & next by 1.\n        y += 1;\n\n        ctx.P[y] = ~0;\n        ctx.M[y] = 0;\n\n        let maxBlockScore;\n        if (y === bMax) {\n          const remainder = pattern.length % w;\n          maxBlockScore = remainder === 0 ? w : remainder;\n        } else {\n          maxBlockScore = w;\n        }\n\n        score[y] =\n          score[y - 1] +\n          maxBlockScore -\n          carry +\n          advanceBlock(ctx, charPeq, y, carry);\n      } else {\n        // Error count for bottom block exceeds threshold, reduce the number of\n        // blocks processed for the next column.\n        while (y > 0 && score[y] >= maxErrors + w) {\n          y -= 1;\n        }\n      }\n\n      // If error count is under threshold, report a match.\n      if (y === bMax && score[y] <= maxErrors) {\n        if (score[y] < maxErrors) {\n          // Discard any earlier, worse matches.\n          matches.splice(0, matches.length);\n        }\n\n        matches.push({\n          start: -1,\n          end: j + 1,\n          errors: score[y],\n        });\n\n        // Because `search` only reports the matches with the lowest error count,\n        // we can \"ratchet down\" the max error threshold whenever a match is\n        // encountered and thereby save a small amount of work for the remainder\n        // of the text.\n        maxErrors = score[y];\n      }\n    }\n\n    return matches;\n  }\n\n  /**\n   * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n   *\n   * Returns the start, and end positions and error counts for each lowest-cost\n   * match. Only the \"best\" matches are returned.\n   * @param {string} text\n   * @param {string} pattern\n   * @param {array} maxErrors\n   * @return {obj} Matches with the `start` property set.\n   */\n  export default function search(\n    text,\n    pattern,\n    maxErrors\n  ) {\n    const matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n  }"],"file":"string-match.min.js"}