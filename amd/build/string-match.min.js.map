{"version":3,"file":"string-match.min.js","sources":["../src/string-match.js"],"sourcesContent":["/**\n * Functions for string matching used by the other methods.\n *\n * This code originaly is from the approx-string-match project (https://github.com/robertknight/approx-string-match-js)\n * by Robert Knight wich is released under the MIT License (https://opensource.org/licenses/MIT).\n */\n\n/**\n * Represents a match returned by a call to `search`.\n * @param {string} s - Document text to search\n * @return {string}\n */\n  function reverse(s) {\n    return s.split(\"\").reverse().join(\"\");\n  }\n\n  /**\n   * Given the ends of approximate matches for `pattern` in `text`, find\n   * the start of the matches.\n   *\n   * @param {string} text\n   * @param {string} pattern\n   * @param {array} matches\n   * @return {obj} Matches with the `start` property set.\n   */\n  function findMatchStarts(text, pattern, matches) {\n    const patRev = reverse(pattern);\n\n    return matches.map((m) => {\n      // Find start of each match by reversing the pattern and matching segment\n      // of text and searching for an approx match with the same number of\n      // errors.\n      const minStart = Math.max(0, m.end - pattern.length - m.errors);\n      const textRev = reverse(text.slice(minStart, m.end));\n\n      // If there are multiple possible start points, choose the one that\n      // maximizes the length of the match.\n      const start = findMatchEnds(textRev, patRev, m.errors).reduce((min, rm) => {\n        if (m.end - rm.end < min) {\n          return m.end - rm.end;\n        }\n        return min;\n      }, m.end);\n\n      return {\n        start,\n        end: m.end,\n        errors: m.errors,\n      };\n    });\n  }\n\n  /**\n   * Internal context used when calculating blocks of a column.\n   */\n  // interface Context {\n  //   /**\n  //    * Bit-arrays of positive vertical deltas.\n  //    *\n  //    * ie. `P[b][i]` is set if the vertical delta for the i'th row in the b'th\n  //    * block is positive.\n  //    */\n  //   P: Uint32Array;\n  //   /** Bit-arrays of negative vertical deltas. */\n  //   M: Uint32Array;\n  //   /** Bit masks with a single bit set indicating the last row in each block. */\n  //   lastRowMask: Uint32Array;\n  // }\n\n  /**\n   * Return 1 if a number is non-zero or zero otherwise, without using\n   * conditional operators.\n   *\n   * This should get inlined into `advanceBlock` below by the JIT.\n   *\n   * Adapted from https://stackoverflow.com/a/3912218/434243\n   * @param {int} n\n   * @return {bool}\n   */\n  function oneIfNotZero(n) {\n    return ((n | -n) >> 31) & 1;\n  }\n\n  /**\n   * Block calculation step of the algorithm.\n   *\n   * From Fig 8. on p. 408 of [1], additionally optimized to replace conditional\n   * checks with bitwise operations as per Section 4.2.3 of [2].\n   *\n   * @param {obj} ctx - The pattern context object\n   * @param {array} peq - The `peq` array for the current character (`ctx.peq.get(ch)`)\n   * @param {int} b - The block level\n   * @param {obj} hIn - Horizontal input delta ∈ {1,0,-1}\n   * @return {obj} Horizontal output delta ∈ {1,0,-1}\n   */\n  function advanceBlock(ctx, peq, b, hIn) {\n    let pV = ctx.P[b];\n    let mV = ctx.M[b];\n    const hInIsNegative = hIn >>> 31; // 1 if hIn < 0 or 0 otherwise.\n    const eq = peq[b] | hInIsNegative;\n\n    // Step 1: Compute horizontal deltas.\n    const xV = eq | mV;\n    const xH = (((eq & pV) + pV) ^ pV) | eq;\n\n    let pH = mV | ~(xH | pV);\n    let mH = pV & xH;\n\n    // Step 2: Update score (value of last row of this block).\n    const hOut =\n      oneIfNotZero(pH & ctx.lastRowMask[b]) -\n      oneIfNotZero(mH & ctx.lastRowMask[b]);\n\n    // Step 3: Update vertical deltas for use when processing next char.\n    pH <<= 1;\n    mH <<= 1;\n\n    mH |= hInIsNegative;\n    pH |= oneIfNotZero(hIn) - hInIsNegative; // Set pH[0] if hIn > 0.\n\n    pV = mH | ~(xV | pH);\n    mV = pH & xV;\n\n    ctx.P[b] = pV;\n    ctx.M[b] = mV;\n\n    return hOut;\n  }\n\n  /**\n   * Find the ends and error counts for matches of `pattern` in `text`.\n   *\n   * Only the matches with the lowest error count are reported. Other matches\n   * with error counts <= maxErrors are discarded.\n   *\n   * This is the block-based search algorithm from Fig. 9 on p.410 of [1].\n   *\n   * @param {string} text\n   * @param {string} pattern\n   * @param {array} maxErrors\n   * @return {obj} Matches with the `start` property set.\n   */\n  function findMatchEnds(text, pattern, maxErrors) {\n    if (pattern.length === 0) {\n      return [];\n    }\n\n    // Clamp error count so we can rely on the `maxErrors` and `pattern.length`\n    // rows being in the same block below.\n    maxErrors = Math.min(maxErrors, pattern.length);\n\n    const matches = [];\n\n    // Word size.\n    const w = 32;\n\n    // Index of maximum block level.\n    const bMax = Math.ceil(pattern.length / w) - 1;\n\n    // Context used across block calculations.\n    const ctx = {\n      P: new Uint32Array(bMax + 1),\n      M: new Uint32Array(bMax + 1),\n      lastRowMask: new Uint32Array(bMax + 1),\n    };\n    ctx.lastRowMask.fill(1 << 31);\n    ctx.lastRowMask[bMax] = 1 << (pattern.length - 1) % w;\n\n    // Dummy \"peq\" array for chars in the text which do not occur in the pattern.\n    const emptyPeq = new Uint32Array(bMax + 1);\n\n    // Map of UTF-16 character code to bit vector indicating positions in the\n    // pattern that equal that character.\n    const peq = new Map();\n\n    // Version of `peq` that only stores mappings for small characters. This\n    // allows faster lookups when iterating through the text because a simple\n    // array lookup can be done instead of a hash table lookup.\n    const asciiPeq = [];\n    for (let i = 0; i < 256; i++) {\n      asciiPeq.push(emptyPeq);\n    }\n\n    // Calculate `ctx.peq` - a map of character values to bitmasks indicating\n    // positions of that character within the pattern, where each bit represents\n    // a position in the pattern.\n    for (let c = 0; c < pattern.length; c += 1) {\n      const val = pattern.charCodeAt(c);\n      if (peq.has(val)) {\n        // Duplicate char in pattern.\n        continue;\n      }\n\n      const charPeq = new Uint32Array(bMax + 1);\n      peq.set(val, charPeq);\n      if (val < asciiPeq.length) {\n        asciiPeq[val] = charPeq;\n      }\n\n      for (let b = 0; b <= bMax; b += 1) {\n        charPeq[b] = 0;\n\n        // Set all the bits where the pattern matches the current char (ch).\n        // For indexes beyond the end of the pattern, always set the bit as if the\n        // pattern contained a wildcard char in that position.\n        for (let r = 0; r < w; r += 1) {\n          const idx = b * w + r;\n          if (idx >= pattern.length) {\n            continue;\n          }\n\n          const match = pattern.charCodeAt(idx) === val;\n          if (match) {\n            charPeq[b] |= 1 << r;\n          }\n        }\n      }\n    }\n\n    // Index of last-active block level in the column.\n    let y = Math.max(0, Math.ceil(maxErrors / w) - 1);\n\n    // Initialize maximum error count at bottom of each block.\n    const score = new Uint32Array(bMax + 1);\n    for (let b = 0; b <= y; b += 1) {\n      score[b] = (b + 1) * w;\n    }\n    score[bMax] = pattern.length;\n\n    // Initialize vertical deltas for each block.\n    for (let b = 0; b <= y; b += 1) {\n      ctx.P[b] = ~0;\n      ctx.M[b] = 0;\n    }\n\n    // Process each char of the text, computing the error count for `w` chars of\n    // the pattern at a time.\n    for (let j = 0; j < text.length; j += 1) {\n      // Lookup the bitmask representing the positions of the current char from\n      // the text within the pattern.\n      const charCode = text.charCodeAt(j);\n      let charPeq;\n\n      if (charCode < asciiPeq.length) {\n        // Fast array lookup.\n        charPeq = asciiPeq[charCode];\n      } else {\n        // Slower hash table lookup.\n        charPeq = peq.get(charCode);\n        if (typeof charPeq === \"undefined\") {\n          charPeq = emptyPeq;\n        }\n      }\n\n      // Calculate error count for blocks that we definitely have to process for\n      // this column.\n      let carry = 0;\n      for (let b = 0; b <= y; b += 1) {\n        carry = advanceBlock(ctx, charPeq, b, carry);\n        score[b] += carry;\n      }\n\n      // Check if we also need to compute an additional block, or if we can reduce\n      // the number of blocks processed for the next column.\n      if (\n        score[y] - carry <= maxErrors &&\n        y < bMax &&\n        (charPeq[y + 1] & 1 || carry < 0)\n      ) {\n        // Error count for bottom block is under threshold, increase the number of\n        // blocks processed for this column & next by 1.\n        y += 1;\n\n        ctx.P[y] = ~0;\n        ctx.M[y] = 0;\n\n        let maxBlockScore;\n        if (y === bMax) {\n          const remainder = pattern.length % w;\n          maxBlockScore = remainder === 0 ? w : remainder;\n        } else {\n          maxBlockScore = w;\n        }\n\n        score[y] =\n          score[y - 1] +\n          maxBlockScore -\n          carry +\n          advanceBlock(ctx, charPeq, y, carry);\n      } else {\n        // Error count for bottom block exceeds threshold, reduce the number of\n        // blocks processed for the next column.\n        while (y > 0 && score[y] >= maxErrors + w) {\n          y -= 1;\n        }\n      }\n\n      // If error count is under threshold, report a match.\n      if (y === bMax && score[y] <= maxErrors) {\n        if (score[y] < maxErrors) {\n          // Discard any earlier, worse matches.\n          matches.splice(0, matches.length);\n        }\n\n        matches.push({\n          start: -1,\n          end: j + 1,\n          errors: score[y],\n        });\n\n        // Because `search` only reports the matches with the lowest error count,\n        // we can \"ratchet down\" the max error threshold whenever a match is\n        // encountered and thereby save a small amount of work for the remainder\n        // of the text.\n        maxErrors = score[y];\n      }\n    }\n\n    return matches;\n  }\n\n  /**\n   * Search for matches for `pattern` in `text` allowing up to `maxErrors` errors.\n   *\n   * Returns the start, and end positions and error counts for each lowest-cost\n   * match. Only the \"best\" matches are returned.\n   * @param {string} text\n   * @param {string} pattern\n   * @param {array} maxErrors\n   * @return {obj} Matches with the `start` property set.\n   */\n  export default function search(\n    text,\n    pattern,\n    maxErrors\n  ) {\n    const matches = findMatchEnds(text, pattern, maxErrors);\n    return findMatchStarts(text, pattern, matches);\n  }"],"names":["reverse","s","split","join","oneIfNotZero","n","advanceBlock","ctx","peq","b","hIn","pV","P","mV","M","hInIsNegative","eq","xV","xH","pH","mH","hOut","lastRowMask","findMatchEnds","text","pattern","maxErrors","length","Math","min","matches","w","bMax","ceil","Uint32Array","fill","emptyPeq","Map","asciiPeq","i","push","c","val","charCodeAt","has","charPeq","set","r","idx","y","max","score","j","charCode","get","carry","maxBlockScore","remainder","splice","start","end","errors","patRev","map","m","minStart","slice","reduce","rm","findMatchStarts"],"mappings":"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"}