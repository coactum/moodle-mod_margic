{"version":3,"file":"text-range.min.js","sources":["../src/text-range.js"],"sourcesContent":["/**\n * Functions for handling text-ranges used by the other methods.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n * @return {string}\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // Nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n * @return {int}\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n\n    if (length + textNode.data.length > nextOffset) {\n      results.push({node: textNode, offset: nextOffset - length});\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && length === nextOffset) {\n    results.push({node: textNode, offset: textNode.data.length});\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return {node: text, offset: forwards ? 0 : text.data.length};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   * @return {Range}\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({direction: RESOLVE_FORWARDS});\n      end = this.end.resolve({direction: RESOLVE_BACKWARDS});\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   * @return {Range}\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n"],"names":["nodeTextLength","node","nodeType","Node","ELEMENT_NODE","TEXT_NODE","textContent","length","previousSiblingsTextLength","sibling","previousSibling","resolveOffsets","element","offsets","textNode","nextOffset","shift","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","results","currentNode","nextNode","undefined","data","push","offset","RangeError","TextPosition","Error","parent","contains","this","el","parentElement","options","err","direction","tw","document","createTreeWalker","getRootNode","forwards","text","previousNode","fromPoint","textOffset","childNodes","i","TextRange","start","end","relativeTo","resolve","range","Range","setStart","setEnd","startContainer","startOffset","endContainer","endOffset","root"],"mappings":"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"}