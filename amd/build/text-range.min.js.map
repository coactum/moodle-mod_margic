{"version":3,"file":"text-range.min.js","sources":["../src/text-range.js"],"sourcesContent":["/**\n * Functions for handling text-ranges used by the other methods.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n\n  console.log('text-range.js -> resolveOffsets');\n  console.log('element');\n  console.log(element);\n\n  console.log('offsets');\n  console.log(offsets);\n\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  console.log('nextOffset');\n  console.log(nextOffset);\n\n  console.log('currentNode');\n  console.log(currentNode);\n\n  console.log('offsets');\n  console.log(offsets);\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n    console.log('textNode');\n    console.log(textNode);\n    console.log('offsets');\n    console.log(offsets);\n    if (length + textNode.data.length > nextOffset) {\n      results.push({ node: textNode, offset: nextOffset - length });\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && textNode && length === nextOffset) {\n      console.log('boundary case');\n      console.log('nextOffset');\n      console.log(nextOffset);\n\n      console.log('textNode');\n      console.log(textNode);\n\n      console.log('length');\n      console.log(length);\n      console.log('offsets');\n  console.log(offsets);\n\n    results.push({ node: textNode, offset: textNode.data.length });\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    console.log('nextOffset');\n    console.log(nextOffset);\n    console.log('offsets');\n  console.log(offsets);\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  console.log('results');\n  console.log(results);\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return { node: text, offset: forwards ? 0 : text.data.length };\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({ direction: RESOLVE_FORWARDS });\n      end = this.end.resolve({ direction: RESOLVE_BACKWARDS });\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    // console.log('TextRange fromRange');\n    // console.log('range');\n    // console.log(range);\n    // console.log(range.startContainer);\n    // console.log(range.startOffset);\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n"],"names":["nodeTextLength","node","nodeType","Node","ELEMENT_NODE","TEXT_NODE","textContent","length","previousSiblingsTextLength","sibling","previousSibling","resolveOffsets","element","console","log","offsets","textNode","nextOffset","shift","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","results","currentNode","nextNode","undefined","data","push","offset","RangeError","TextPosition","Error","parent","contains","this","el","parentElement","options","err","direction","tw","document","createTreeWalker","getRootNode","forwards","text","previousNode","fromPoint","textOffset","childNodes","i","TextRange","start","end","relativeTo","resolve","range","Range","setStart","setEnd","startContainer","startOffset","endContainer","endOffset","root"],"mappings":"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"}