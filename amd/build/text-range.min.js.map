{"version":3,"sources":["../src/text-range.js"],"names":["nodeTextLength","node","nodeType","Node","ELEMENT_NODE","TEXT_NODE","textContent","length","previousSiblingsTextLength","sibling","previousSibling","resolveOffsets","element","offsets","nextOffset","shift","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","results","currentNode","nextNode","textNode","data","push","offset","RangeError","TextPosition","Error","parent","contains","el","parentElement","options","err","direction","tw","document","createTreeWalker","getRootNode","forwards","text","previousNode","fromPoint","textOffset","childNodes","i","TextRange","start","end","relativeTo","resolve","range","Range","setStart","setEnd","startContainer","startOffset","endContainer","endOffset","root"],"mappings":"49CAcA,QAASA,CAAAA,CAAT,CAAwBC,CAAxB,CAA8B,CAC5B,OAAQA,CAAI,CAACC,QAAb,EACE,IAAKC,CAAAA,IAAI,CAACC,YAAV,CACA,IAAKD,CAAAA,IAAI,CAACE,SAAV,CAIE,MAA8BJ,CAAAA,CAAI,CAACK,WAAN,CAAmBC,MAAhD,CACF,QACE,MAAO,EAAP,CARJ,CAUD,CAQD,QAASC,CAAAA,CAAT,CAAoCP,CAApC,CAA0C,IACpCQ,CAAAA,CAAO,CAAGR,CAAI,CAACS,eADqB,CAEpCH,CAAM,CAAG,CAF2B,CAIxC,MAAOE,CAAP,CAAgB,CACdF,CAAM,EAAIP,CAAc,CAACS,CAAD,CAAxB,CACAA,CAAO,CAAGA,CAAO,CAACC,eACnB,CAED,MAAOH,CAAAA,CACR,CAUD,QAASI,CAAAA,CAAT,CAAwBC,CAAxB,CAA6C,4BAATC,CAAS,+BAATA,CAAS,sBAEvCC,CAAAA,CAAU,CAAGD,CAAO,CAACE,KAAR,EAF0B,CAGrCC,CAAQ,CACZJ,CAAO,CAACK,aAD+B,CAEvCC,kBAFuC,CAEpBN,CAFoB,CAEXO,UAAU,CAACC,SAFA,CAHE,CAMrCC,CAAO,CAAG,EAN2B,CAQvCC,CAAW,CAAGN,CAAQ,CAACO,QAAT,EARyB,CASvCC,CATuC,CAUvCjB,CAAM,CAAG,CAV8B,CAc3C,MAAOO,CAAU,SAAV,EAA4BQ,CAAnC,CAAgD,CAC9CE,CAAQ,CAAwBF,CAAhC,CAEA,GAAIf,CAAM,CAAGiB,CAAQ,CAACC,IAAT,CAAclB,MAAvB,CAAgCO,CAApC,CAAgD,CAC9CO,CAAO,CAACK,IAAR,CAAa,CAACzB,IAAI,CAAEuB,CAAP,CAAiBG,MAAM,CAAEb,CAAU,CAAGP,CAAtC,CAAb,EACAO,CAAU,CAAGD,CAAO,CAACE,KAAR,EACd,CAHD,IAGO,CACLO,CAAW,CAAGN,CAAQ,CAACO,QAAT,EAAd,CACAhB,CAAM,EAAIiB,CAAQ,CAACC,IAAT,CAAclB,MACzB,CACF,CAGD,MAAOO,CAAU,SAAV,EAA4BP,CAAM,GAAKO,CAA9C,CAA0D,CACxDO,CAAO,CAACK,IAAR,CAAa,CAACzB,IAAI,CAAEuB,CAAP,CAAiBG,MAAM,CAAEH,CAAQ,CAACC,IAAT,CAAclB,MAAvC,CAAb,EACAO,CAAU,CAAGD,CAAO,CAACE,KAAR,EACd,CAED,GAAID,CAAU,SAAd,CAA8B,CAC5B,KAAM,IAAIc,CAAAA,UAAJ,CAAe,4BAAf,CACP,CAED,MAAOP,CAAAA,CACR,C,8CAWYQ,CAAAA,C,YAQX,WAAYjB,CAAZ,CAAqBe,CAArB,CAA6B,WAC3B,GAAa,CAAT,CAAAA,CAAJ,CAAgB,CACd,KAAM,IAAIG,CAAAA,KAAJ,CAAU,mBAAV,CACP,CAGD,KAAKlB,OAAL,CAAeA,CAAf,CAGA,KAAKe,MAAL,CAAcA,CACf,C,iDASUI,C,CAAQ,CACjB,GAAI,CAACA,CAAM,CAACC,QAAP,CAAgB,KAAKpB,OAArB,CAAL,CAAoC,CAClC,KAAM,IAAIkB,CAAAA,KAAJ,CAAU,8CAAV,CACP,CAHgB,GAKbG,CAAAA,CAAE,CAAG,KAAKrB,OALG,CAMbe,CAAM,CAAG,KAAKA,MAND,CAOjB,MAAOM,CAAE,GAAKF,CAAd,CAAsB,CACpBJ,CAAM,EAAInB,CAA0B,CAACyB,CAAD,CAApC,CACAA,CAAE,CAA2BA,CAAE,CAACC,aACjC,CAED,MAAO,IAAIL,CAAAA,CAAJ,CAAiBI,CAAjB,CAAqBN,CAArB,CACR,C,yCAoBqB,IAAdQ,CAAAA,CAAc,wDAAJ,EAAI,CACpB,GAAI,CACF,MAAOxB,CAAAA,CAAc,CAAC,KAAKC,OAAN,CAAe,KAAKe,MAApB,CAAd,CAA0C,CAA1C,CACR,CAAC,MAAOS,CAAP,CAAY,CACZ,GAAoB,CAAhB,QAAKT,MAAL,EAAqBQ,CAAO,CAACE,SAAR,SAAzB,CAA0D,CACxD,GAAMC,CAAAA,CAAE,CAAGC,QAAQ,CAACC,gBAAT,CACT,KAAK5B,OAAL,CAAa6B,WAAb,EADS,CAETtB,UAAU,CAACC,SAFF,CAAX,CAIAkB,CAAE,CAAChB,WAAH,CAAiB,KAAKV,OAAtB,CALwD,GAMlD8B,CAAAA,CAAQ,CAAGP,CAAO,CAACE,SAAR,IANuC,CAOlDM,CAAI,CACRD,CAAQ,CAAGJ,CAAE,CAACf,QAAH,EAAH,CAAmBe,CAAE,CAACM,YAAH,EAR2B,CAUxD,GAAI,CAACD,CAAL,CAAW,CACT,KAAMP,CAAAA,CACP,CACD,MAAO,CAACnC,IAAI,CAAE0C,CAAP,CAAahB,MAAM,CAAEe,CAAQ,CAAG,CAAH,CAAOC,CAAI,CAAClB,IAAL,CAAUlB,MAA9C,CACR,CAdD,IAcO,CACL,KAAM6B,CAAAA,CACP,CACF,CACF,C,wDAUqBnC,C,CAAM0B,C,CAAQ,CAClC,OAAQ1B,CAAI,CAACC,QAAb,EACE,IAAKC,CAAAA,IAAI,CAACE,SAAV,CACE,MAAOwB,CAAAA,CAAY,CAACgB,SAAb,CAAuB5C,CAAvB,CAA6B0B,CAA7B,CAAP,CACF,IAAKxB,CAAAA,IAAI,CAACC,YAAV,CACE,MAAO,IAAIyB,CAAAA,CAAJ,CAAyC5B,CAAzC,CAAgD0B,CAAhD,CAAP,CACF,QACE,KAAM,IAAIG,CAAAA,KAAJ,CAAU,qCAAV,CAAN,CANJ,CAQD,C,4CASgB7B,C,CAAM0B,C,CAAQ,CAE7B,OAAQ1B,CAAI,CAACC,QAAb,EACE,IAAKC,CAAAA,IAAI,CAACE,SAAV,CAAqB,CACnB,GAAa,CAAT,CAAAsB,CAAM,EAAQA,CAAM,CAAwB1B,CAAD,CAAOwB,IAAP,CAAYlB,MAA3D,CAAmE,CACjE,KAAM,IAAIuB,CAAAA,KAAJ,CAAU,kCAAV,CACP,CAED,GAAI,CAAC7B,CAAI,CAACiC,aAAV,CAAyB,CACvB,KAAM,IAAIJ,CAAAA,KAAJ,CAAU,yBAAV,CACP,CAGD,GAAMgB,CAAAA,CAAU,CAAGtC,CAA0B,CAACP,CAAD,CAA1B,CAAmC0B,CAAtD,CAEA,MAAO,IAAIE,CAAAA,CAAJ,CAAiB5B,CAAI,CAACiC,aAAtB,CAAqCY,CAArC,CACR,CACD,IAAK3C,CAAAA,IAAI,CAACC,YAAV,CAAwB,CACtB,GAAa,CAAT,CAAAuB,CAAM,EAAQA,CAAM,CAAG1B,CAAI,CAAC8C,UAAL,CAAgBxC,MAA3C,CAAmD,CACjD,KAAM,IAAIuB,CAAAA,KAAJ,CAAU,mCAAV,CACP,CAID,OADIgB,CAAAA,CAAU,CAAG,CACjB,CAASE,CAAC,CAAG,CAAb,CAAgBA,CAAC,CAAGrB,CAApB,CAA4BqB,CAAC,EAA7B,CAAiC,CAC/BF,CAAU,EAAI9C,CAAc,CAACC,CAAI,CAAC8C,UAAL,CAAgBC,CAAhB,CAAD,CAC7B,CAED,MAAO,IAAInB,CAAAA,CAAJ,CAAyC5B,CAAzC,CAAgD6C,CAAhD,CACR,CACD,QACE,KAAM,IAAIhB,CAAAA,KAAJ,CAAU,yCAAV,CAAN,CA7BJ,CA+BD,C,oCAUUmB,CAAAA,C,YAOX,WAAYC,CAAZ,CAAmBC,CAAnB,CAAwB,WACtB,KAAKD,KAAL,CAAaA,CAAb,CACA,KAAKC,GAAL,CAAWA,CACZ,C,iDASUvC,C,CAAS,CAClB,MAAO,IAAIqC,CAAAA,CAAJ,CACL,KAAKC,KAAL,CAAWE,UAAX,CAAsBxC,CAAtB,CADK,CAEL,KAAKuC,GAAL,CAASC,UAAT,CAAoBxC,CAApB,CAFK,CAIR,C,yCAaS,IACJsC,CAAAA,CADI,CAEJC,CAFI,CAIR,GACE,KAAKD,KAAL,CAAWtC,OAAX,GAAuB,KAAKuC,GAAL,CAASvC,OAAhC,EACA,KAAKsC,KAAL,CAAWvB,MAAX,EAAqB,KAAKwB,GAAL,CAASxB,MAFhC,CAGE,OAEehB,CAAc,CAC3B,KAAKuC,KAAL,CAAWtC,OADgB,CAE3B,KAAKsC,KAAL,CAAWvB,MAFgB,CAG3B,KAAKwB,GAAL,CAASxB,MAHkB,CAF7B,UAECuB,CAFD,MAEQC,CAFR,KAOD,CAVD,IAUO,CACLD,CAAK,CAAG,KAAKA,KAAL,CAAWG,OAAX,CAAmB,CAAChB,SAAS,EAAV,CAAnB,CAAR,CACAc,CAAG,CAAG,KAAKA,GAAL,CAASE,OAAT,CAAiB,CAAChB,SAAS,EAAV,CAAjB,CACP,CAED,GAAMiB,CAAAA,CAAK,CAAG,GAAIC,CAAAA,KAAlB,CACAD,CAAK,CAACE,QAAN,CAAeN,CAAK,CAACjD,IAArB,CAA2BiD,CAAK,CAACvB,MAAjC,EACA2B,CAAK,CAACG,MAAN,CAAaN,CAAG,CAAClD,IAAjB,CAAuBkD,CAAG,CAACxB,MAA3B,EACA,MAAO2B,CAAAA,CACR,C,8CAQgBA,C,CAAO,IAChBJ,CAAAA,CAAK,CAAGrB,CAAY,CAACgB,SAAb,CACZS,CAAK,CAACI,cADM,CAEZJ,CAAK,CAACK,WAFM,CADQ,CAKhBR,CAAG,CAAGtB,CAAY,CAACgB,SAAb,CAAuBS,CAAK,CAACM,YAA7B,CAA2CN,CAAK,CAACO,SAAjD,CALU,CAMtB,MAAO,IAAIZ,CAAAA,CAAJ,CAAcC,CAAd,CAAqBC,CAArB,CACR,C,gDAUkBW,C,CAAMZ,C,CAAOC,C,CAAK,CACnC,MAAO,IAAIF,CAAAA,CAAJ,CACL,GAAIpB,CAAAA,CAAJ,CAAiBiC,CAAjB,CAAuBZ,CAAvB,CADK,CAEL,GAAIrB,CAAAA,CAAJ,CAAiBiC,CAAjB,CAAuBX,CAAvB,CAFK,CAIR,C","sourcesContent":["/**\n * Functions for handling text-ranges used by the other methods.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n * @return {string}\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // Nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n * @return {int}\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n\n    if (length + textNode.data.length > nextOffset) {\n      results.push({node: textNode, offset: nextOffset - length});\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && length === nextOffset) {\n    results.push({node: textNode, offset: textNode.data.length});\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return {node: text, offset: forwards ? 0 : text.data.length};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   * @return {Range}\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({direction: RESOLVE_FORWARDS});\n      end = this.end.resolve({direction: RESOLVE_BACKWARDS});\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   * @return {Range}\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n"],"file":"text-range.min.js"}