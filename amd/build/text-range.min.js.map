{"version":3,"file":"text-range.min.js","sources":["../src/text-range.js"],"sourcesContent":["/**\n * Functions for handling text-ranges used by the other methods.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n * @return {string}\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // Nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n * @return {int}\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n\n    if (length + textNode.data.length > nextOffset) {\n      results.push({node: textNode, offset: nextOffset - length});\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && length === nextOffset) {\n    results.push({node: textNode, offset: textNode.data.length});\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return {node: text, offset: forwards ? 0 : text.data.length};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   * @return {Range}\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({direction: RESOLVE_FORWARDS});\n      end = this.end.resolve({direction: RESOLVE_BACKWARDS});\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   * @return {Range}\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n"],"names":["nodeTextLength","node","nodeType","Node","ELEMENT_NODE","TEXT_NODE","textContent","length","previousSiblingsTextLength","sibling","previousSibling","resolveOffsets","element","offsets","nextOffset","shift","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","results","textNode","currentNode","nextNode","undefined","data","push","offset","RangeError","TextPosition","constructor","Error","relativeTo","parent","contains","this","el","parentElement","resolve","options","err","direction","tw","document","createTreeWalker","getRootNode","forwards","text","previousNode","fromPoint","textOffset","childNodes","i","TextRange","start","end","toRange","range","Range","setStart","setEnd","startContainer","startOffset","endContainer","endOffset","root"],"mappings":"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"}