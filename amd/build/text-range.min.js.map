{"version":3,"file":"text-range.min.js","sources":["../src/text-range.js"],"sourcesContent":["/**\n * Functions for handling text-ranges used by the other methods.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\n/**\n * Return the combined length of text nodes contained in `node`.\n *\n * @param {Node} node\n * @return {string}\n */\nfunction nodeTextLength(node) {\n  switch (node.nodeType) {\n    case Node.ELEMENT_NODE:\n    case Node.TEXT_NODE:\n      // Nb. `textContent` excludes text in comments and processing instructions\n      // when called on a parent element, so we don't need to subtract that here.\n\n      return /** @type {string} */ (node.textContent).length;\n    default:\n      return 0;\n  }\n}\n\n/**\n * Return the total length of the text of all previous siblings of `node`.\n *\n * @param {Node} node\n * @return {int}\n */\nfunction previousSiblingsTextLength(node) {\n  let sibling = node.previousSibling;\n  let length = 0;\n\n  while (sibling) {\n    length += nodeTextLength(sibling);\n    sibling = sibling.previousSibling;\n  }\n\n  return length;\n}\n\n/**\n * Resolve one or more character offsets within an element to (text node, position)\n * pairs.\n *\n * @param {Element} element\n * @param {number[]} offsets - Offsets, which must be sorted in ascending order\n * @return {{ node: Text, offset: number }[]}\n */\nfunction resolveOffsets(element, ...offsets) {\n\n  let nextOffset = offsets.shift();\n  const nodeIter = /** @type {Document} */ (\n    element.ownerDocument\n  ).createNodeIterator(element, NodeFilter.SHOW_TEXT);\n  const results = [];\n\n  let currentNode = nodeIter.nextNode();\n  let textNode;\n  let length = 0;\n\n  // Find the text node containing the `nextOffset`th character from the start\n  // of `element`.\n  while (nextOffset !== undefined && currentNode) {\n    textNode = /** @type {Text} */ (currentNode);\n\n    if (length + textNode.data.length > nextOffset) {\n      results.push({node: textNode, offset: nextOffset - length});\n      nextOffset = offsets.shift();\n    } else {\n      currentNode = nodeIter.nextNode();\n      length += textNode.data.length;\n    }\n  }\n\n  // Boundary case.\n  while (nextOffset !== undefined && length === nextOffset) {\n    results.push({node: textNode, offset: textNode.data.length});\n    nextOffset = offsets.shift();\n  }\n\n  if (nextOffset !== undefined) {\n    throw new RangeError('Offset exceeds text length');\n  }\n\n  return results;\n}\n\nexport let RESOLVE_FORWARDS = 1;\nexport let RESOLVE_BACKWARDS = 2;\n\n/**\n * Represents an offset within the text content of an element.\n *\n * This position can be resolved to a specific descendant node in the current\n * DOM subtree of the element using the `resolve` method.\n */\nexport class TextPosition {\n  /**\n   * Construct a `TextPosition` that refers to the text position `offset` within\n   * the text content of `element`.\n   *\n   * @param {Element} element\n   * @param {number} offset\n   */\n  constructor(element, offset) {\n    if (offset < 0) {\n      throw new Error('Offset is invalid');\n    }\n\n    /** Element that `offset` is relative to. */\n    this.element = element;\n\n    /** Character offset from the start of the element's `textContent`. */\n    this.offset = offset;\n  }\n\n  /**\n   * Return a copy of this position with offset relative to a given ancestor\n   * element.\n   *\n   * @param {Element} parent - Ancestor of `this.element`\n   * @return {TextPosition}\n   */\n  relativeTo(parent) {\n    if (!parent.contains(this.element)) {\n      throw new Error('Parent is not an ancestor of current element');\n    }\n\n    let el = this.element;\n    let offset = this.offset;\n    while (el !== parent) {\n      offset += previousSiblingsTextLength(el);\n      el = /** @type {Element} */ (el.parentElement);\n    }\n\n    return new TextPosition(el, offset);\n  }\n\n  /**\n   * Resolve the position to a specific text node and offset within that node.\n   *\n   * Throws if `this.offset` exceeds the length of the element's text. In the\n   * case where the element has no text and `this.offset` is 0, the `direction`\n   * option determines what happens.\n   *\n   * Offsets at the boundary between two nodes are resolved to the start of the\n   * node that begins at the boundary.\n   *\n   * @param {Object} [options]\n   *   @param {RESOLVE_FORWARDS|RESOLVE_BACKWARDS} [options.direction] -\n   *     Specifies in which direction to search for the nearest text node if\n   *     `this.offset` is `0` and `this.element` has no text. If not specified\n   *     an error is thrown.\n   * @return {{ node: Text, offset: number }}\n   * @throws {RangeError}\n   */\n  resolve(options = {}) {\n    try {\n      return resolveOffsets(this.element, this.offset)[0];\n    } catch (err) {\n      if (this.offset === 0 && options.direction !== undefined) {\n        const tw = document.createTreeWalker(\n          this.element.getRootNode(),\n          NodeFilter.SHOW_TEXT\n        );\n        tw.currentNode = this.element;\n        const forwards = options.direction === RESOLVE_FORWARDS;\n        const text = /** @type {Text|null} */ (\n          forwards ? tw.nextNode() : tw.previousNode()\n        );\n        if (!text) {\n          throw err;\n        }\n        return {node: text, offset: forwards ? 0 : text.data.length};\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` that refers to the `offset`th character within\n   * `node`.\n   *\n   * @param {Node} node\n   * @param {number} offset\n   * @return {TextPosition}\n   */\n  static fromCharOffset(node, offset) {\n    switch (node.nodeType) {\n      case Node.TEXT_NODE:\n        return TextPosition.fromPoint(node, offset);\n      case Node.ELEMENT_NODE:\n        return new TextPosition(/** @type {Element} */ (node), offset);\n      default:\n        throw new Error('Node is not an element or text node');\n    }\n  }\n\n  /**\n   * Construct a `TextPosition` representing the range start or end point (node, offset).\n   *\n   * @param {Node} node - Text or Element node\n   * @param {number} offset - Offset within the node.\n   * @return {TextPosition}\n   */\n  static fromPoint(node, offset) {\n\n    switch (node.nodeType) {\n      case Node.TEXT_NODE: {\n        if (offset < 0 || offset > /** @type {Text} */ (node).data.length) {\n          throw new Error('Text node offset is out of range');\n        }\n\n        if (!node.parentElement) {\n          throw new Error('Text node has no parent');\n        }\n\n        // Get the offset from the start of the parent element.\n        const textOffset = previousSiblingsTextLength(node) + offset;\n\n        return new TextPosition(node.parentElement, textOffset);\n      }\n      case Node.ELEMENT_NODE: {\n        if (offset < 0 || offset > node.childNodes.length) {\n          throw new Error('Child node offset is out of range');\n        }\n\n        // Get the text length before the `offset`th child of element.\n        let textOffset = 0;\n        for (let i = 0; i < offset; i++) {\n          textOffset += nodeTextLength(node.childNodes[i]);\n        }\n\n        return new TextPosition(/** @type {Element} */ (node), textOffset);\n      }\n      default:\n        throw new Error('Point is not in an element or text node');\n    }\n  }\n}\n\n/**\n * Represents a region of a document as a (start, end) pair of `TextPosition` points.\n *\n * Representing a range in this way allows for changes in the DOM content of the\n * range which don't affect its text content, without affecting the text content\n * of the range itself.\n */\nexport class TextRange {\n  /**\n   * Construct an immutable `TextRange` from a `start` and `end` point.\n   *\n   * @param {TextPosition} start\n   * @param {TextPosition} end\n   */\n  constructor(start, end) {\n    this.start = start;\n    this.end = end;\n  }\n\n  /**\n   * Return a copy of this range with start and end positions relative to a\n   * given ancestor. See `TextPosition.relativeTo`.\n   *\n   * @param {Element} element\n   * @return {Range}\n   */\n  relativeTo(element) {\n    return new TextRange(\n      this.start.relativeTo(element),\n      this.end.relativeTo(element)\n    );\n  }\n\n  /**\n   * Resolve the `TextRange` to a DOM range.\n   *\n   * The resulting DOM Range will always start and end in a `Text` node.\n   * Hence `TextRange.fromRange(range).toRange()` can be used to \"shrink\" a\n   * range to the text it contains.\n   *\n   * May throw if the `start` or `end` positions cannot be resolved to a range.\n   *\n   * @return {Range}\n   */\n  toRange() {\n    let start;\n    let end;\n\n    if (\n      this.start.element === this.end.element &&\n      this.start.offset <= this.end.offset\n    ) {\n      // Fast path for start and end points in same element.\n      [start, end] = resolveOffsets(\n        this.start.element,\n        this.start.offset,\n        this.end.offset\n      );\n    } else {\n      start = this.start.resolve({direction: RESOLVE_FORWARDS});\n      end = this.end.resolve({direction: RESOLVE_BACKWARDS});\n    }\n\n    const range = new Range();\n    range.setStart(start.node, start.offset);\n    range.setEnd(end.node, end.offset);\n    return range;\n  }\n\n  /**\n   * Convert an existing DOM `Range` to a `TextRange`\n   *\n   * @param {Range} range\n   * @return {TextRange}\n   */\n  static fromRange(range) {\n    const start = TextPosition.fromPoint(\n      range.startContainer,\n      range.startOffset\n    );\n    const end = TextPosition.fromPoint(range.endContainer, range.endOffset);\n    return new TextRange(start, end);\n  }\n\n  /**\n   * Return a `TextRange` from the `start`th to `end`th characters in `root`.\n   *\n   * @param {Element} root\n   * @param {number} start\n   * @param {number} end\n   * @return {Range}\n   */\n  static fromOffsets(root, start, end) {\n    return new TextRange(\n      new TextPosition(root, start),\n      new TextPosition(root, end)\n    );\n  }\n}\n"],"names":["nodeTextLength","node","nodeType","Node","ELEMENT_NODE","TEXT_NODE","textContent","length","previousSiblingsTextLength","sibling","previousSibling","resolveOffsets","element","_len","arguments","offsets","Array","_key","nextOffset","shift","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","results","textNode","currentNode","nextNode","undefined","data","push","offset","RangeError","_exports","RESOLVE_FORWARDS","RESOLVE_BACKWARDS","TextPosition","constructor","Error","this","relativeTo","parent","contains","el","parentElement","resolve","options","err","direction","tw","document","createTreeWalker","getRootNode","forwards","text","previousNode","static","fromPoint","textOffset","childNodes","i","TextRange","start","end","toRange","range","Range","setStart","setEnd","startContainer","startOffset","endContainer","endOffset","root"],"mappings":"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"}