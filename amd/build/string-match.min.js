define("mod_margic/string-match",["exports"],(function(_exports){function reverse(s){return s.split("").reverse().join("")}function oneIfNotZero(n){return(n|-n)>>31&1}function advanceBlock(ctx,peq,b,hIn){let pV=ctx.P[b],mV=ctx.M[b];const hInIsNegative=hIn>>>31,eq=peq[b]|hInIsNegative,xV=eq|mV,xH=(eq&pV)+pV^pV|eq;let pH=mV|~(xH|pV),mH=pV&xH;const hOut=oneIfNotZero(pH&ctx.lastRowMask[b])-oneIfNotZero(mH&ctx.lastRowMask[b]);return pH<<=1,mH<<=1,mH|=hInIsNegative,pH|=oneIfNotZero(hIn)-hInIsNegative,pV=mH|~(xV|pH),mV=pH&xV,ctx.P[b]=pV,ctx.M[b]=mV,hOut}function findMatchEnds(text,pattern,maxErrors){if(0===pattern.length)return[];maxErrors=Math.min(maxErrors,pattern.length);const matches=[],w=32,bMax=Math.ceil(pattern.length/w)-1,ctx={P:new Uint32Array(bMax+1),M:new Uint32Array(bMax+1),lastRowMask:new Uint32Array(bMax+1)};ctx.lastRowMask.fill(1<<31),ctx.lastRowMask[bMax]=1<<(pattern.length-1)%w;const emptyPeq=new Uint32Array(bMax+1),peq=new Map,asciiPeq=[];for(let i=0;i<256;i++)asciiPeq.push(emptyPeq);for(let c=0;c<pattern.length;c+=1){const val=pattern.charCodeAt(c);if(peq.has(val))continue;const charPeq=new Uint32Array(bMax+1);peq.set(val,charPeq),val<asciiPeq.length&&(asciiPeq[val]=charPeq);for(let b=0;b<=bMax;b+=1){charPeq[b]=0;for(let r=0;r<w;r+=1){const idx=b*w+r;if(idx>=pattern.length)continue;pattern.charCodeAt(idx)===val&&(charPeq[b]|=1<<r)}}}let y=Math.max(0,Math.ceil(maxErrors/w)-1);const score=new Uint32Array(bMax+1);for(let b=0;b<=y;b+=1)score[b]=(b+1)*w;score[bMax]=pattern.length;for(let b=0;b<=y;b+=1)ctx.P[b]=-1,ctx.M[b]=0;for(let j=0;j<text.length;j+=1){const charCode=text.charCodeAt(j);let charPeq;charCode<asciiPeq.length?charPeq=asciiPeq[charCode]:(charPeq=peq.get(charCode),void 0===charPeq&&(charPeq=emptyPeq));let carry=0;for(let b=0;b<=y;b+=1)carry=advanceBlock(ctx,charPeq,b,carry),score[b]+=carry;if(score[y]-carry<=maxErrors&&y<bMax&&(1&charPeq[y+1]||carry<0)){let maxBlockScore;if(y+=1,ctx.P[y]=-1,ctx.M[y]=0,y===bMax){const remainder=pattern.length%w;maxBlockScore=0===remainder?w:remainder}else maxBlockScore=w;score[y]=score[y-1]+maxBlockScore-carry+advanceBlock(ctx,charPeq,y,carry)}else for(;y>0&&score[y]>=maxErrors+w;)y-=1;y===bMax&&score[y]<=maxErrors&&(score[y]<maxErrors&&matches.splice(0,matches.length),matches.push({start:-1,end:j+1,errors:score[y]}),maxErrors=score[y])}return matches}return Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=function(text,pattern,maxErrors){const matches=findMatchEnds(text,pattern,maxErrors);return function(text,pattern,matches){const patRev=reverse(pattern);return matches.map((m=>{const minStart=Math.max(0,m.end-pattern.length-m.errors);return{start:findMatchEnds(reverse(text.slice(minStart,m.end)),patRev,m.errors).reduce(((min,rm)=>m.end-rm.end<min?m.end-rm.end:min),m.end),end:m.end,errors:m.errors}}))}(text,pattern,matches)},_exports.default}));

//# sourceMappingURL=string-match.min.js.map