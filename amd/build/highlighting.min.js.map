{"version":3,"file":"highlighting.min.js","sources":["../src/highlighting.js"],"sourcesContent":["/**\n * Functions for the highlighting and anchoring of annotations.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport $ from 'jquery';\nimport {RangeAnchor, TextPositionAnchor, TextQuoteAnchor} from './types';\nimport {TextRange} from './text-range';\n\n/**\n * Get anchors for new annnotation.\n *\n * @param {Element} root\n * @param {Range} range\n * @return {object} - Array with the anchors.\n */\nexport function describe(root, range) {\n    const types = [RangeAnchor, TextPositionAnchor, TextQuoteAnchor];\n    const result = [];\n\n    // console.log('describe');\n\n    for (let type of types) {\n      try {\n        const anchor = type.fromRange(root, range);\n\n        // console.log('type');\n        // console.log(type);\n        // console.log('anchor');\n        // console.log(anchor);\n\n        result.push(anchor.toSelector());\n      } catch (error) {\n        continue;\n      }\n    }\n    return result;\n}\n\n/**\n * Anchor an annotation's selectors in the document.\n *\n * _Anchoring_ resolves a set of selectors to a concrete region of the document\n * which is then highlighted.\n *\n * Any existing anchors associated with `annotation` will be removed before\n * re-anchoring the annotation.\n *\n * @param {AnnotationData} annotation\n * @param {obj} root\n * @return {obj} achor object\n */\n export function anchor(annotation, root) {\n    // console.log('anchor');\n    // console.log('annotation');\n    // console.log(annotation);\n\n    /**\n     * Resolve an annotation's selectors to a concrete range.\n     *\n     * @param {Target} target\n     * @return {obj}\n     */\n    const locate = target => {\n\n        // console.log('anchor -> locate');\n        // console.log('target');\n        // console.log(target);\n\n      // Only annotations with an associated quote can currently be anchored.\n      // This is because the quote is used to verify anchoring with other selector\n      // types.\n      if (\n        !target.selector ||\n        !target.selector.some(s => s.type === 'TextQuoteSelector')\n      ) {\n        return {annotation, target};\n      }\n\n      /** @type {Anchor} */\n      let anchor;\n      try {\n        const range = htmlAnchor(root, target.selector);\n        // Convert the `Range` to a `TextRange` which can be converted back to\n        // a `Range` later. The `TextRange` representation allows for highlights\n        // to be inserted during anchoring other annotations without \"breaking\"\n        // this anchor.\n        // console.log('anchor -> locate -> after htmlAnchor');\n        // console.log('result of htmlAnchor');\n        // console.log(range);\n        const textRange = TextRange.fromRange(range);\n        // console.log('range for anchor');\n        // console.log('textRange');\n        // console.log(textRange);\n\n        anchor = { annotation, target, range: textRange };\n\n        // console.log('anchor found');\n        // console.log(anchor);\n      } catch (err) {\n        // console.log('Error in try to find textrange');\n        // console.log(err);\n        anchor = { annotation, target };\n      }\n\n    //   console.log('anchor at the end of anchor -> locate');\n    //   console.log(anchor);\n      return anchor;\n    };\n\n    /**\n     * Highlight the text range that `anchor` refers to.\n     *\n     * @param {Anchor} anchor\n     */\n    const highlight = anchor => {\n        // console.log('highlight');\n        // console.log('highlight resolveAnchor');\n      const range = resolveAnchor(anchor);\n    //   console.log('range');\n    //   console.log(range);\n\n      if (!range) {\n        // console.log('no range');\n        return;\n      }\n\n    //   console.log('highlight after resolveAnchor');\n    //   console.log('range');\n    //   console.log(range);\n\n    //   console.log('annotation');\n    //   console.log(annotation);\n\n      let highlights = [];\n\n      if (annotation.annotation) {\n        highlights = highlightRange(range, annotation.annotation.id, 'annotated', annotation.annotation.color);\n      } else {\n        highlights = highlightRange(range, false, 'annotated_temp');\n      }\n\n    //   console.log('highlights after i should have highlighted range');\n    //   console.log(highlights);\n\n      highlights.forEach(h => {\n        h._annotation = anchor.annotation;\n      });\n      anchor.highlights = highlights;\n\n    //   if (this._focusedAnnotations.has(anchor.annotation.$tag)) {\n    //     setHighlightsFocused(highlights, true);\n    //   }\n    };\n\n    // Remove existing anchors for this annotation.\n    // this.detach(annotation, false /* notify */); // To be replaced by own method\n\n    // Resolve selectors to ranges and insert highlights.\n    if (!annotation.target) {\n      annotation.target = [];\n    }\n    const anchors = annotation.target.map(locate);\n    // console.log('anchors after locate');\n    // console.log(anchors);\n\n    for (let anchor of anchors) {\n        // console.log('before highlighting anchor');\n        // console.log('anchor');\n        // console.log(anchor);\n        highlight(anchor);\n        // console.log('after highlighting anchor');\n    }\n\n    // Set flag indicating whether anchoring succeeded. For each target,\n    // anchoring is successful either if there are no selectors (ie. this is a\n    // Page Note) or we successfully resolved the selectors to a range.\n    annotation.$orphan =\n      anchors.length > 0 &&\n      anchors.every(anchor => anchor.target.selector && !anchor.range);\n\n    // console.log('anchor ends');\n    // console.log('anchors');\n    // console.log(anchors);\n    return anchors;\n}\n\n/**\n * Resolve an anchor's associated document region to a concrete `Range`.\n *\n * This may fail if anchoring failed or if the document has been mutated since\n * the anchor was created in a way that invalidates the anchor.\n *\n * @param {Anchor} anchor\n * @return {Range|null}\n */\nfunction resolveAnchor(anchor) {\n    // console.log('resolveAnchor');\n    // console.log('anchor');\n    // console.log(anchor);\n\n    if (!anchor.range) {\n      return null;\n    }\n    try {\n      return anchor.range.toRange();\n    } catch {\n      return null;\n    }\n}\n\n/**\n * Wraps the DOM Nodes within the provided range with a highlight\n * element of the specified class and returns the highlight Elements.\n *\n * Modified for handling annotations.\n *\n * @param {Range} range - Range to be highlighted\n * @param {int} annotationid - ID of annotation\n * @param {string} cssClass - A CSS class to use for the highlight\n * @param {string} color - Color of the highlighting\n * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n */\n function highlightRange(range, annotationid = false, cssClass = 'annotated', color = 'FFFF00') {\n    // console.log('highlightRange');\n    // console.log('range');\n    // console.log(range);\n\n    const textNodes = wholeTextNodesInRange(range);\n\n    // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n    // adjacent, we only need to create one highlight element for the group.\n    let textNodeSpans = [];\n    let prevNode = null;\n    let currentSpan = null;\n\n    textNodes.forEach(node => {\n        if (prevNode && prevNode.nextSibling === node) {\n            currentSpan.push(node);\n        } else {\n            currentSpan = [node];\n            textNodeSpans.push(currentSpan);\n        }\n        prevNode = node;\n    });\n\n    // Filter out text node spans that consist only of white space. This avoids\n    // inserting highlight elements in places that can only contain a restricted\n    // subset of nodes such as table rows and lists.\n    const whitespace = /^\\s*$/;\n    textNodeSpans = textNodeSpans.filter(span =>\n        // Check for at least one text node with non-space content.\n        span.some(node => !whitespace.test(node.nodeValue))\n    );\n\n    // Wrap each text node span with a `<span>` element.\n    const highlights = /** @type {HighlightElement[]} */ ([]);\n\n    textNodeSpans.forEach(nodes => {\n        const highlightEl = document.createElement('margic-highlight');\n        highlightEl.className = cssClass;\n\n        if (annotationid) {\n            highlightEl.className += ' ' + cssClass + '-' + annotationid;\n            highlightEl.style = \"text-decoration:underline; text-decoration-color: #\" + color;\n            highlightEl.id = cssClass + '-' + annotationid;\n            highlightEl.style.backgroundColor = '#' + color;\n        }\n\n        const parent = /** @type {Node} */ (nodes[0].parentNode);\n        parent.replaceChild(highlightEl, nodes[0]);\n        nodes.forEach(node => highlightEl.appendChild(node));\n\n        highlights.push(highlightEl);\n\n    });\n\n    return highlights;\n}\n\n/**\n * Return text nodes which are entirely inside `range`.\n *\n * If a range starts or ends part-way through a text node, the node is split\n * and the part inside the range is returned.\n *\n * @param {Range} range\n * @return {Text[]}\n */\n function wholeTextNodesInRange(range) {\n    if (range.collapsed) {\n        // Exit early for an empty range to avoid an edge case that breaks the algorithm\n        // below. Splitting a text node at the start of an empty range can leave the\n        // range ending in the left part rather than the right part.\n        return [];\n    }\n\n    /** @type {Node|null} */\n    let root = range.commonAncestorContainer;\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        // If the common ancestor is not an element, set it to the parent element to\n        // ensure that the loop below visits any text nodes generated by splitting\n        // the common ancestor.\n        //\n        // Note that `parentElement` may be `null`.\n        root = root.parentElement;\n    }\n\n    if (!root) {\n        // If there is no root element then we won't be able to insert highlights,\n        // so exit here.\n        return [];\n    }\n\n    const textNodes = [];\n    const nodeIter = /** @type {Document} */ (\n       root.ownerDocument\n    ).createNodeIterator(\n        root,\n        NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n    );\n    let node;\n    while ((node = nodeIter.nextNode())) {\n        if (!isNodeInRange(range, node)) {\n           continue;\n        }\n        let text = /** @type {Text} */ (node);\n\n        if (text === range.startContainer && range.startOffset > 0) {\n            // Split `text` where the range starts. The split will create a new `Text`\n           // node which will be in the range and will be visited in the next loop iteration.\n           text.splitText(range.startOffset);\n           continue;\n        }\n\n        if (text === range.endContainer && range.endOffset < text.data.length) {\n            // Split `text` where the range ends, leaving it as the part in the range.\n           text.splitText(range.endOffset);\n       }\n\n       textNodes.push(text);\n    }\n\n    return textNodes;\n}\n\n/**\n * Returns true if any part of `node` lies within `range`.\n *\n * @param {Range} range\n * @param {Node} node\n * @return {bool} - If node is in range\n */\nfunction isNodeInRange(range, node) {\n    try {\n        const length = node.nodeValue?.length ?? node.childNodes.length;\n       return (\n           // Check start of node is before end of range.\n           range.comparePoint(node, 0) <= 0 &&\n           // Check end of node is after start of range.\n           range.comparePoint(node, length) >= 0\n       );\n    } catch (e) {\n        // `comparePoint` may fail if the `range` and `node` do not share a common\n       // ancestor or `node` is a doctype.\n       return false;\n   }\n}\n\n/**\n * @param {RangeAnchor|TextPositionAnchor|TextQuoteAnchor} anchor\n * @param {Object} [options]\n * @return {obj} - range\n */\n function querySelector(anchor, options = {}) {\n    // console.log('querySelector');\n    // console.log('anchor');\n    // console.log(anchor);\n    // console.log('options');\n    // console.log(options);\n\n    return anchor.toRange(options);\n}\n\n/**\n * Anchor a set of selectors.\n *\n * This function converts a set of selectors into a document range.\n * It encapsulates the core anchoring algorithm, using the selectors alone or\n * in combination to establish the best anchor within the document.\n *\n * @param {Element} root - The root element of the anchoring context.\n * @param {Selector[]} selectors - The selectors to try.\n * @param {Object} [options]\n * @return {object} the query selector\n */\n function htmlAnchor(root, selectors, options = {}) {\n    let position = null;\n    let quote = null;\n    let range = null;\n\n    // console.log('html.js -> anchor() -> selectors');\n    // console.log(selectors);\n\n    // console.log('htmlAnchor()');\n\n    // Collect all the selectors\n    for (let selector of selectors) {\n      switch (selector.type) {\n        case 'TextPositionSelector':\n          position = selector;\n          options.hint = position.start; // TextQuoteAnchor hint\n          break;\n        case 'TextQuoteSelector':\n          quote = selector;\n          break;\n        case 'RangeSelector':\n          range = selector;\n          break;\n      }\n    }\n\n    /**\n     * Assert the quote matches the stored quote, if applicable\n     * @param {Range} range\n     * @return {Range} range\n     */\n    const maybeAssertQuote = range => {\n        // console.log('maybeAssertQuote');\n        // console.log('range');\n        // console.log(range);\n        // console.log('quote');\n        // console.log(quote);\n      if (quote?.exact && range.toString() !== quote.exact) {\n        throw new Error('quote mismatch');\n      } else {\n        // console.log('range found!');\n        // console.log(range);\n        return range;\n      }\n    };\n\n    let queryselector = false;\n\n    try {\n        if (range) {\n            // console.log('html.js -> anchor() range RangeAnchor.fromSelector');\n\n          let anchor = RangeAnchor.fromSelector(root, range);\n\n        //   console.log('anchor');\n        //   console.log(anchor);\n\n          queryselector = querySelector(anchor, options);\n\n          if (queryselector) {\n\n            // console.log('htmlAnchor queryselector for RangeAnchor');\n            // console.log(queryselector);\n\n            return queryselector;\n          } else {\n            return maybeAssertQuote;\n          }\n        }\n    } catch (error) {\n        try {\n            if (position) {\n\n                // console.log('html.js -> anchor() position TextPositionAnchor.fromSelector');\n\n                // console.log('position');\n\n                let anchor = TextPositionAnchor.fromSelector(root, position);\n\n                queryselector = querySelector(anchor, options);\n                if (queryselector) {\n\n                    // console.log('htmlAnchor queryselector for TextPositionAnchor');\n                    // console.log(queryselector);\n                    return queryselector;\n                  } else {\n                    return maybeAssertQuote;\n                  }\n            }\n        } catch (error) {\n            try {\n                if (quote) {\n\n                    // console.log('html.js -> anchor() quote TextQuoteAnchor.fromSelector');\n\n                    // console.log('quote');\n                    // console.log('htmlAnchor queryselector for TextQuoteAnchor');\n\n                    let anchor = TextQuoteAnchor.fromSelector(root, quote);\n\n                    queryselector = querySelector(anchor, options);\n\n                    // console.log(queryselector);\n\n                    return queryselector;\n                }\n            } catch (error) {\n                return false;\n            }\n        }\n    }\n}\n\n/**\n * Remove all temporary highlights under a given root element.\n */\n export function removeAllTempHighlights() {\n    const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n    if (highlights !== undefined && highlights.length != 0) {\n        removeHighlights(highlights);\n    }\n}\n\n/**\n * Remove highlights from a range previously highlighted with `highlightRange`.\n *\n * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n */\n function removeHighlights(highlights) {\n\n    // console.log('removeHighlights highlights');\n    // console.log(highlights);\n\n    for (var i = 0; i < highlights.length; i++) {\n        if (highlights[i].parentNode) {\n            //var pn = highlights[i].parentNode;\n            const children = Array.from(highlights[i].childNodes);\n            replaceWith(highlights[i], children);\n            //pn.normalize(); // To Be removed?\n        }\n    }\n}\n\n/**\n * Replace a child `node` with `replacements`.\n *\n * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n *\n * @param {ChildNode} node\n * @param {Node[]} replacements\n */\nfunction replaceWith(node, replacements) {\n    const parent = /** @type {Node} */ (node.parentNode);\n\n    replacements.forEach(r => parent.insertBefore(r, node));\n    node.remove();\n}"],"names":["highlightRange","range","annotationid","cssClass","color","textNodes","wholeTextNodesInRange","textNodeSpans","prevNode","currentSpan","forEach","node","nextSibling","push","whitespace","filter","span","some","test","nodeValue","highlights","nodes","highlightEl","document","createElement","className","style","id","backgroundColor","parentNode","replaceChild","appendChild","collapsed","root","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","nextNode","isNodeInRange","text","startContainer","startOffset","splitText","endContainer","endOffset","data","length","_node$nodeValue","childNodes","comparePoint","e","querySelector","anchor","options","toRange","replaceWith","replacements","parent","r","insertBefore","remove","annotation","highlight","resolveAnchor","h","_annotation","target","anchors","map","selector","s","type","selectors","position","quote","hint","start","maybeAssertQuote","exact","toString","Error","RangeAnchor","fromSelector","error","TextPositionAnchor","TextQuoteAnchor","htmlAnchor","textRange","TextRange","fromRange","err","$orphan","every","types","result","toSelector","Array","from","querySelectorAll","undefined","i","children","removeHighlights"],"mappings":"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"}