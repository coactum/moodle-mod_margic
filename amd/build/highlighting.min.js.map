{"version":3,"file":"highlighting.min.js","sources":["../src/highlighting.js"],"sourcesContent":["/**\n * Functions for the highlighting and anchoring of annotations.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport $ from 'jquery';\nimport {RangeAnchor, TextPositionAnchor, TextQuoteAnchor} from './types';\nimport {TextRange} from './text-range';\n\n/**\n * Get anchors for new annnotation.\n *\n * @param {Element} root\n * @param {Range} range\n * @return {object} - Array with the anchors.\n */\nexport function describe(root, range) {\n    const types = [RangeAnchor, TextPositionAnchor, TextQuoteAnchor];\n    const result = [];\n\n    for (let type of types) {\n      try {\n        const anchor = type.fromRange(root, range);\n\n        result.push(anchor.toSelector());\n      } catch (error) {\n        continue;\n      }\n    }\n    return result;\n}\n\n/**\n * Anchor an annotation's selectors in the document.\n *\n * _Anchoring_ resolves a set of selectors to a concrete region of the document\n * which is then highlighted.\n *\n * Any existing anchors associated with `annotation` will be removed before\n * re-anchoring the annotation.\n *\n * @param {AnnotationData} annotation\n * @param {obj} root\n * @return {obj} achor object\n */\n export function anchor(annotation, root) {\n    /**\n     * Resolve an annotation's selectors to a concrete range.\n     *\n     * @param {Target} target\n     * @return {obj}\n     */\n    const locate = target => {\n\n      // Only annotations with an associated quote can currently be anchored.\n      // This is because the quote is used to verify anchoring with other selector\n      // types.\n      if (\n        !target.selector ||\n        !target.selector.some(s => s.type === 'TextQuoteSelector')\n      ) {\n        return {annotation, target};\n      }\n\n      /** @type {Anchor} */\n      let anchor;\n      try {\n        const range = htmlAnchor(root, target.selector);\n        // Convert the `Range` to a `TextRange` which can be converted back to\n        // a `Range` later. The `TextRange` representation allows for highlights\n        // to be inserted during anchoring other annotations without \"breaking\"\n        // this anchor.\n\n\n        const textRange = TextRange.fromRange(range);\n\n        anchor = {annotation, target, range: textRange};\n\n      } catch (err) {\n\n        anchor = {annotation, target};\n      }\n\n      return anchor;\n    };\n\n    /**\n     * Highlight the text range that `anchor` refers to.\n     *\n     * @param {Anchor} anchor\n     */\n    const highlight = anchor => {\n\n      const range = resolveAnchor(anchor);\n\n      if (!range) {\n        return;\n      }\n\n      let highlights = [];\n\n      if (annotation.annotation) {\n        highlights = highlightRange(range, annotation.annotation.id, 'annotated', annotation.annotation.color);\n      } else {\n        highlights = highlightRange(range, false, 'annotated_temp');\n      }\n\n      highlights.forEach(h => {\n        h._annotation = anchor.annotation;\n      });\n      anchor.highlights = highlights;\n\n    };\n\n    // Remove existing anchors for this annotation.\n    // this.detach(annotation, false /* notify */); // To be replaced by own method\n\n    // Resolve selectors to ranges and insert highlights.\n    if (!annotation.target) {\n      annotation.target = [];\n    }\n    const anchors = annotation.target.map(locate);\n\n    for (let anchor of anchors) {\n\n        highlight(anchor);\n    }\n\n    // Set flag indicating whether anchoring succeeded. For each target,\n    // anchoring is successful either if there are no selectors (ie. this is a\n    // Page Note) or we successfully resolved the selectors to a range.\n    annotation.$orphan =\n      anchors.length > 0 &&\n      anchors.every(anchor => anchor.target.selector && !anchor.range);\n\n    return anchors;\n}\n\n/**\n * Resolve an anchor's associated document region to a concrete `Range`.\n *\n * This may fail if anchoring failed or if the document has been mutated since\n * the anchor was created in a way that invalidates the anchor.\n *\n * @param {Anchor} anchor\n * @return {Range|null}\n */\nfunction resolveAnchor(anchor) {\n\n    if (!anchor.range) {\n      return null;\n    }\n    try {\n      return anchor.range.toRange();\n    } catch {\n      return null;\n    }\n}\n\n/**\n * Wraps the DOM Nodes within the provided range with a highlight\n * element of the specified class and returns the highlight Elements.\n *\n * Modified for handling annotations.\n *\n * @param {Range} range - Range to be highlighted\n * @param {int} annotationid - ID of annotation\n * @param {string} cssClass - A CSS class to use for the highlight\n * @param {string} color - Color of the highlighting\n * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n */\n function highlightRange(range, annotationid = false, cssClass = 'annotated', color = 'FFFF00') {\n\n    const textNodes = wholeTextNodesInRange(range);\n\n    // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n    // adjacent, we only need to create one highlight element for the group.\n    let textNodeSpans = [];\n    let prevNode = null;\n    let currentSpan = null;\n\n    textNodes.forEach(node => {\n        if (prevNode && prevNode.nextSibling === node) {\n            currentSpan.push(node);\n        } else {\n            currentSpan = [node];\n            textNodeSpans.push(currentSpan);\n        }\n        prevNode = node;\n    });\n\n    // Filter out text node spans that consist only of white space. This avoids\n    // inserting highlight elements in places that can only contain a restricted\n    // subset of nodes such as table rows and lists.\n    const whitespace = /^\\s*$/;\n    textNodeSpans = textNodeSpans.filter(span =>\n        // Check for at least one text node with non-space content.\n        span.some(node => !whitespace.test(node.nodeValue))\n    );\n\n    // Wrap each text node span with a `<span>` element.\n    const highlights = /** @type {HighlightElement[]} */ ([]);\n\n    textNodeSpans.forEach(nodes => {\n        const highlightEl = document.createElement('margic-highlight');\n        highlightEl.className = cssClass;\n\n        if (annotationid) {\n            highlightEl.className += ' ' + cssClass + '-' + annotationid;\n            highlightEl.style = \"text-decoration:underline; text-decoration-color: #\" + color;\n            highlightEl.id = cssClass + '-' + annotationid;\n            highlightEl.style.backgroundColor = '#' + color;\n        }\n\n        const parent = /** @type {Node} */ (nodes[0].parentNode);\n        parent.replaceChild(highlightEl, nodes[0]);\n        nodes.forEach(node => highlightEl.appendChild(node));\n\n        highlights.push(highlightEl);\n\n    });\n\n    return highlights;\n}\n\n/**\n * Return text nodes which are entirely inside `range`.\n *\n * If a range starts or ends part-way through a text node, the node is split\n * and the part inside the range is returned.\n *\n * @param {Range} range\n * @return {Text[]}\n */\n function wholeTextNodesInRange(range) {\n    if (range.collapsed) {\n        // Exit early for an empty range to avoid an edge case that breaks the algorithm\n        // below. Splitting a text node at the start of an empty range can leave the\n        // range ending in the left part rather than the right part.\n        return [];\n    }\n\n    /** @type {Node|null} */\n    let root = range.commonAncestorContainer;\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        // If the common ancestor is not an element, set it to the parent element to\n        // ensure that the loop below visits any text nodes generated by splitting\n        // the common ancestor.\n        //\n        // Note that `parentElement` may be `null`.\n        root = root.parentElement;\n    }\n\n    if (!root) {\n        // If there is no root element then we won't be able to insert highlights,\n        // so exit here.\n        return [];\n    }\n\n    const textNodes = [];\n    const nodeIter = /** @type {Document} */ (\n       root.ownerDocument\n    ).createNodeIterator(\n        root,\n        NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n    );\n    let node;\n    while ((node = nodeIter.nextNode())) {\n        if (!isNodeInRange(range, node)) {\n           continue;\n        }\n        let text = /** @type {Text} */ (node);\n\n        if (text === range.startContainer && range.startOffset > 0) {\n            // Split `text` where the range starts. The split will create a new `Text`\n           // node which will be in the range and will be visited in the next loop iteration.\n           text.splitText(range.startOffset);\n           continue;\n        }\n\n        if (text === range.endContainer && range.endOffset < text.data.length) {\n            // Split `text` where the range ends, leaving it as the part in the range.\n           text.splitText(range.endOffset);\n       }\n\n       textNodes.push(text);\n    }\n\n    return textNodes;\n}\n\n/**\n * Returns true if any part of `node` lies within `range`.\n *\n * @param {Range} range\n * @param {Node} node\n * @return {bool} - If node is in range\n */\nfunction isNodeInRange(range, node) {\n    try {\n        const length = node.nodeValue?.length ?? node.childNodes.length;\n       return (\n           // Check start of node is before end of range.\n           range.comparePoint(node, 0) <= 0 &&\n           // Check end of node is after start of range.\n           range.comparePoint(node, length) >= 0\n       );\n    } catch (e) {\n        // `comparePoint` may fail if the `range` and `node` do not share a common\n       // ancestor or `node` is a doctype.\n       return false;\n   }\n}\n\n/**\n * @param {RangeAnchor|TextPositionAnchor|TextQuoteAnchor} anchor\n * @param {Object} [options]\n * @return {obj} - range\n */\n function querySelector(anchor, options = {}) {\n\n    return anchor.toRange(options);\n}\n\n/**\n * Anchor a set of selectors.\n *\n * This function converts a set of selectors into a document range.\n * It encapsulates the core anchoring algorithm, using the selectors alone or\n * in combination to establish the best anchor within the document.\n *\n * @param {Element} root - The root element of the anchoring context.\n * @param {Selector[]} selectors - The selectors to try.\n * @param {Object} [options]\n * @return {object} the query selector\n */\n function htmlAnchor(root, selectors, options = {}) {\n    let position = null;\n    let quote = null;\n    let range = null;\n\n    // Collect all the selectors\n    for (let selector of selectors) {\n      switch (selector.type) {\n        case 'TextPositionSelector':\n          position = selector;\n          options.hint = position.start; // TextQuoteAnchor hint\n          break;\n        case 'TextQuoteSelector':\n          quote = selector;\n          break;\n        case 'RangeSelector':\n          range = selector;\n          break;\n      }\n    }\n\n    /**\n     * Assert the quote matches the stored quote, if applicable\n     * @param {Range} range\n     * @return {Range} range\n     */\n    const maybeAssertQuote = range => {\n\n      if (quote?.exact && range.toString() !== quote.exact) {\n        throw new Error('quote mismatch');\n      } else {\n        return range;\n      }\n    };\n\n    let queryselector = false;\n\n    try {\n        if (range) {\n\n          let anchor = RangeAnchor.fromSelector(root, range);\n\n          queryselector = querySelector(anchor, options);\n\n          if (queryselector) {\n            return queryselector;\n          } else {\n            return maybeAssertQuote;\n          }\n        }\n    } catch (error) {\n        try {\n            if (position) {\n\n                let anchor = TextPositionAnchor.fromSelector(root, position);\n\n                queryselector = querySelector(anchor, options);\n                if (queryselector) {\n                    return queryselector;\n                  } else {\n                    return maybeAssertQuote;\n                  }\n            }\n        } catch (error) {\n            try {\n                if (quote) {\n\n                    let anchor = TextQuoteAnchor.fromSelector(root, quote);\n\n                    queryselector = querySelector(anchor, options);\n\n                    return queryselector;\n                }\n            } catch (error) {\n                return false;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Remove all temporary highlights under a given root element.\n */\n export function removeAllTempHighlights() {\n    const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n    if (highlights !== undefined && highlights.length != 0) {\n        removeHighlights(highlights);\n    }\n}\n\n/**\n * Remove highlights from a range previously highlighted with `highlightRange`.\n *\n * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n */\n function removeHighlights(highlights) {\n\n    for (var i = 0; i < highlights.length; i++) {\n        if (highlights[i].parentNode) {\n            const children = Array.from(highlights[i].childNodes);\n            replaceWith(highlights[i], children);\n        }\n    }\n}\n\n/**\n * Replace a child `node` with `replacements`.\n *\n * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n *\n * @param {ChildNode} node\n * @param {Node[]} replacements\n */\nfunction replaceWith(node, replacements) {\n    const parent = /** @type {Node} */ (node.parentNode);\n\n    replacements.forEach(r => parent.insertBefore(r, node));\n    node.remove();\n}"],"names":["obj","highlightRange","range","annotationid","arguments","length","undefined","cssClass","color","textNodes","collapsed","root","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","node","nextNode","isNodeInRange","text","startContainer","startOffset","splitText","endContainer","endOffset","data","push","wholeTextNodesInRange","textNodeSpans","prevNode","currentSpan","forEach","nextSibling","whitespace","filter","span","some","test","nodeValue","highlights","nodes","highlightEl","document","createElement","className","style","id","backgroundColor","parentNode","replaceChild","appendChild","_node$nodeValue$lengt","_node$nodeValue","childNodes","comparePoint","e","querySelector","anchor","options","toRange","replaceWith","replacements","parent","r","insertBefore","remove","annotation","highlight","resolveAnchor","h","_annotation","target","anchors","map","selector","s","type","selectors","position","quote","hint","start","maybeAssertQuote","_quote","exact","toString","Error","queryselector","RangeAnchor","fromSelector","error","TextPositionAnchor","TextQuoteAnchor","htmlAnchor","textRange","TextRange","fromRange","err","$orphan","every","types","result","toSelector","Array","from","$","default","querySelectorAll","i","children","removeHighlights","_jquery","__esModule"],"mappings":"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"}