{"version":3,"sources":["../src/highlighting.js"],"names":["root","range","types","RangeAnchor","TextPositionAnchor","TextQuoteAnchor","result","type","anchor","fromRange","push","toSelector","error","annotation","highlight","resolveAnchor","highlights","highlightRange","id","color","forEach","h","_annotation","target","anchors","map","locate","selector","some","s","htmlAnchor","textRange","TextRange","err","$orphan","length","every","toRange","annotationid","cssClass","textNodes","wholeTextNodesInRange","textNodeSpans","prevNode","currentSpan","node","nextSibling","filter","span","test","nodeValue","nodes","highlightEl","document","createElement","className","style","backgroundColor","parent","parentNode","replaceChild","appendChild","collapsed","commonAncestorContainer","nodeType","Node","ELEMENT_NODE","parentElement","nodeIter","ownerDocument","createNodeIterator","NodeFilter","SHOW_TEXT","nextNode","isNodeInRange","text","startContainer","startOffset","splitText","endContainer","endOffset","data","childNodes","comparePoint","e","querySelector","options","selectors","position","quote","hint","start","maybeAssertQuote","exact","toString","Error","queryselector","fromSelector","removeAllTempHighlights","Array","from","querySelectorAll","removeHighlights","i","children","replaceWith","replacements","r","insertBefore","remove"],"mappings":"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","sourcesContent":["/**\n * Functions for the highlighting and anchoring of annotations.\n *\n * This code originaly is from the Hypothesis project (https://github.com/hypothesis/client)\n * which is released under the 2-Clause BSD License (https://opensource.org/licenses/BSD-2-Clause),\n * sometimes referred to as the \"Simplified BSD License\".\n */\n\nimport $ from 'jquery';\nimport {RangeAnchor, TextPositionAnchor, TextQuoteAnchor} from './types';\nimport {TextRange} from './text-range';\n\n/**\n * Get anchors for new annnotation.\n *\n * @param {Element} root\n * @param {Range} range\n * @return {object} - Array with the anchors.\n */\nexport function describe(root, range) {\n    const types = [RangeAnchor, TextPositionAnchor, TextQuoteAnchor];\n    const result = [];\n\n    for (let type of types) {\n      try {\n        const anchor = type.fromRange(root, range);\n\n        result.push(anchor.toSelector());\n      } catch (error) {\n        continue;\n      }\n    }\n    return result;\n}\n\n/**\n * Anchor an annotation's selectors in the document.\n *\n * _Anchoring_ resolves a set of selectors to a concrete region of the document\n * which is then highlighted.\n *\n * Any existing anchors associated with `annotation` will be removed before\n * re-anchoring the annotation.\n *\n * @param {AnnotationData} annotation\n * @param {obj} root\n * @return {obj} achor object\n */\n export function anchor(annotation, root) {\n    /**\n     * Resolve an annotation's selectors to a concrete range.\n     *\n     * @param {Target} target\n     * @return {obj}\n     */\n    const locate = target => {\n\n      // Only annotations with an associated quote can currently be anchored.\n      // This is because the quote is used to verify anchoring with other selector\n      // types.\n      if (\n        !target.selector ||\n        !target.selector.some(s => s.type === 'TextQuoteSelector')\n      ) {\n        return {annotation, target};\n      }\n\n      /** @type {Anchor} */\n      let anchor;\n      try {\n        const range = htmlAnchor(root, target.selector);\n        // Convert the `Range` to a `TextRange` which can be converted back to\n        // a `Range` later. The `TextRange` representation allows for highlights\n        // to be inserted during anchoring other annotations without \"breaking\"\n        // this anchor.\n\n\n        const textRange = TextRange.fromRange(range);\n\n        anchor = {annotation, target, range: textRange};\n\n      } catch (err) {\n\n        anchor = {annotation, target};\n      }\n\n      return anchor;\n    };\n\n    /**\n     * Highlight the text range that `anchor` refers to.\n     *\n     * @param {Anchor} anchor\n     */\n    const highlight = anchor => {\n\n      const range = resolveAnchor(anchor);\n\n      if (!range) {\n        return;\n      }\n\n      let highlights = [];\n\n      if (annotation.annotation) {\n        highlights = highlightRange(range, annotation.annotation.id, 'annotated', annotation.annotation.color);\n      } else {\n        highlights = highlightRange(range, false, 'annotated_temp');\n      }\n\n      highlights.forEach(h => {\n        h._annotation = anchor.annotation;\n      });\n      anchor.highlights = highlights;\n\n    };\n\n    // Remove existing anchors for this annotation.\n    // this.detach(annotation, false /* notify */); // To be replaced by own method\n\n    // Resolve selectors to ranges and insert highlights.\n    if (!annotation.target) {\n      annotation.target = [];\n    }\n    const anchors = annotation.target.map(locate);\n\n    for (let anchor of anchors) {\n\n        highlight(anchor);\n    }\n\n    // Set flag indicating whether anchoring succeeded. For each target,\n    // anchoring is successful either if there are no selectors (ie. this is a\n    // Page Note) or we successfully resolved the selectors to a range.\n    annotation.$orphan =\n      anchors.length > 0 &&\n      anchors.every(anchor => anchor.target.selector && !anchor.range);\n\n    return anchors;\n}\n\n/**\n * Resolve an anchor's associated document region to a concrete `Range`.\n *\n * This may fail if anchoring failed or if the document has been mutated since\n * the anchor was created in a way that invalidates the anchor.\n *\n * @param {Anchor} anchor\n * @return {Range|null}\n */\nfunction resolveAnchor(anchor) {\n\n    if (!anchor.range) {\n      return null;\n    }\n    try {\n      return anchor.range.toRange();\n    } catch {\n      return null;\n    }\n}\n\n/**\n * Wraps the DOM Nodes within the provided range with a highlight\n * element of the specified class and returns the highlight Elements.\n *\n * Modified for handling annotations.\n *\n * @param {Range} range - Range to be highlighted\n * @param {int} annotationid - ID of annotation\n * @param {string} cssClass - A CSS class to use for the highlight\n * @param {string} color - Color of the highlighting\n * @return {HighlightElement[]} - Elements wrapping text in `normedRange` to add a highlight effect\n */\n function highlightRange(range, annotationid = false, cssClass = 'annotated', color = 'FFFF00') {\n\n    const textNodes = wholeTextNodesInRange(range);\n\n    // Group text nodes into spans of adjacent nodes. If a group of text nodes are\n    // adjacent, we only need to create one highlight element for the group.\n    let textNodeSpans = [];\n    let prevNode = null;\n    let currentSpan = null;\n\n    textNodes.forEach(node => {\n        if (prevNode && prevNode.nextSibling === node) {\n            currentSpan.push(node);\n        } else {\n            currentSpan = [node];\n            textNodeSpans.push(currentSpan);\n        }\n        prevNode = node;\n    });\n\n    // Filter out text node spans that consist only of white space. This avoids\n    // inserting highlight elements in places that can only contain a restricted\n    // subset of nodes such as table rows and lists.\n    const whitespace = /^\\s*$/;\n    textNodeSpans = textNodeSpans.filter(span =>\n        // Check for at least one text node with non-space content.\n        span.some(node => !whitespace.test(node.nodeValue))\n    );\n\n    // Wrap each text node span with a `<span>` element.\n    const highlights = /** @type {HighlightElement[]} */ ([]);\n\n    textNodeSpans.forEach(nodes => {\n        const highlightEl = document.createElement('margic-highlight');\n        highlightEl.className = cssClass;\n\n        if (annotationid) {\n            highlightEl.className += ' ' + cssClass + '-' + annotationid;\n            highlightEl.style = \"text-decoration:underline; text-decoration-color: #\" + color;\n            highlightEl.id = cssClass + '-' + annotationid;\n            highlightEl.style.backgroundColor = '#' + color;\n        }\n\n        const parent = /** @type {Node} */ (nodes[0].parentNode);\n        parent.replaceChild(highlightEl, nodes[0]);\n        nodes.forEach(node => highlightEl.appendChild(node));\n\n        highlights.push(highlightEl);\n\n    });\n\n    return highlights;\n}\n\n/**\n * Return text nodes which are entirely inside `range`.\n *\n * If a range starts or ends part-way through a text node, the node is split\n * and the part inside the range is returned.\n *\n * @param {Range} range\n * @return {Text[]}\n */\n function wholeTextNodesInRange(range) {\n    if (range.collapsed) {\n        // Exit early for an empty range to avoid an edge case that breaks the algorithm\n        // below. Splitting a text node at the start of an empty range can leave the\n        // range ending in the left part rather than the right part.\n        return [];\n    }\n\n    /** @type {Node|null} */\n    let root = range.commonAncestorContainer;\n    if (root.nodeType !== Node.ELEMENT_NODE) {\n        // If the common ancestor is not an element, set it to the parent element to\n        // ensure that the loop below visits any text nodes generated by splitting\n        // the common ancestor.\n        //\n        // Note that `parentElement` may be `null`.\n        root = root.parentElement;\n    }\n\n    if (!root) {\n        // If there is no root element then we won't be able to insert highlights,\n        // so exit here.\n        return [];\n    }\n\n    const textNodes = [];\n    const nodeIter = /** @type {Document} */ (\n       root.ownerDocument\n    ).createNodeIterator(\n        root,\n        NodeFilter.SHOW_TEXT // Only return `Text` nodes.\n    );\n    let node;\n    while ((node = nodeIter.nextNode())) {\n        if (!isNodeInRange(range, node)) {\n           continue;\n        }\n        let text = /** @type {Text} */ (node);\n\n        if (text === range.startContainer && range.startOffset > 0) {\n            // Split `text` where the range starts. The split will create a new `Text`\n           // node which will be in the range and will be visited in the next loop iteration.\n           text.splitText(range.startOffset);\n           continue;\n        }\n\n        if (text === range.endContainer && range.endOffset < text.data.length) {\n            // Split `text` where the range ends, leaving it as the part in the range.\n           text.splitText(range.endOffset);\n       }\n\n       textNodes.push(text);\n    }\n\n    return textNodes;\n}\n\n/**\n * Returns true if any part of `node` lies within `range`.\n *\n * @param {Range} range\n * @param {Node} node\n * @return {bool} - If node is in range\n */\nfunction isNodeInRange(range, node) {\n    try {\n        const length = node.nodeValue?.length ?? node.childNodes.length;\n       return (\n           // Check start of node is before end of range.\n           range.comparePoint(node, 0) <= 0 &&\n           // Check end of node is after start of range.\n           range.comparePoint(node, length) >= 0\n       );\n    } catch (e) {\n        // `comparePoint` may fail if the `range` and `node` do not share a common\n       // ancestor or `node` is a doctype.\n       return false;\n   }\n}\n\n/**\n * @param {RangeAnchor|TextPositionAnchor|TextQuoteAnchor} anchor\n * @param {Object} [options]\n * @return {obj} - range\n */\n function querySelector(anchor, options = {}) {\n\n    return anchor.toRange(options);\n}\n\n/**\n * Anchor a set of selectors.\n *\n * This function converts a set of selectors into a document range.\n * It encapsulates the core anchoring algorithm, using the selectors alone or\n * in combination to establish the best anchor within the document.\n *\n * @param {Element} root - The root element of the anchoring context.\n * @param {Selector[]} selectors - The selectors to try.\n * @param {Object} [options]\n * @return {object} the query selector\n */\n function htmlAnchor(root, selectors, options = {}) {\n    let position = null;\n    let quote = null;\n    let range = null;\n\n    // Collect all the selectors\n    for (let selector of selectors) {\n      switch (selector.type) {\n        case 'TextPositionSelector':\n          position = selector;\n          options.hint = position.start; // TextQuoteAnchor hint\n          break;\n        case 'TextQuoteSelector':\n          quote = selector;\n          break;\n        case 'RangeSelector':\n          range = selector;\n          break;\n      }\n    }\n\n    /**\n     * Assert the quote matches the stored quote, if applicable\n     * @param {Range} range\n     * @return {Range} range\n     */\n    const maybeAssertQuote = range => {\n\n      if (quote?.exact && range.toString() !== quote.exact) {\n        throw new Error('quote mismatch');\n      } else {\n        return range;\n      }\n    };\n\n    let queryselector = false;\n\n    try {\n        if (range) {\n\n          let anchor = RangeAnchor.fromSelector(root, range);\n\n          queryselector = querySelector(anchor, options);\n\n          if (queryselector) {\n            return queryselector;\n          } else {\n            return maybeAssertQuote;\n          }\n        }\n    } catch (error) {\n        try {\n            if (position) {\n\n                let anchor = TextPositionAnchor.fromSelector(root, position);\n\n                queryselector = querySelector(anchor, options);\n                if (queryselector) {\n                    return queryselector;\n                  } else {\n                    return maybeAssertQuote;\n                  }\n            }\n        } catch (error) {\n            try {\n                if (quote) {\n\n                    let anchor = TextQuoteAnchor.fromSelector(root, quote);\n\n                    queryselector = querySelector(anchor, options);\n\n                    return queryselector;\n                }\n            } catch (error) {\n                return false;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Remove all temporary highlights under a given root element.\n */\n export function removeAllTempHighlights() {\n    const highlights = Array.from($('body')[0].querySelectorAll('.annotated_temp'));\n    if (highlights !== undefined && highlights.length != 0) {\n        removeHighlights(highlights);\n    }\n}\n\n/**\n * Remove highlights from a range previously highlighted with `highlightRange`.\n *\n * @param {HighlightElement[]} highlights - The highlight elements returned by `highlightRange`\n */\n function removeHighlights(highlights) {\n\n    for (var i = 0; i < highlights.length; i++) {\n        if (highlights[i].parentNode) {\n            const children = Array.from(highlights[i].childNodes);\n            replaceWith(highlights[i], children);\n        }\n    }\n}\n\n/**\n * Replace a child `node` with `replacements`.\n *\n * nb. This is like `ChildNode.replaceWith` but it works in older browsers.\n *\n * @param {ChildNode} node\n * @param {Node[]} replacements\n */\nfunction replaceWith(node, replacements) {\n    const parent = /** @type {Node} */ (node.parentNode);\n\n    replacements.forEach(r => parent.insertBefore(r, node));\n    node.remove();\n}"],"file":"highlighting.min.js"}